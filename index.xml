<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title/><link>https://obsidian.codeplayer.org/</link><description>Recent content on</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sun, 16 Apr 2023 15:09:54 +0800</lastBuildDate><atom:link href="https://obsidian.codeplayer.org/index.xml" rel="self" type="application/rss+xml"/><item><title>YubiKey配置</title><link>https://obsidian.codeplayer.org/CS/%E5%AE%89%E5%85%A8/YubiKey%E9%85%8D%E7%BD%AE/</link><pubDate>Sun, 16 Apr 2023 15:09:54 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/%E5%AE%89%E5%85%A8/YubiKey%E9%85%8D%E7%BD%AE/</guid><description>初始化设置 https://xiaoqiang.blog/yubikey-shiyong/
设置PIV功能的PIN和PUK
设置FIDO2功能的PIN
设置OTP功能
操作系统登录 Mac登陆配置 https://support.yubico.com/hc/en-us/articles/360016649059-Using-Your-YubiKey-as-a-Smart-Card-in-macOS
注意需要在Yubikey Manger的Applications &amp;gt; PIV里，点击setup for macOS</description></item><item><title>玩转YubiKey</title><link>https://obsidian.codeplayer.org/CS/%E5%AE%89%E5%85%A8/%E7%8E%A9%E8%BD%ACYubikey/</link><pubDate>Sun, 16 Apr 2023 12:23:09 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/%E5%AE%89%E5%85%A8/%E7%8E%A9%E8%BD%ACYubikey/</guid><description>什么是YubiKey 官方解释 [!info] 官方解释 The YubiKey is a form of 2 Factor Authentication (2FA) which works as an extra layer of security to your online accounts.</description></item><item><title>工具分享</title><link>https://obsidian.codeplayer.org/%E5%B7%A5%E5%85%B7%E5%88%86%E4%BA%AB/</link><pubDate>Sun, 16 Apr 2023 10:56:48 +0800</pubDate><guid>https://obsidian.codeplayer.org/%E5%B7%A5%E5%85%B7%E5%88%86%E4%BA%AB/</guid><description>基础设施 服务器 deskmini 介绍 ![[assets/Pasted image 20230416112309.png]]
小型化APU平台，体积仅1.92升 最大支持内存64G 2x M.2 PCIe Gen3 x4 + 2x 2.5&amp;quot; SATA 6Gb SSD/HDD 可以将其中一个M.</description></item><item><title>系统资源计算</title><link>https://obsidian.codeplayer.org/CS/Linux/%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90%E8%AE%A1%E7%AE%97/</link><pubDate>Sun, 09 Apr 2023 17:22:36 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Linux/%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90%E8%AE%A1%E7%AE%97/</guid><description>内存 VIRT 进程“需要的”虚拟内存大小，包括进程使用的库、代码、数据，以及malloc、new分配的堆空间和分配的栈空间等； 假如进程新申请10MB的内存，但实际只使用了1MB，那么它会增长10MB，而不是实际的1MB使用量。 VIRT = SWAP + RES RES 进程当前使用的内存大小，包括使用中的malloc、new分配的堆空间和分配的栈空间，但不包括swap out量； 包含其他进程的共享； 如果申请10MB的内存，实际使用1MB，它只增长1MB，与VIRT相反； 关于库占用内存的情况，它只统计加载的库文件所占内存大小。 RES = CODE + DATA SHR 除了自身进程的共享内存，也包括其他进程的共享内存； 虽然进程只使用了几个共享库的函数，但它包含了整个共享库的大小； 计算某个进程所占的物理内存大小公式：RES – SHR； swap out后，它将会降下来。</description></item><item><title>APIServer</title><link>https://obsidian.codeplayer.org/CS/Kubernetes/APIServer/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Kubernetes/APIServer/</guid><description>API Server kube-apiserver是Kubernetes最重要的核心组件之一，主要提供以下的功能
提供集群管理的REST API接口，包括认证授权、数据校验以及集群状态变更等
提供其他模块之间的数据交互和通信的枢纽（其他模块通过API Server查询或修改数据，只有API Server才直接操作etcd）
访问控制概览 Kubernetes API的每个请求都会经过多阶段的访问控制之后才会被接受，这包括认证、授权以及准入控制（Admission Control）等。
访问控制细节 认证 开启TLS时，所有的请求都需要首先认证。Kubernetes支持多种认证机制，并支持同时开启多个认证插件（只要有一个认证通过即可）。如果认证成功，则用户的username会传入授权模块做进一步授权验证；而对于认证失败的请求则返回HTTP 401。
认证插件 X509证书 使用X509客户端证书只需要API Server启动时配置&amp;ndash;client-ca-file=SOMEFILE。在证书认证时，其CN域用作用户名，而组织机构域则用作group名。 静态Token文件 使用静态Token文件认证只需要API Server启动时配置&amp;ndash;token-auth-file=SOMEFILE。 该文件为csv格式，每行至少包括三列token,username,user id， token,user,uid,&amp;quot;group1,group2,group3” 引导Token 为了支持平滑地启动引导新的集群，Kubernetes 包含了一种动态管理的持有者令牌类型， 称作 启动引导令牌（BootstrapToken）。 这些令牌以 Secret 的形式保存在 kube-system 名字空间中，可以被动态管理和创建。 控制器管理器包含的 TokenCleaner 控制器能够在启动引导令牌过期时将其删除。 在使用kubeadm部署Kubernetes时，可通过kubeadm token list命令查询。 静态密码文件 需要API Server启动时配置&amp;ndash;basic-auth-file=SOMEFILE，文件格式为csv，每行至少三列password, user, uid，后面是可选的group名 password,user,uid,&amp;quot;group1,group2,group3” ServiceAccount ServiceAccount是Kubernetes自动生成的，并会自动挂载到容器的/run/secrets/kubernetes.</description></item><item><title>CNI</title><link>https://obsidian.codeplayer.org/CS/Kubernetes/CNI/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Kubernetes/CNI/</guid><description>CNI Kubernetes 网络模型设计的基础原则是：
所有的 Pod 能够不通过 NAT就能相互访问。 所有的节点能够不通过NAT就能相互访问。 容器内看见的 IP地址和外部组件看到的容器 IP是一样的。 Kubernetes 的集群里，IP地址是以 Pod为单位进行分配的，每个 Pod都拥有一个独立的 IP地址。一个Pod内部的所有容器共享一个网络栈，即宿主机上的一个网络命名空间，包括它们的IP 地址、网络设备、配置等都是共享的。也就是说，Pod 里面的所有容器能通过localhost:port来连接对方。在Kubernetes中，提供了一个轻量的通用容器网络接口 CNI（Container Network Interface），专门用于设置和删除容器的网络连通性。容器运行时通过 CNI调用网络插件来完成容器的网络设置。</description></item><item><title>Controller Manager</title><link>https://obsidian.codeplayer.org/CS/Kubernetes/Controller-Manager/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Kubernetes/Controller-Manager/</guid><description>控制器的工作流程 Informer 的内部机制 控制器的协同工作原理 通用 Controller Job Controller：处理job。
Pod AutoScaler：处理 pod 的自动缩容/扩容。
RelicaSet：依据 Replicaset Spec 创建 Pod。</description></item><item><title>CRI</title><link>https://obsidian.codeplayer.org/CS/Kubernetes/CRI/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Kubernetes/CRI/</guid><description>CRI 容器运行时（Container Runtime），运行于Kubernetes（k8s）集群的每个节点中，负责容器的整个生命周期。其中 Docker 是目前应用最广的。随着容器云的发展，越来越多的容器运行时涌现。为了解决这些容器运行时和 Kubernetes 的集成问题，在 Kubernetes1.5版本中，社区推出了CRI（Container Runtime Interface，容器运行时接口）以支持更多的容器运行时。
CRI是 Kubernetes定义的一组 gRPC服务。kubelet作为客户端，基于gRPC框架，通过 Socket 和容器运行时通信。 它包括两类服务∶镜像服务（Image Service）和运行时服务（Runtime Service）。 镜像服务提供下载、检查和删除镜像的远程程序调用。 运行时服务 包含用于管理容器生命周期，以及与容器交互的调用（exeC/ attach/ port-forward）的远程程序调用。</description></item><item><title>CSI</title><link>https://obsidian.codeplayer.org/CS/Kubernetes/CSI/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Kubernetes/CSI/</guid><description>容器运行时存储 除外挂存储卷外，容器启动后，运行时所需文件系统性能直接影响容器性能；
早期的 Docker 采用 Device Mapper 作为容器运行时存储驱动，因为 OverlayFS尚未合并进Kernel；
目前 Docker 和 containerd都默认以OverlayFS 作为运行时存储驱动；
OverlayFS目前已经有非常好的性能，与DeviceMapper 相比优 20%，与操作主机文件性能几乎一致
存储卷插件管理 Kubernetes支持以插件的形式来实现对不同存储的支持和扩展，这些扩展基于如下三种方式：
out-of-tree CSI插件 CSI 通过 RPC与存储驱动进行交互。</description></item><item><title>DDD领域驱动设计</title><link>https://obsidian.codeplayer.org/CS/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/</guid><description>基础 Domain-Driven Design Domain-Driven Design：基于 领域 的工程设计。
领域暂时可以将其理解为“业务问题的范畴“。
领域可大可小，对应着大小业务问题的边界。简单来说，领域驱动设计就是将业务上要做的一件大事，通过推演和抽象，拆分成多个内聚的领域。
面向接口编程，高内聚、低耦合。
DP(Domain Primitive) 构建领域的基础类型。作用：明确接口语义、内聚隐性逻辑、简化单元测试。
定义：在 DDD里，DP 可以说是一切模型、方法、架构的基础。它是在特定领域、拥有精准定义、可以自我验证、拥有行为的对象。可以认为是领域的最小组成部分。
DP三条原则：
让隐性的概念显性化
让隐性的上下文显性化
封装多对象行为</description></item><item><title>Devices</title><link>https://obsidian.codeplayer.org/Apple/Devices/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/Apple/Devices/</guid><description> iPhone 14 Pro AirPods Pro Macbook Pro 2021 M1 Pro [[iPad]] Air 5 Apple Watch S7</description></item><item><title>Dockerfile</title><link>https://obsidian.codeplayer.org/CS/Docker/Dockerfile/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Docker/Dockerfile/</guid><description>回顾 12 Factor 之进程 [[系统架构#12 factors|12 factors]]
运行环境中，应用程序通常是以一个和多个进程运行的。 12-Factor 应用的进程必须无状态（Stateless）且无共享（Share nothing）。 任何需要持久化的数据都要存储在后端服务内，比如数据库。 应在构建阶段将源代码编译成待执行应用。 Session Sticky 是 12-Factor 极力反对的。 Session 中的数据应该保存在诸如 Memcached 或 Redis 这样的带有过期时间的缓存中 Docker 遵循以上原则管理和构建应用。 理解构建上下文（Build Context） 当运行 docker build 命令时，当前工作目录被称为构建上下文。 docker build 默认查找当前目录的 Dockerfile 作为构建输入，也可以通过 –f 指定 Dockerfile。 docker build –f .</description></item><item><title>etcd</title><link>https://obsidian.codeplayer.org/CS/Kubernetes/etcd/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Kubernetes/etcd/</guid><description>etcd Etcd是CoreOS基于Raft开发的分布式key-value存储，可用于服务发现、共享配置以及一致性保障（如数据库选主、分布式锁等）。
在分布式系统中，如何管理节点间的状态一直是一个难题，etcd像是专门为集群环境的服务发现和注册而设计，它提供了数据TTL失效、数据改变监视、多值、目录监听、分布式锁原子操作等功能，可以方便的跟踪并管理集群节点的状态。
键值对存储：将数据存储在分层组织的目录中，如同在标准文件系统中 监测变更：监测特定的键或目录以进行更改，并对值的更改做出反应 简单: curl可访问的用户的API（HTTP+JSON） 安全: 可选的SSL客户端证书认证 快速: 单实例每秒1000次写操作，2000+次读操作 可靠: 使用Raft算法保证一致性 主要功能 基本的key-value存储 监听机制 key的过期及续约机制，用于监控和服务发现 原子Compare And Swap和Compare And Delete，用于分布式锁和leader选举 使用场景 也可以用于键值对存储，应用程序可以读取和写入 etcd 中的数据 etcd 比较多的应用场景是用于服务注册与发现 基于监听机制的分布式异步系统 键值对存储 etcd 是一个键值存储的组件，其他的应用都是基于其键值存储的功能展开。</description></item><item><title>GMP</title><link>https://obsidian.codeplayer.org/CS/Golang/GMP/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Golang/GMP/</guid><description>有关系统的进程和进程的知识，可参考 [[Linux进程]]
协程 进程： 分配系统资源（CPU 时间、内存等）基本单位 有独立的内存空间，切换开销大 线程：进程的一个执行流，是 CPU 调度并能独立运行的的基本单位 同一进程中的多线程共享内存空间，线程切换代价小 多线程通信方便 从内核层面来看线程其实也是一种特殊的进程，它跟父进程共享了打开的文件和文件系统信息，共享了地址空间和信号处理函数 协程 Go 语言中的轻量级线程实现 Golang 在 runtime、系统调用等多方面对 goroutine 调度进行了封装和处理，当遇到长时间执行或者进行系统调用时，会主动把当前 goroutine 的 CPU (P) 转让出去，让其他 goroutine 能被调度并执行，也就是 Golang 从语言层面支持了协程 线程和协程的差异 每个 goroutine (协程) 默认占用内存远比 Java 、C 的线程少 goroutine：2KB 线程：8MB 线程/goroutine 切换开销方面，goroutine 远比线程小 线程：涉及模式切换(从用户态切换到内核态)、16个寄存器、PC、SP&amp;hellip;等寄存器的刷新 goroutine：只有三个寄存器的值修改 - PC / SP / DX.</description></item><item><title>Headless</title><link>https://obsidian.codeplayer.org/CS/Kubernetes/Headless/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Kubernetes/Headless/</guid><description>Headless和ClusterIP的区别 CoreDNS的作用：在K8S里，我们想要通过name来访问服务的方式就是在Deployment上面添加一层Service，这样我们就可以通过Service name来访问服务了，那其中的原理就是和CoreDNS有关，它将Service name解析成Cluster IP。
这样我们访问Cluster IP的时候就通过Cluster IP作负载均衡，把流量分布到各个POD上面。
K8s中资源的全局FQDN格式:
1 2 Service_NAME.NameSpace_NAME.Domain.LTD. Domain.LTD.=svc.cluster.local.　#这是默认k8s集群的域名。 ClusterIP ClusterIP的原理：一个Service可能对应多个EndPoint(Pod)，client访问的是Cluster IP，通过iptables规则转到Real Server，从而达到负载均衡的效果。</description></item><item><title>homelab</title><link>https://obsidian.codeplayer.org/CS/Linux/homelab/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Linux/homelab/</guid><description> 路由器 openwrt openclash zerotier K8S K9S registry harbor 支持docker镜像 支持K8S helm OSS Minio</description></item><item><title>iPad</title><link>https://obsidian.codeplayer.org/Apple/iPad/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/Apple/iPad/</guid><description> 型号 iPad Air 5 购买日期 2022-09-29 无法锁屏问题 因为通用控制 学习工具 MarginNote 3 GoodNotes 5 Prodrafts PDF Expert 贴膜 水凝膜 笔尖 洛小希2H</description></item><item><title>istio</title><link>https://obsidian.codeplayer.org/CS/Kubernetes/istio/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Kubernetes/istio/</guid><description>问题 No tracing问题 没有正确设置meshConfig.defaultConfig.tracing.zipkin.address和meshConfig.defaultConfig.tracing.sampling istioctl install --set profile=demo --set meshConfig.defaultConfig.tracing.zipkin.address=jaeger-collector.istio-system:9411 --set meshConfig.defaultConfig.tracing.sampling=100 -y 重建、更新istio后，可能需要把sidecar重启/重建 jaeger暂时使用allinone即可，因为用es做后端存储太难配置 kiali的Graph为空或prometheus没有数据 prometheus.</description></item><item><title>K0S</title><link>https://obsidian.codeplayer.org/CS/Kubernetes/K0S/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Kubernetes/K0S/</guid><description>安装K0S https://docs.k0sproject.io/v1.23.6+k0s.2/install/
curl -sSLf [https://get.k0s.sh](https://get.k0s.sh) | sudo sh sudo k0s install controller --single sudo k0s start sudo k0s status sudo k0s kubectl get nodes 卸载K0S sudo k0s stop sudo k0s reset reboot system 💡 A few small k0s fragments persist even after the reset (for example, iptables).</description></item><item><title>kube-proxy</title><link>https://obsidian.codeplayer.org/CS/Kubernetes/kube-proxy/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Kubernetes/kube-proxy/</guid><description>kube-proxy 每台机器上都运行一个kube-proxy服务，它监听API server中service和endpoint的变化情况，并通过iptables等来为服务配置负载均衡（仅支持TCP和UDP）。
kube-proxy可以直接运行在物理机上，也可以以static pod或者DaemonSet的方式运行。
kube-proxy当前支持一下几种实现
userspace：最早的负载均衡方案，它在用户空间监听一个端口，所有服务通过iptables转发到这个端口，然后在其内部负载均衡到实际的Pod。该方式最主要的问题是效率低，有明显的性能瓶颈。 iptables：目前推荐的方案，完全以iptables规则的方式来实现service负载均衡。该方式最主要的问题是在服务多的时候产生太多的iptables规则，非增量式更新会引入一定的时延，大规模情况下有明显的性能问题 ipvs：为解决iptables模式的性能问题，v1.8新增了ipvs模式，采用增量式更新，并可以保证service更新期间连接保持不断开 winuserspace∶ 同userspace，但仅工作在windows上 Linux内核处理数据包：Netfilter框架 Netfilter和iptables iptables iptables支持的锚点 kube-proxy工作原理 Kubernetes iptables规则 IPVS IPVS支持的锚点和核心函数 域名服务 Kubernetes Service通过虚拟IP地址或者节点端口为用户应用提供访问入口</description></item><item><title>Kubelet</title><link>https://obsidian.codeplayer.org/CS/Kubernetes/Kubelet/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Kubernetes/Kubelet/</guid><description>kubelet 架构 kubelet 管理 Pod 的核心流程 kubelet 每个节点上都运行一个kubelet 服务进程，默认监听 10250端口。
接收并执行 master 发来的指令； 管理 Pod及Pod 中的容器； 每个kubelet 进程会在API Server 上注册节点自身信息，定期向 master 节点汇报节点的资源使用情况，并通过 cAdvisor监控节点和容器的资源。 节点管理 节点管理主要是节点自注册和节点状态更新：</description></item><item><title>MacOS</title><link>https://obsidian.codeplayer.org/Apple/MacOS/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/Apple/MacOS/</guid><description> 解除下载程序的限制 进入 /Applications 目录，执行 xattr -r -c &amp;lt;app name&amp;gt; 查看路由 netstat -rn 查看某个网络接口由哪个程序创建 ifconfig -v &amp;lt;interface&amp;gt; | grep &amp;quot;agent domain&amp;quot; SSH到别的服务器后，中文乱码 编辑 /etc/ssh_config，注释SendEnv LANG LC_*一行即可。 SSH自动unlink GPG sockets 编辑 /etc/ssh_config，添加配置StreamLocalBindUnlink yes</description></item><item><title>Modules</title><link>https://obsidian.codeplayer.org/CS/Golang/Modules/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Golang/Modules/</guid><description>开启modules
$ go env -w GO111MODULE=on</description></item><item><title>Proxy</title><link>https://obsidian.codeplayer.org/CS/Golang/Proxy/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Golang/Proxy/</guid><description>GOPROXY 和 GOPRIVAT 为拉取 Go 依赖设置代理
export GOPROXY=https://goproxy.cn
在设置 GOPROXY 以后，默认所有依赖拉取都需要经过 proxy 连接 git repo，拉取代码，并做checksum 校验
某些私有代码仓库是 goproxy.cn 无法连接的，因此需要设置 GOPRIVATE 来声明私有代码仓库</description></item><item><title>RSS Reader</title><link>https://obsidian.codeplayer.org/RSS/RSS-Reader/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/RSS/RSS-Reader/</guid><description> 客户端 平台 是否收费 最短刷新时间 优点 缺点 Reeder 5 Mac/iOS 10$ 界面美观 收费 inoreader web/iOS 可免费使用 实时/10分钟 功能丰富 Tiny Tiny RSS web 免费 15分钟 自建 Feeder web/浏览器扩展 免费 1分钟 Feedbro 浏览器扩展 免费 5分钟 NetNewsWire Mac/iOS 免费 10分钟 FreshRSS web 免费 20分钟 自建 miniflux web 免费 无法设置 自建、简单 fluent-reader 全平台 免费 10分钟 QuiteRSS Mac/Win/Linux 免费 1秒 复古，太丑</description></item><item><title>Service</title><link>https://obsidian.codeplayer.org/CS/Kubernetes/Service/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Kubernetes/Service/</guid><description>Service对象 Service Selector Kubernetes允许将Pod对象通过标签（Label）进行标记，并通过Service Selector定义基于Pod标签的过滤规则，以便选择服务的上游应用实例 Ports Ports属性中定义了服务的端口、协议目标端口等信息 1 2 3 4 5 6 7 8 9 10 11 apiVersion:v1kind:Servicemetadata:name:nginx-serviceSpec:selector:app:nginxports:- protocol:TCPport:80targetPort:80 Endpoint对象 当Service的selector不为空时，Kubernetes EndpointController会侦听服务创建事件，创建与Service同名的Endpoint对象 selector能够选取的所有PodIP都会被配置到addresses属性中 如果此时selector所对应的filter查询不到对应的Pod，则addresses列表为空 默认配置下，如果此时对应的Pod为not ready状态，则对应的PodIP只会出现在subsets的notReadyAddresses属性中，这意味着对应的Pod还没准备好提供服务，不能作为流量转发的目标。 如果设置了PublishNotReadyAdddress为true，则无论Pod是否就绪都会被加入readyAddress list 1 2 3 4 5 6 7 8 9 10 11 12 13 14 apiVersion:v1kind:Endpointmetadata:name:nginx-servicesubsets:- addresses:- ip:10.</description></item><item><title>tmux</title><link>https://obsidian.codeplayer.org/CS/Linux/tmux/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Linux/tmux/</guid><description>快捷键 tmux窗口最大化：prefix+z</description></item><item><title>Understanding Espresso</title><link>https://obsidian.codeplayer.org/%E5%92%96%E5%95%A1/Understanding-Espresso/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/%E5%92%96%E5%95%A1/Understanding-Espresso/</guid><description>Dose (Episode #1) Extraction theory 从咖啡粉中提取可溶解物质
How much work 提取可溶解物质到杯子中是做功（work）
为了提高萃取率必须更加努力做功
用的咖啡粉越多，必须做的功也越多
The basket 粉碗是最主要的决定粉量的因素
粉碗标注大小的正负1g是应该使用的粉量大小
如果使用的粉量过少，会在粉饼顶端和冲煮头之间产生一些空隙。这会造成粉饼凌乱、糊状，这样的粉饼无法告诉你任何关于萃取时发生了什么信息，同时这也非常难以清理。
使用更多的粉量并没有任何更好的地方。传统中使用更多的粉量，是因为以前磨豆机没有定量功能，只能为了得到统一的粉量，而手动的填满粉碗。现在磨豆机有了定量功能，我们可以使用任何我们想要的粉量。
The coffee 咖啡越是深烘，萃取时需要做的功越少，越容易得到可溶解物质。</description></item><item><title>VSCode</title><link>https://obsidian.codeplayer.org/CS/%E7%BC%96%E8%BE%91%E5%99%A8/VSCode/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/%E7%BC%96%E8%BE%91%E5%99%A8/VSCode/</guid><description>多光标 按住Alt，用鼠标左键点击，可以出现多个光标，输入的代码可以在光标处同时增加。 按住Ctrl+Alt，再按键盘上向上或者向下的键，可以使一列上出现多个光标。 选中一段文字，按Shift+Alt+i，可以在每行末尾出现光标 光标放在一个地方，按Ctrl+Shift+l或者ctrl+F2，可以在页面中出现这个词的不同地方都出现光标（不区分大小写）。有时候这个快捷键的作用和F2重命名变量类似，但是它更加广泛，因为还可以对比如字符串相同的非同一变量或函数类的东西修改。 Ctrl+d，第一次按下时，它会选中光标附近的单词；第二次按下时，它会找到这个单词第二次出现的位置，创建一个新的光标，并且选中它 按Shift+Alt，再使用鼠标拖动，也可以出现竖直的列光标，同时可以选中多列。 任何光标操作，可以按Ctrl + U取消 参考资料 VSCode 又酷又实用的多光标编辑 VS Code 多光标模式 拒绝重复，你一定要学会的多光标特性 Tips 触发参数提示：Shift+Cmd+Space</description></item><item><title>Yoga Nidra</title><link>https://obsidian.codeplayer.org/Yoga-Nidra/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/Yoga-Nidra/</guid><description>什么是Yoga Nidra? 1种精神状态 介于清醒和睡眠之间的状态
1种引导式冥想 比静坐式冥想更易入门，减少因失败带来的挫败感。
1种高效的放松方式 据说45分钟的Yoga Nidra，约等于4个小时的深度睡眠。
瑜伽式睡眠，每90分钟，休息20分钟
Yoga Nidra有什么好处？ 缓解焦虑、抑郁和各种心理障碍 减少失眠、提高睡眠质量 提高认知能力 增强学习能力和记忆力 增强免疫系统功能 如何进行Yoga Nidra？ Yoga Nidra的步骤可能因引导老师不同而各有所异，但基本都包含：</description></item><item><title>zerotier-moon</title><link>https://obsidian.codeplayer.org/CS/Linux/zerotier-moon/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Linux/zerotier-moon/</guid><description>使用docker搭建 部署命令：docker run --name zerotier-moon -d --restart always -p 9993:9993/udp -v &amp;lt;zerotier-moon-config dir&amp;gt;:/var/lib/zerotier-one seedgou/zerotier-moon -4 &amp;lt;public ipv4 addression&amp;gt; 查看moon id：docker logs zerotier-moon 防火墙设置 9993端口的TCP和UDP均要打开 客户端配置 直接使用命令 zerotier-cli orbit xxxxxx xxxxxx 添加 将moon生成的配置的moons.</description></item><item><title>ZFS</title><link>https://obsidian.codeplayer.org/CS/Linux/ZFS/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Linux/ZFS/</guid><description>ARC缓存限制
需要把参数写到cmdline中，写在 /etc/modprobe.d 中不生效
GRUB_CMDLINE_LINUX=&amp;quot;zfs.zfs_arc_max=8589934592 zfs.zfs_arc_min=4294967296&amp;quot;</description></item><item><title>内存管理</title><link>https://obsidian.codeplayer.org/CS/Golang/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Golang/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid><description>堆内存管理 堆内存管理 初始化连续内存块作为堆
有内存申请的时候，Allocator 从堆内存的未分配区域分割小内存块
用链表将已分配内存连接起来
需要信息描述每个内存块的元数据：大小，是否使用，下一个内存块的地址等
TCMalloc 概览 page:内存页，一块 8K 大小的内存空间。Go 与操作系统之间的内存申请和释放，都是以page 为单位
span: 内存块，一个或多个连续的 page 组成一个 span</description></item><item><title>内核</title><link>https://obsidian.codeplayer.org/CS/Linux/%E5%86%85%E6%A0%B8/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Linux/%E5%86%85%E6%A0%B8/</guid><description>/etc/modules-load.d 与 In /etc/modprobe.d的区别
/etc/modules-load.d can only load modules, nothing more. You can’t blacklist a module and you can’t insert a module with special options.</description></item><item><title>咖啡理论</title><link>https://obsidian.codeplayer.org/%E5%92%96%E5%95%A1/%E5%92%96%E5%95%A1%E7%90%86%E8%AE%BA/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/%E5%92%96%E5%95%A1/%E5%92%96%E5%95%A1%E7%90%86%E8%AE%BA/</guid><description>意式萃取理论 Ergun公式：计算水通过粉饼的压降。压降deltaP就是水从开始接触粉饼的面，到从粉饼出来的这个面结束，这段过程中因为粉饼的阻力，造成的水的压强的损失。
u0是水的流速。
咖啡冲煮的最根本原则&amp;amp;底层逻辑 是否使用滤纸 所有带滤纸的冲煮，获得的咖啡液中的物质构成种类是一样的 味道不同的原因：物质的比例不同 不带滤纸的冲煮，还会有悬浊分散系的分子 溶解速率 咖啡萃取没有“最先萃取出来酸味物质、然后甜、最后苦”的说法 是不同风味物质的溶解速率不同，都是同时开始被萃取的 酸最容易溶解、萃取速率最快，其次甜，最后苦 同一个豆子冲煮的咖啡偏苦偏酸的原因 酸味物质都差不多一样多 偏酸的，甜味苦味物质更少，酸味更突出 偏苦的，甜味苦味物质更多，酸味没那么突出 【调节风味的基本原则】 调节豆子里面风味特征更难萃取的那一部分 例如浅烘豆子，调节甜味物质的萃取 突出酸味：降低萃取率的方法 突出甜味：提高萃取率的方法 例如深烘豆子，调节苦味物质的萃取 突出甜味：降低萃取率的方法 突出苦味：提高萃取率的方法 萃取时需要避免，严重的萃取不足和萃取过度 通过分段来控制总体萃取率 想要控制酸，只能通过改变水质的方法 https://www.</description></item><item><title>咖啡豆</title><link>https://obsidian.codeplayer.org/%E5%92%96%E5%95%A1/%E5%92%96%E5%95%A1%E8%B1%86/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/%E5%92%96%E5%95%A1/%E5%92%96%E5%95%A1%E8%B1%86/</guid><description>摩卡壶 啡舍克里奥片意式拼配：深度烘焙。227g 48.4元，0.21元/g。危地马拉、哥斯达黎加、洪都拉斯。建议配合牛奶。
菠剪咖啡成子日式深烘：深度烘焙。66.63元 250克 0.26元/克。埃塞俄比亚、哥伦比亚、巴西。建议配合牛奶。
治光师北野拼配：深度烘焙。72.6元 300克 0.24元/克。哥伦比亚、曼特宁、危地马拉和秘鲁、青尼亚、云南水洗。均衡。
M2M Casanove 意式拼配：深度烘焙。85.9元 500克 0.17元/克。埃塞俄比亚、哥伦比亚。苦味突出，没有酸味。美式和奶咖都不错。
罗马假日意式拼配：中深烘焙。61元 454克 0.13元/克。巴西、哥伦比亚、乌手达。适合做奶咖。
液体芝士SOE：中深烘焙。57.14元227克 0.25元/克。埃塞俄比亚、古姬罕贝拉。口感醇厚顺滑，口感低，无酸。配合提纯奶。
M2M热带公路意式拼配：中度烘焙。129元 500克 0.</description></item><item><title>噪音</title><link>https://obsidian.codeplayer.org/%E5%99%AA%E9%9F%B3/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/%E5%99%AA%E9%9F%B3/</guid><description>楼上 以前没感觉到楼上吵，但搬到现在这个小区后，楼上吵的不行，噪音不断，真的受不了。
砸地板 跑动 拖家具 走路声音也特别大 音乐 小区有弹钢琴的，而且不关门窗，声音传播好远。 以前小区隔壁住户天天从晚上6点到8点，唱歌两个小时，风吹雨打从不休息。 办法 找物业帮忙 找居委会帮忙 加微信告知不要再吵了 反击 - 共振音响 心态 杀不死我的必使我强大</description></item><item><title>基于Istio的高级流量管理</title><link>https://obsidian.codeplayer.org/CS/Kubernetes/%E5%9F%BA%E4%BA%8EIstio%E7%9A%84%E9%AB%98%E7%BA%A7%E6%B5%81%E9%87%8F%E7%AE%A1%E7%90%86/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Kubernetes/%E5%9F%BA%E4%BA%8EIstio%E7%9A%84%E9%AB%98%E7%BA%A7%E6%B5%81%E9%87%8F%E7%AE%A1%E7%90%86/</guid><description>微服务架构的演变 Evolution 从单块系统到微服务系统的演进 微服务架构的演进 典型的微服务业务场景 更完整的微服务架构 系统边界 微服务到服务网格还缺什么? Sidecar 的工作原理 Service Mesh 适应性</description></item><item><title>基于Kubernetes和Istio的安全保证</title><link>https://obsidian.codeplayer.org/CS/Kubernetes/%E5%9F%BA%E4%BA%8EKubernetes%E5%92%8CIstio%E7%9A%84%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Kubernetes/%E5%9F%BA%E4%BA%8EKubernetes%E5%92%8CIstio%E7%9A%84%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81/</guid><description>云原生语境下的安全保证 云原生语境下的安全保证 安全保证是贯穿软件整个生命周期的重要部分。
安全与效率有时候是相违背的。
如何将二者统一起来，提升整体效率是关键。
这需要我们将安全思想贯穿到软件开发运维的所有环节。
云原生层次模型 软件的生命周期∶开发-&amp;gt;分发→部署-&amp;gt;运行
开发环节的安全保证 SaaS 应用的 [[系统架构#12 factors|12-factor]] 设计原则的一些理念与云原生安全不谋而合。
传统的安全三元素 CIA（ConfidentialitVIntegrity和 AVailability），在云原生安全中被充分应用，如对工作负载的完整性保护，与I（Integrity）完整性保护相对应。
机密性（Confidentiality）指只有授权用户可以获取信息。 完整性（Integrity）指信息在输入和传输的过程中，不被非法授权修改和破坏，保证数据的一致性。 可用性（Availability）指保证合法用户对信息和资源的使用不会被不正当地拒绝。 **基础设施即代码（Infrastructure as Code，简称 laC）**也与云原生的实践紧密相关。</description></item><item><title>基于RSS的推送系统</title><link>https://obsidian.codeplayer.org/RSS/%E5%9F%BA%E4%BA%8ERSS%E7%9A%84%E6%8E%A8%E9%80%81%E7%B3%BB%E7%BB%9F/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/RSS/%E5%9F%BA%E4%BA%8ERSS%E7%9A%84%E6%8E%A8%E9%80%81%E7%B3%BB%E7%BB%9F/</guid><description>想法 使用RSSHUB搜索原RSS中的特定信息并生成新的RSS（刷新速度极快），再使用RSS客户端比如浏览器扩展或telegram bot读取新生成的RSS并进行推送（同样需要刷新速度极快）。
实践 订阅telegram频道 将频道username与需要搜索的关键字填到RSSHUB的路由中
将上一步RSSHUB的路由添加RSS客户端中
RSS客户端实现推送
RSS客户端最快刷新时间 [[RSS Reader]]</description></item><item><title>学习资料</title><link>https://obsidian.codeplayer.org/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/</guid><description>Bilibili
iPad、英语等技巧、资源
【iPad学英语整合版】听·说·读·写：优秀App+技巧+白嫖资源！一个视频全囊括！
obsidian
程序员使用 Obsidian 的经验 &amp;mdash; 我的工作流
主题是哪个
英语
【Udemy IELTS 排名第一的课程】雅思 7+ 备考课程</description></item><item><title>将应用迁移至Kubernetes平台</title><link>https://obsidian.codeplayer.org/CS/Kubernetes/%E5%B0%86%E5%BA%94%E7%94%A8%E8%BF%81%E7%A7%BB%E8%87%B3Kubernetes%E5%B9%B3%E5%8F%B0/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Kubernetes/%E5%B0%86%E5%BA%94%E7%94%A8%E8%BF%81%E7%A7%BB%E8%87%B3Kubernetes%E5%B9%B3%E5%8F%B0/</guid><description>应用接入最佳实践 应用容器化 目标 稳定性、可用性、性能、安全
从多维度思考高可用的问题
应用容器化的思考 容器额外开销和风险 Log driver Blocking mode Non blocking mode 共用 kernel 所以 系统参数配置共享 进程数共享-Fork bomb fd 数共享 主机磁盘共享 容器化应用的资源监控 容器中看到的资源是主机资源</description></item><item><title>常用命令</title><link>https://obsidian.codeplayer.org/CS/Docker/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Docker/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid><description>远程构建image 使用build构建 1 2 3 DOCKER_HOST=&amp;#34;ssh://user@docker-build.dev&amp;#34; docker build -t {tag} . docker use context remote-build-host &amp;amp;&amp;amp; docker build -t {tag} .</description></item><item><title>常用命令</title><link>https://obsidian.codeplayer.org/CS/Kubernetes/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Kubernetes/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid><description>Kubectl Kubectl 命令和 kubeconfig kubectl 是一个 Kubernetes 的命令行工具，它允许Kubernetes 用户以命令行的方式与 Kubernetes 交互，其默认读取配置文件 ~/.kube/config。 kubectl 会将接收到的用户请求转化为 rest 调用以rest client 的形式与 apiserver 通讯。 apiserver 的地址，用户信息等配置在 kubeconfig。 常用命令 kubectl get po –oyaml -w kubectl 可查看对象。 -oyaml 输出详细信息为 yaml 格式。 -w watch 该对象的后续变化。 -owide 以详细列表的格式查看对象。 在终端通过stdin读取inline YAML 1 2 3 4 $ kubectl apply -f - &amp;lt;&amp;lt;EOF &amp;lt;-- insert YAML content here --&amp;gt; EOF OR</description></item><item><title>常见问题</title><link>https://obsidian.codeplayer.org/CS/ElasticSearch/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/ElasticSearch/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</guid><description>Search加.keyword与不加.keyword的区别，为什么没有结果 https://segmentfault.com/q/1010000017312707
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 GET production-index-info/index_info/_search { &amp;#34;query&amp;#34;: { &amp;#34;bool&amp;#34;: { &amp;#34;minimum_should_match&amp;#34;: 0, &amp;#34;must&amp;#34;: [ { &amp;#34;term&amp;#34;: { &amp;#34;is_resolved.</description></item><item><title>搭建自己的RSS服务</title><link>https://obsidian.codeplayer.org/RSS/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84RSS%E6%9C%8D%E5%8A%A1/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/RSS/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84RSS%E6%9C%8D%E5%8A%A1/</guid><description>为什么搭建自己的RSS服务平台 基于Docker，自建难度低，迁移性好。
自建RSS订阅器平台足够强大。有filter功能等。
数据完全掌握在自己手中。可通过duplicati备份。
无广告，不担心托管平台倒闭。RSS阅读器平台经常会由于盈利或政策原因关门。
没有订阅数上限或其它恶心的限制。完全免费。
进一步压榨VPS。毕竟有这么多性能溢出！
通过插件功能可以支持内嵌Youtube、Bilibili、西瓜视频等。
将多RSS源合并成一个URL分享给他人
思路 自己搭一个 RSS Server （如 FreshRSS 或者 TTRSS ），在服务端管理自己的 RSS 源。</description></item><item><title>摩卡壶</title><link>https://obsidian.codeplayer.org/%E5%92%96%E5%95%A1/%E6%91%A9%E5%8D%A1%E5%A3%B6/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/%E5%92%96%E5%95%A1/%E6%91%A9%E5%8D%A1%E5%A3%B6/</guid><description>摩卡壶基础理论 先是小火，然后出液后改最小火，最后离火或铺满底部后离火。
加热可选导热板，可以在关火后继续缓缓释放热量。
低烘需要更多的咖啡液，深烘可以少一些，深烘可以在过热之前，提早结束萃取。同时萃取的液体越多，萃取率也就越高。
粉越细，萃取压力越高，并没有发生通道效应，同时粉越细，萃取温度越高。
但是高温萃取出来的，虽然萃取率高，味道并不是特别好。
底部加开水，放滤纸（用水稍微浸湿），小火加热直到液体流出，然后关闭火源（如果用导热板）或最小火，10秒后离开热源。
120g咖啡液，加入80-100g水
摩卡壶主要要避免过热，过热会导致非常苦。
深烘豆子不要太满，太满会造成更高的温度
如果出液太少，在萃取足够的液体之前开始喷射，有可能是咖啡豆研磨的太细了；另外还有可能是壶变热的太快，在出液后尝试使用更小火。
小壶在出液后基本可以直接离火。
摩卡壶萃取配方 摩卡新手近2个月的尝试
单阀三杯份，18g粉，意式研磨度轻压，加个滤纸，90g水出50g不到，美式或者拿铁都可
双阀两杯份，20g粉，其他参数一致，拿铁更好喝一些。
16g咖啡豆，C40 7格（比意式还细一点），热水60g，通常咖啡粉的吸水量是粉重的两倍，得到咖啡液31.6g。做美式咖啡液跟水的比例是1:6。</description></item><item><title>数据结构与算法总结</title><link>https://obsidian.codeplayer.org/CS/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</guid><description>数据结构与算法总结 数据结构 20个最常用的、最基础数据结构与算法：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；10 个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。
我们学习数据结构和算法，要学习它的由来、特性、适用的场景以及它能解决的问题。
数组 数组可以说是最基础、最简单的数据结构了。数组用一块连续的内存空间，来存储相同类型的一组数据，最大的特点就是支持随机访问，但插入、删除操作也因此变得比较低效，平均情况时间复杂度为 O(n)。在平时的业务开发中，我们可以直接使用编程语言提供的容器类，但是，如果是特别底层的开发，直接使用数组可能会更合适。
链表 链表跟数组一样，也是非常基础、非常常用的数据结构。不过链表要比数组稍微复杂，从普通的单链表衍生出来好几种链表结构，比如双向链表、循环链表、双向循环链表。
和数组相比，链表更适合插入、删除操作频繁的场景，查询的时间复杂度较高。不过，在具体软件开发中，要对数组和链表的各种性能进行对比，综合来选择使用两者中的哪一个。
写出正确链表代码的六个技巧。分别是理解指针或引用的含义、警惕指针丢失和内存泄漏、利用哨兵简化实现难度、重点留意边界条件处理，以及举例画图、辅助思考，还有多写多练。
写链表代码是最考验逻辑思维能力的。因为，链表代码到处都是指针的操作、边界条件的处理，稍有不慎就容易产生 Bug。链表代码写得好坏，可以看出一个人写代码是否够细心，考虑问题是否全面，思维是否缜密。所以，这也是很多面试官喜欢让人手写链表代码的原因。所以，这一节讲到的东西，你一定要自己写代码实现一下，才有效果。
栈 栈是一种操作受限的数据结构，只支持入栈和出栈操作。后进先出是它最大的特点。栈既可以通过数组实现，也可以通过链表来实现。**不管基于数组还是链表，入栈、出栈的时间复杂度都为 O(1)。**除此之外，我们还讲了一种支持动态扩容的顺序栈，你需要重点掌握它的均摊时间复杂度分析方法。
队列 队列最大的特点就是先进先出，主要的两个操作是入队和出队。跟栈一样，它既可以用数组来实现，也可以用链表来实现。用数组实现的叫顺序队列，用链表实现的叫链式队列。特别是长得像一个环的循环队列。在数组实现队列的时候，会有数据搬移操作，要想解决数据搬移的问题，我们就需要像环一样的循环队列。</description></item><item><title>数据迁移</title><link>https://obsidian.codeplayer.org/CS/ElasticSearch/%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/ElasticSearch/%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB/</guid><description>Elasticdump 适合数据量较小​​的场景
elasticdump --input=${SOURCE_ES}/$index --output=${DESTINATION_ES}/$index --type data --limit 1000 --overwrite true</description></item><item><title>服务发现</title><link>https://obsidian.codeplayer.org/CS/Kubernetes/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Kubernetes/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/</guid><description>服务发布 需要把服务发布至集群内部或者外部，服务的不同类型 ClusterlP(Headless) NodePort LoadBalancer ExternalName 证书管理和七层负载均衡的需求 需要gRPC负载均衡如何做? DNS需求 与上下游服务的关系 服务发布的挑战 kube-dns DNS TTL问题 Service ClusterIP只能对内 kube-proxy支持的iptables/ipvs规模有限 IPVS的性能和生产化问题 kube-proxy的drift问题 频繁的Pod变动（spec change，failover，crashloop）导致LB频繁变更 对外发布的Service需要与企业ELB即成 不支持gRPC 不支持自定义DNS和高级路由功能 Ingress Spec的成熟度?</description></item><item><title>极左、左派、右派、极右的区分与现状</title><link>https://obsidian.codeplayer.org/%E6%9E%81%E5%B7%A6%E5%B7%A6%E6%B4%BE%E5%8F%B3%E6%B4%BE%E6%9E%81%E5%8F%B3%E7%9A%84%E5%8C%BA%E5%88%86%E4%B8%8E%E7%8E%B0%E7%8A%B6/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/%E6%9E%81%E5%B7%A6%E5%B7%A6%E6%B4%BE%E5%8F%B3%E6%B4%BE%E6%9E%81%E5%8F%B3%E7%9A%84%E5%8C%BA%E5%88%86%E4%B8%8E%E7%8E%B0%E7%8A%B6/</guid><description>西方的左右派划分标准 法国大革命的口号非常动听，叫“自由、平等、博爱”。但任何激动人心的口号都有一个缺点，就是经不起推敲。每个人的天资、生存环境都是不同的，如果让每个人都“自由”发展，那么他们的财富、地位就不可能平等。如果要让每个人都在经济上“平等”，那么必然会限制强者的自由以保障弱者。左右派起源于法国制宪会议，但很快定型成与初始含义毫不相干的两个集团。其中左派比较支持平等，强调建设福利国家，更多的通过国家干预手段帮助弱者，右派比较强调自由，反对过高福利，比较支持竞争，反对国家干预，强调建立“弱”政府，反对对于强者的过多限制。但左派和右派的区别只基于对平等与自由的偏重上。左派更偏重平等一点，右派更偏重自由一点。对基本限度的平等与自由权利，均持有同样的共识。
什么是极左，什么是极右所谓极左，就是把左派的思路推向极端，突破“自由的底限”。为获得无差别的公正，而取消绝大部分的自由，为取消绝大部分的自由，必须建立一个无比强大的国家机器，将人民的一切活动处于国家的控制之下。所谓极右，如果把右派的思路推向极端，突破“平等的底限”。把反对国家限制强者推演成要强者控制国家欺凌弱者，宣称“国家就是为强者存在的”（斯托雷平），实行寡头专政，取消对弱者的一切保护，一切自由。
为什么说极左制度是伪公平？ 极左的目的是为获得经济上无差别的公正，但由于每个人能力、背景各不相同，要压制每个人的个性寻求公正，就必须实行极权。这样尽管每个人在经济上基本平等，但极权会造成权力的不平等。位高权重的，呼风唤雨，无所不为。地位卑贱的，连性命都无法保障。在权力倾轧中被淘汰下来的，往往境遇悲惨。这些大伙都很熟，我们曾经在这种制度下生存了很长时间。
为什么说极右制度是伪自由？极左到极右的角色变换这才是我想讲的东西。作为七十年代末八十年代初的一代人，小学的时候，学的是公有财产神圣不可侵犯，个人利益服从集体利益，甘做螺丝钉和驯服工具。初中的时候，学的是邓小平同志的英明论断：中国不可能出现百万富翁！高中的时候，一切都颠倒了，一部分人“先富起来”了，国有企业“卖给私人”了，工人阶级要“自己养活自己”了。上大学以后，很无奈，中国的贫富差距已经变成世界第一了。
极右制度不合理的关键在于忽视“起点平等”。刘少奇曾经握着淘粪工人时传祥的手，笑着说：“我们没有高低贵贱之分，只有分工不同。”在一个极左制度下的工厂里，虽然厂家资金的实际支配权在厂长和书记这里，但名义上是属于大家的。忽然有一天，分家了，厂长和书记拿到了厂，原先许诺给工人们的退休工资和医疗保障全都作废了，工人们每人拿到了几千元分家费。厂长对工人们说：我们现在不搞大锅饭了，大家今后要自由竞争！话虽好听，可这种“分家”方案，这种取消弱者的一切社会保障，取消一切退休金、医疗保险的“自由竞争”，难道真会是“自由”的竞争吗？
极右制度，往往表现为权贵资本主义与寡头专政。南美、东南亚模式可为前鉴。极右与右派的距离很远，离极左却是咫尺之遥。极左与极右有相同的“根”，在极左制度中，国民的财产名属全民，而支配权属于权力中心，转变成极右制度很简单，只要把“全民所有”的遮羞布拿下来就是了，直接依靠权力化公为私。
左右翼分派混乱的原因 大陆的左派、右派名词来源与欧洲不同，在中国大陆，派别的划分都是以政府为参照系的。由于历史上政府一直是极左，因此在人们思想上有一个惯性：完全支持政府的就是极左，大部分支持政府的是左派，反对政府的是右派。可以说在九十年代之前，这种划分都是比较合理的。
但现在情况变了，大家都能看到。农民问题、失业工人问题、学生就业问题，基本上都是自由主义者提出来的。按常理，自由主义应该属于右翼阵营，对平等问题的关注较弱。但在国内，连他们都开始关注平等问题，表现得“左”了。说明目前的参照系已经偏向极右。
极左阵营一分为二。有一部分人停住了追随变革的脚步。如果说工人失业、资本家入党还可以被认为是“阵痛”和“权益之计”的话，国有资产的快速私有化却是令人心下雪亮。有些地区，在九十年代末，私有经济比重还只有百分之十几，但过了四五年，就上升到百分之五十到八十。这可不是什么私有经济的“优越性”，而是大家心知肚明的国有财产瓜分。私有经济再“优越”，也不可能几年就翻上几倍的。这些是目前坚持极左的“毛派”反对“邓派”的基础。
福布斯在二零零一年给出了中国富豪排行榜，中国大陆有形形色色的排行榜，但绝没有这张有用。中国公安们就按着这张排行榜一个个查下来，富豪们纷纷入狱。我可以一个个扳着指头数下来：在排行榜上位居第二的杨斌，通过奇迹性的行政“划拨”到3000亩土地获利七十多亿，贵为朝鲜特区行政长官的身份，在吉林被捕。在排行榜上位居第三的仰融，在华晨的权钱交谊中“栽了跟头”，琅珰入狱。不多举例，大伙也能知道是哪批人“先富起来”了。
极左分裂了，不少人可以归为极左与极右派系分裂。极左称为毛派，已经失去了实际的政治权力，转移到网上成为另一类反对派。现在有些网友看见极左派和右派都在批评政府，就想当然地认为执政者是中间派，其实不然。还有一点不能忽略的是：不少极左派系转型成为民族主义派系，我认为他们的转型是为了逃避面对国内现实问题。骂日本骂美国，多容易呀，多安全呀，也不需要什么判断力，中国做的就是对的呗！哪有谈国内问题那么难？
讨论假问题的知识分子 中国知识分子除了“吃苦耐劳”，没什么特别的优点。缺点倒是很多，攀附权贵，空谈，抄袭，寡廉鲜耻的知识分子是屡见不鲜。现在是好点了，独立的，面对现实的知识分子越来越多，但我还得说上几句，中国一些善良又独立，还有点学者风范的知识分子有另一个特点，就是喜欢“白日做梦”。
怎么“白日做梦”呢？当权力迅速腐化，中国开始进行以权换钱的“原始积累”的时候。学者们开始憧憬“中产阶级”的产生会给中国“送来”民主制度和自由市场经济。当香港回归的时候。学者开始幻想“香港的多党制”会“普及”大陆。当工人纷纷下岗，贫富严重分化的时候。学者们又会认为“威权体制”下的经济增长将是“民主化”不可逾越的短暂阶段。他们从来不想，不去自己争取权益，不去推动制度民主化建设，不去抨击社会的不公，难道自由民主与公正会随着“经济增长”像天上掉馅饼一样落到国民手里吗？远看欧美各国，近看台湾韩国，民主化进程都是血与泪凝成的，好东西不会光顾睡大觉的民族。不去追求民主，哪来的民主？不去追求自由，哪来的自由？不去呼唤平等，哪来的平等？企图等着经济发展后制度“水到渠成”，笑话，没看见别人的渠都是自己挖的么？不挖渠，水到了只会把人淹死。
九十年代末期的知识界现象，叫作“自由主义与新左派的对话”。看似与国外右派与左派的对话相似。但对些什么呢？中国太平等了？中国太自由了？国内没几个人能听懂“新左派”的“后现代”论述。想想也是，跟一个吃不饱饭的人谈减肥，他能听懂么？自由主义也面临“少谈公正”的指责而纷纷转型。以前叱咤风云的厉以宁，被人指责为权贵辩护。当人们越来越关注穷人的时候，谈股份、谈市场争夺、谈MBA，意义便明显褪色了。
俺认为现在左和右的“对话”根本没有意义。左派与右派根本没有“对话的必要”。自由多一点平等少一点，还是自由少一点平等多一点，这种讨论在中国毫无意义。真正要做的是建立“自由与平等的底限”。在一个既不自由又不平等的社会，谈哪个多哪个少不是“空谈”又是什么呢？
阻止极右倾向可能为时已晚目前什么是中国最大的经济现象？我认为就是“私有化”。对此网上早已直言无忌，也有一些报刊胆子比较大，敢于直呼“私有化进程”。现实中的大多数媒体要遮掩一些，换个说法，什么“改制”、“转制”、“股份化”、“鼓励私有成分”。其实都是一个意思。</description></item><item><title>架构基础</title><link>https://obsidian.codeplayer.org/CS/Kubernetes/%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Kubernetes/%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80/</guid><description>主要组件 Kubernetes 的主节点（Master Node） API服务器：API Server 这是 Kubernetes 控制面板中唯一带有用户可访问 API 以及用户可交互的组件。API 服务器会暴露一个 RESTful 的 Kubernetes API 并使用 JSON 格式的清单文件（manifest files）。 群的数据存储：Cluster Data Store Kubernetes 使用“etcd”。这是一个强大的、稳定的、高可用的键值存储，被Kubernetes 用于长久储存所有的 API 对象。 控制管理器：Controller Manager 被称为“kube-controller manager”，它运行着所有处理集群日常任务的控制器。包括了节点控制器、副本控制器、端点（endpoint）控制器以及服务账户等。 调度器：Scheduler 调度器会监控新建的 pods（一组或一个容器）并将其分配给节点。 Kubernetes 的工作节点（Worker Node） Kubelet 负责调度到对应节点的 Pod 的生命周期管理，执行任务并将 Pod 状态报告给主节点的渠道，通过容器运行时（拉取镜像、启动和停止容器等）来运行这些容器。它还会定期执行被请求的容器的健康探测程序。 Kube-proxy 它负责节点的网络，在主机上维护网络规则并执行连接转发。它还负责对正在服务的 pods 进行负载平衡。 etcd etcd 是 CoreOS 基于 Raft 开发的分布式 key-value 存储，可用于服务发现、共享配置以及一致性保障（如数据库选主、分布式锁等）。</description></item><item><title>查询与聚合</title><link>https://obsidian.codeplayer.org/CS/ElasticSearch/%E6%9F%A5%E8%AF%A2%E4%B8%8E%E8%81%9A%E5%90%88/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/ElasticSearch/%E6%9F%A5%E8%AF%A2%E4%B8%8E%E8%81%9A%E5%90%88/</guid><description>查询和聚合的基础使用 查询数据 查询所有 match_all表示查询所有的数据，sort即按照什么字段排序
1 2 3 4 5 6 7 GET /bank/_search { &amp;#34;query&amp;#34;: { &amp;#34;match_all&amp;#34;: {} }, &amp;#34;sort&amp;#34;: [ { &amp;#34;account_number&amp;#34;: &amp;#34;asc&amp;#34; } ] } 结果</description></item><item><title>核心技术</title><link>https://obsidian.codeplayer.org/CS/Docker/%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Docker/%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/</guid><description>Docker 基于 Linux 内核的 Cgroup，Namespace，以及 Union FS 等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术，由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。
最初实现是基于 LXC，从 0.7 以后开始去除 LXC，转而使用自行开发的 Libcontainer，从 1.11 开始，则进一步演进为使用 runC 和 Containerd。
Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护，使得 Docker 技术比虚拟机技术更为轻便、快捷。</description></item><item><title>深入理解</title><link>https://obsidian.codeplayer.org/CS/Kubernetes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Kubernetes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/</guid><description>API 设计原则 所有 API 都应是声明式的
相对于命令式操作，声明式操作对于重复操作的效果是稳定的，这对于容易出现数据丢失或重复的分布式环境来说是很重要的。
声明式操作更易被用户使用，可以使系统向用户隐藏实现的细节，同时也保留了系统未来持续优化的可能性。
此外，声明式的 API 还隐含了所有的 API 对象都是名词性质的，例如 Service、Volume 这些 API 都是名词，这些名词描述了用户所
期望得到的一个目标对象。
API 对象是彼此互补而且可组合的
这实际上鼓励 API 对象尽量实现面向对象设计时的要求，即“高内聚，松耦合”，对业务相关的概念有一个合适的分解，提高分解出来的对象的可重用性。</description></item><item><title>深入理解Pod的生命周期</title><link>https://obsidian.codeplayer.org/CS/Kubernetes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pod%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Kubernetes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pod%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</guid><description>如何优雅的管理Pod的完整生命周期 Pod状态机 Pod Phase Pod Phase Pending Running Succeeded Failed Unknown kubectl get pod显示的状态信息是由podstatus 的conditions和phase计算出来的 查看pod细节 kubectl get pod $podname-oyaml 查看pod相关事件 kubectl describe pod Pod状态计算细节 如何确保Pod的高可用 避免容器进程被终止避免Pod被驱逐</description></item><item><title>生产化运维</title><link>https://obsidian.codeplayer.org/CS/Kubernetes/%E7%94%9F%E4%BA%A7%E5%8C%96%E8%BF%90%E7%BB%B4/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Kubernetes/%E7%94%9F%E4%BA%A7%E5%8C%96%E8%BF%90%E7%BB%B4/</guid><description>镜像仓库 镜像仓库 镜像仓库（Docker Registry）负责存储、管理和分发镜像。 镜像仓库管理多个Repository，Repository通过命名来区分。每个Repository包含一个或多个镜像，镜像通过镜像名称和标签（Tag）来区分。 客户端拉取镜像时，要指定三要素： 镜像仓库：要从哪一个镜像仓库拉取镜像，通常通过DNS或IP地址来确定一个镜像仓库，如hub.docker.com Repository：组织名，如cncamp 镜像名称+标签：如nginx∶latest 公有镜像仓库优势
开放：任何开发者都可以上传、分享镜像到公有镜像仓库中。
便捷：开发者可以非常方便地搜索、拉取其他开发者的镜像，避免重复造轮子。
免运维：开发者只需要关注应用开发，不必关心镜像仓库的更新、升级、维护等。</description></item><item><title>生产化集群的管理</title><link>https://obsidian.codeplayer.org/CS/Kubernetes/%E7%94%9F%E4%BA%A7%E5%8C%96%E9%9B%86%E7%BE%A4%E7%9A%84%E7%AE%A1%E7%90%86/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Kubernetes/%E7%94%9F%E4%BA%A7%E5%8C%96%E9%9B%86%E7%BE%A4%E7%9A%84%E7%AE%A1%E7%90%86/</guid><description>计算节点 生产化集群的考量 计算节点： 如何批量安装和升级计算节点的操作系统? 如何管理配置计算节点的网络信息? 如何管理不同SKU（StockKeeping Unit）的计算节点? 如何快速下架故障的计算节点? 如何快速扩缩集群的规模? 控制平面： 如何在主节点上下载、安装和升级控制平面组件及其所需的配置文件? 如何确保集群所需的其他插件，例如CoreDNS、监控系统等部署完成? 如何准备控制平面组件的各种安全证书? 如何快速升级或回滚控制平面组件的版本? 操作系统的选择 操作系统的评估与选择 通用操作系统 Ubuntu Centos Fedora 专为容器优化的操作系统 最小化操作系统 CoreOS RedHat Atomic Snappy Ubuntu Core RancherOS 操作系统的评估与选择 操作系统评估和选型的标准</description></item><item><title>疑难问题</title><link>https://obsidian.codeplayer.org/CS/git/%E7%96%91%E9%9A%BE%E9%97%AE%E9%A2%98/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/git/%E7%96%91%E9%9A%BE%E9%97%AE%E9%A2%98/</guid><description>如果理解”gpg failed to sign the data“问题</description></item><item><title>磨豆机</title><link>https://obsidian.codeplayer.org/%E5%92%96%E5%95%A1/%E7%A3%A8%E8%B1%86%E6%9C%BA/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/%E5%92%96%E5%95%A1/%E7%A3%A8%E8%B1%86%E6%9C%BA/</guid><description>磨豆机的影响因素 颗粒形状，平刀片状，萃取率更高，溶解的一致性更好。鬼齿锥刀块状，萃取率相对低。需要根据形状调整参数
粒径分布。分布越集中一致性更好，分布宽泛一点会有差异性味道。哪个更好取决于个人，没有绝对好坏
细粉，两个作用，一是增加层次感丰富性，二是堵滤纸底增加萃取率。到底细粉好不好需要根据豆子等具体判断
刀片直径，影响研磨速度，越大越快。发热家用可以基本忽略，商用发热越少越好
ek43是中国咖啡业的最大笑话，除非你是开咖啡店给别人磨豆子或者参赛要求0残粉，要不然那些钱买个同品质磨豆机还能剩很多</description></item><item><title>算法与数据结构</title><link>https://obsidian.codeplayer.org/CS/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid><description>算法与数据结构 前言 想要学习数据结构与算法，首先要掌握一个数据结构与算法中最重要的概念——复杂度分析。
这个概念究竟有多重要呢？可以这么说，它几乎占了数据结构和算法这门课的半壁江山，是数据结构和算法学习的精髓。
数据结构和算法解决的是如何更省、更快地存储和处理数据的问题，因此，我们就需要一个考量效率和资源消耗的方法，这就是复杂度分析方法。所以，如果你只掌握了数据结构和算法的特点、用法，但是没有学会复杂度分析，那就相当于只知道操作口诀，而没掌握心法。只有把心法了然于胸，才能做到无招胜有招！
我们学习数据结构和算法，要学习它的由来、特性、适用的场景以及它能解决的问题。
作为初学者，或者一个非算法工程师来说，需要掌握的20个最常用的、最基础数据结构与算法：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；10 个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。
一些可以让你事半功倍的学习技巧 边学边练，适度刷题 建议你每周花 1～2 个小时的时间，集中把学习的数据结构和算法，全都自己写出来，用代码实现一遍。这样一定会比单纯地看或者听的效果要好很多！
多问、多思考、多互动 学习最好的方法是，找到几个人一起学习，一块儿讨论切磋，有问题及时寻求老师答疑。
打怪升级学习法 学习的过程中，我们碰到最大的问题就是，坚持不下来。 是的，很多基础课程学起来都非常枯燥。为此，我自己总结了一套“打怪升级学习法”。</description></item><item><title>系统架构</title><link>https://obsidian.codeplayer.org/CS/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/</guid><description>传统分层架构 vs 微服务 微服务改造 分离微服务的方法建议： 审视并发现可以分离的业务逻辑业务逻辑 寻找天生隔离的代码模块，可以借助于静态代码分析工具 不同并发规模，不同内存需求的模块都可以分离出不同的微服务，此方法可提高资源利用率，节省成本 一些常用的可微服务化的组件： 用户和账户管理 授权和会话管理 系统配置 通知和通讯服务 照片，多媒体，元数据等 分解原则：基于 size, scope and capabilities 微服务通信 点对点 多用于系统内部多组件之间通讯；</description></item><item><title>索引</title><link>https://obsidian.codeplayer.org/CS/MongoDB/%E7%B4%A2%E5%BC%95/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/MongoDB/%E7%B4%A2%E5%BC%95/</guid><description>date created: 2023-04-03 09:41 date modified: 2023-04-05 13:57 layout: page tags: MongoDB title: &amp;ldquo;索引&amp;rdquo; 索引排序 单字段的索引，创建时不论指定升序还是降序，它查询时用的 sort 可以是任意方向的（升序或降序）。 多字段的索引按前缀匹配 排序字段的 “排序顺序”，必须和索引中的对应字段的排序顺序完全相同或完全相反。 sort 条件是 index 的前缀子集时，query 条件可以为空，也可以为任何 index 的前缀子集。 sort 条件不是 index 的前缀子集时，query 条件必须包含 index 字段中 sort 字段前方的所有字段。 数据结构 MongoDb 真的用的是 B 树吗？ 通过查阅资料，我从 MongoDb 的官网和 WiredTiger 官网找到了答案。MongoDb 官网关于存储引擎（Storage Engine）的描述写道：从 MongoDb 3.</description></item><item><title>胶囊咖啡</title><link>https://obsidian.codeplayer.org/%E5%92%96%E5%95%A1/%E8%83%B6%E5%9B%8A%E5%92%96%E5%95%A1/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/%E5%92%96%E5%95%A1/%E8%83%B6%E5%9B%8A%E5%92%96%E5%95%A1/</guid><description> nespresso 浓缩咖啡 volluto 沃鲁托 灵感之源 arpeggio 阿佩奇欧 大杯系列 Tokyo 东京唯沃托 大师匠心 Ethiopia 埃塞俄比亚 Nicaragua 尼加拉瓜 illy 中度烘焙 深度烘焙 明谦 平衡70</description></item><item><title>调度</title><link>https://obsidian.codeplayer.org/CS/Kubernetes/%E8%B0%83%E5%BA%A6/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Kubernetes/%E8%B0%83%E5%BA%A6/</guid><description>kube-scheduler kube-scheduler负责分配调度Pod 到集群内的节点上，它监听 kube-apiserver，查询还未分配
Node 的Pod，然后根据调度策略为这些 Pod 分配节点（更新 Pod 的 NodeName 字段）。
调度器需要充分考虑诸多的因素∶
公平调度； 资源高效利用； QoS； affinity和 anti-affinity； 数据本地化（data locality）； 内部负载干扰（inter-workload interference）； deadlines。 调度器 kube-scheduler 调度分为两个阶段，predicate 和 priority：</description></item><item><title>进程</title><link>https://obsidian.codeplayer.org/CS/Linux/%E8%BF%9B%E7%A8%8B/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Linux/%E8%BF%9B%E7%A8%8B/</guid><description>进程与线程 进程：资源分配的基本单位
线程：调度的基本单位
无论是线程还是进程，在 linux 中都以 task_struct 描述，从内核角度看，与进程无本质区别
Glibc 中的 pthread 库提供 NPTL（Native POSIX Threading Library）支持
进程的内存使用 CPU对内存的访问 CPU 上有个 Memory Management Unit（MMU） 单元</description></item><item><title>远程调试</title><link>https://obsidian.codeplayer.org/CS/Kubernetes/%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Kubernetes/%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/</guid><description> 原理：https://learn.microsoft.com/zh-cn/visualstudio/bridge/overview-bridge-to-kubernetes
教程：https://learn.microsoft.com/zh-cn/visualstudio/bridge/bridge-to-kubernetes-vs-code
示例：https://learn.microsoft.com/zh-cn/visualstudio/bridge/bridge-to-kubernetes-sample
安装 安装vscode 安装vscode扩展Kubernetes和Bridge to Kubernetes 安装go扩展 配置 打开项目 选择kubernetes namespace 打开命令面板，运行命令“Bridge to Kubernetes: 配置” 选择需要重定向到本地的服务 输入本地运行的程序的端口号 选择或创建调试的启动配置（与本地开发的配置相同） 选择在隔离或非隔离模式下运行，隔离模式需要转发header kubernetes-route-as 在调试中选择刚才创建的配置启动 限制 要使 Bridge to Kubernetes 成功连接，一个 pod 只能有一个容器在该 pod 中运行。 目前，Bridge to Kubernetes pod 必须是 Linux 容器。 不支持 Windows 容器。 Bridge to Kubernetes 需要提升的权限才能在开发计算机上运行，以便编辑主机文件。 Bridge to Kubernetes 不能用于已启用 Azure Dev Spaces 的群集。</description></item><item><title>部署KubeSphere</title><link>https://obsidian.codeplayer.org/CS/Kubernetes/%E9%83%A8%E7%BD%B2KubeSphere/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Kubernetes/%E9%83%A8%E7%BD%B2KubeSphere/</guid><description>安装KubeSphere 直接在k8s中安装 1 2 3 kubectl apply -f https://github.com/kubesphere/ks-installer/releases/download/v3.3.0/kubesphere-installer.yaml kubectl apply -f https://github.com/kubesphere/ks-installer/releases/download/v3.3.0/cluster-configuration.yaml 检查安装日志 kubectl logs -n kubesphere-system $(kubectl get pod -n kubesphere-system -l 'app in (ks-install, ks-installer)' -o jsonpath='{.</description></item><item><title>金句收藏</title><link>https://obsidian.codeplayer.org/%E9%87%91%E5%8F%A5%E6%94%B6%E8%97%8F/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/%E9%87%91%E5%8F%A5%E6%94%B6%E8%97%8F/</guid><description> 用心若镜，不将不迎。
这句话出自庄子《应帝王》篇，讲的是列子学道的故事。列子拜师壶子学道，好像没有学到什么一样回家了，之后三年不出门。每天帮着妻子烧火做饭好像正经工作一样，每天喂猪好像伺候人一样，各种事情在他这里不分亲疏也没有偏私，这便是“用心若镜”。
镜子内本身是空无一物的，心好像镜子一样，也就是说心中没有自己的主观偏私之见。喂猪和伺候人，在我眼中没什么区别；烧火做饭和正经工作，对我来说都同等对待。所以并不会对喂猪产生抗拒，也不会对烧火做饭不耐烦。事来了，我用一样的心境去应对处理而已。
这样首先，我不会对来寻我的物（包含事），产生抗拒心理。比如碰到自己不喜欢的事就不想做，或者往后拖。它来了就来了，走了就走了，我都能坦然接受，这就叫不将不迎。
其次，我的心会平和安宁，不与外物相构斗，不会因为它们而产生相应的情绪，这样就不会耗散心神。表现出来就是，做事心不累，不会一边不想做，一边又不得不做，而痛苦不堪，产生深深的厌烦。
https://zhuanlan.zhihu.com/p/362220510
如果一个人不想做某件事，通常不是由于客观条件不允许，而是他有下面四种心态之一：恐惧（Fear）、排斥（Rejection）、自卑（Low self-esteem）、怠惰（Laziness）。
杀不死我的必使我强大</description></item><item><title>镜像站</title><link>https://obsidian.codeplayer.org/CS/Linux/%E9%95%9C%E5%83%8F%E7%AB%99/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Linux/%E9%95%9C%E5%83%8F%E7%AB%99/</guid><description>北京外国语大学开源软件镜像站</description></item><item><title>集群联邦和Istio多集群管理</title><link>https://obsidian.codeplayer.org/CS/Kubernetes/%E9%9B%86%E7%BE%A4%E8%81%94%E9%82%A6%E5%92%8CIstio%E5%A4%9A%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Kubernetes/%E9%9B%86%E7%BE%A4%E8%81%94%E9%82%A6%E5%92%8CIstio%E5%A4%9A%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86/</guid><description>集群治理的驱动力 分布式云是未来 成本优化（Cost Effective） 更好的弹性及灵活性（Elasticity&amp;amp;Flexibility） 避免厂商锁定（Avoid Vendor Lock-in） 第一时间获取云上的新功能（Innovation） 容灾（Resilience &amp;amp;Recovery） 数据保护及风险管理（Data Protection&amp;amp;Risk Management） 提升响应速度（NetworkPerformance Improvements） 分布式云的挑战 Kubernetes单集群承载能力有限 异构的基础设施 存量资源接入 配置变更及下发 跨地域、跨机房应用部署及管理 容灾与隔离性，异地多活 弹性调度及自动伸缩 监控告警 如何应对 通过Kubernetes 屏蔽底层基础设施，提供统一的接入层 多云架构 多集群+多云 多集群管控 统一的管控面 方便接入，降低使用门槛 跨地域的集群管理 集群联邦 集群联邦的必要性 单一集群的管理规模有上限 数据库存储</description></item><item><title>面向对象</title><link>https://obsidian.codeplayer.org/CS/Golang/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Golang/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</guid><description>常用方法 可见性控制 public - 常量、变量、类型、接口、结构、函数等的名称大写 private - 非大写就只能在包内使用 继承 通过组合实现，内嵌一个或多个 struct 多态 通过接口实现，通过接口定义方法集，编写多套实现</description></item><item><title>高效休息</title><link>https://obsidian.codeplayer.org/%E9%AB%98%E6%95%88%E4%BC%91%E6%81%AF/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/%E9%AB%98%E6%95%88%E4%BC%91%E6%81%AF/</guid><description>【你为什么总是很累?】如何高效休息!</description></item></channel></rss>