<!doctype html><html lang=en><head><script async defer data-website-id=de560d7e-374a-4694-943f-f3f01b8dba46 src=https://umami.codeplayer.org:1443/umami.js></script>
<script>function _howxm(){_howxmQueue.push(arguments)}window._howxmQueue=window._howxmQueue||[],_howxm("setAppID","21c1239b-b2d0-45c5-8eab-246d8b16a9d6"),function(){if(t="howxm_script",!document.getElementById(t)){var t,e=document.createElement("script"),n=document.getElementsByTagName("script")[0];e.setAttribute("id",t),e.type="text/javascript",e.async=!0,e.src="https://static.howxm.com/sdk.js",n.parentNode.insertBefore(e,n)}}()</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-PCXDEM5E1Q"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-PCXDEM5E1Q",{anonymize_ip:!1})}</script><meta charset=utf-8><meta name=description content="etcd Etcd是CoreOS基于Raft开发的分布式key-value存储，可用于服务发现、共享配置以及一致性保障（如数据库选主、分布式锁等）。
在分布式系统中，如何管理节点间的状态一直是一个难题，etcd像是专门为集群环境的服务发现和注册而设计，它提供了数据TTL失效、数据改变监视、多值、目录监听、分布式锁原子操作等功能，可以方便的跟踪并管理集群节点的状态。
 键值对存储：将数据存储在分层组织的目录中，如同在标准文件系统中 监测变更：监测特定的键或目录以进行更改，并对值的更改做出反应 简单: curl可访问的用户的API（HTTP+JSON） 安全: 可选的SSL客户端证书认证 快速: 单实例每秒1000次写操作，2000+次读操作 可靠: 使用Raft算法保证一致性  主要功能  基本的key-value存储 监听机制 key的过期及续约机制，用于监控和服务发现 原子Compare And Swap和Compare And Delete，用于分布式锁和leader选举  使用场景  也可以用于键值对存储，应用程序可以读取和写入 etcd 中的数据 etcd 比较多的应用场景是用于服务注册与发现 基于监听机制的分布式异步系统  键值对存储 etcd 是一个键值存储的组件，其他的应用都是基于其键值存储的功能展开。"><meta property="og:title" content="etcd"><meta property="og:description" content="etcd Etcd是CoreOS基于Raft开发的分布式key-value存储，可用于服务发现、共享配置以及一致性保障（如数据库选主、分布式锁等）。
在分布式系统中，如何管理节点间的状态一直是一个难题，etcd像是专门为集群环境的服务发现和注册而设计，它提供了数据TTL失效、数据改变监视、多值、目录监听、分布式锁原子操作等功能，可以方便的跟踪并管理集群节点的状态。
 键值对存储：将数据存储在分层组织的目录中，如同在标准文件系统中 监测变更：监测特定的键或目录以进行更改，并对值的更改做出反应 简单: curl可访问的用户的API（HTTP+JSON） 安全: 可选的SSL客户端证书认证 快速: 单实例每秒1000次写操作，2000+次读操作 可靠: 使用Raft算法保证一致性  主要功能  基本的key-value存储 监听机制 key的过期及续约机制，用于监控和服务发现 原子Compare And Swap和Compare And Delete，用于分布式锁和leader选举  使用场景  也可以用于键值对存储，应用程序可以读取和写入 etcd 中的数据 etcd 比较多的应用场景是用于服务注册与发现 基于监听机制的分布式异步系统  键值对存储 etcd 是一个键值存储的组件，其他的应用都是基于其键值存储的功能展开。"><meta property="og:type" content="website"><meta property="og:image" content="https://obsidian.codeplayer.org/icon.png"><meta property="og:url" content="https://obsidian.codeplayer.org/Cards/CS/Kubernetes/etcd/"><meta property="og:width" content="200"><meta property="og:height" content="200"><meta name=twitter:card content="summary"><meta name=twitter:title content="etcd"><meta name=twitter:description content="etcd Etcd是CoreOS基于Raft开发的分布式key-value存储，可用于服务发现、共享配置以及一致性保障（如数据库选主、分布式锁等）。
在分布式系统中，如何管理节点间的状态一直是一个难题，etcd像是专门为集群环境的服务发现和注册而设计，它提供了数据TTL失效、数据改变监视、多值、目录监听、分布式锁原子操作等功能，可以方便的跟踪并管理集群节点的状态。
 键值对存储：将数据存储在分层组织的目录中，如同在标准文件系统中 监测变更：监测特定的键或目录以进行更改，并对值的更改做出反应 简单: curl可访问的用户的API（HTTP+JSON） 安全: 可选的SSL客户端证书认证 快速: 单实例每秒1000次写操作，2000+次读操作 可靠: 使用Raft算法保证一致性  主要功能  基本的key-value存储 监听机制 key的过期及续约机制，用于监控和服务发现 原子Compare And Swap和Compare And Delete，用于分布式锁和leader选举  使用场景  也可以用于键值对存储，应用程序可以读取和写入 etcd 中的数据 etcd 比较多的应用场景是用于服务注册与发现 基于监听机制的分布式异步系统  键值对存储 etcd 是一个键值存储的组件，其他的应用都是基于其键值存储的功能展开。"><meta name=twitter:image content="https://obsidian.codeplayer.org/icon.png"><title>etcd</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://obsidian.codeplayer.org//icon.png><link href=https://obsidian.codeplayer.org/styles.80333fa2099c0bee674efa435fde378c.min.css rel=stylesheet><link href=https://obsidian.codeplayer.org/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://obsidian.codeplayer.org/js/darkmode.245a0a31da505f6b327aec1fcae860c8.min.js></script>
<script src=https://obsidian.codeplayer.org/js/util.00639692264b21bc3ee219733d38a8be.min.js></script>
<link rel=preload href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css as=style onload='this.onload=null,this.rel="stylesheet"' integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/core@1.2.1></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/dom@1.2.1></script>
<script async src=https://obsidian.codeplayer.org/js/popover.aa9bc99c7c38d3ae9538f218f1416adb.min.js></script>
<script defer src=https://obsidian.codeplayer.org/js/code-title.ce4a43f09239a9efb48fee342e8ef2df.min.js></script>
<script defer src=https://obsidian.codeplayer.org/js/clipboard.2913da76d3cb21c5deaa4bae7da38c9f.min.js></script>
<script defer src=https://obsidian.codeplayer.org/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const SEARCH_ENABLED=!1,LATEX_ENABLED=!0,PRODUCTION=!0,BASE_URL="https://obsidian.codeplayer.org/",fetchData=Promise.all([fetch("https://obsidian.codeplayer.org/indices/linkIndex.8aed04344c01ff4421ca534aea1f7999.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://obsidian.codeplayer.org/indices/contentIndex.b29b07a109f5213c0a3b0cae563a4797.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://obsidian.codeplayer.org",!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!1;drawGraph("https://obsidian.codeplayer.org",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}var i=document.getElementsByClassName("mermaid");i.length>0&&import("https://unpkg.com/mermaid@9/dist/mermaid.esm.min.mjs").then(e=>{e.default.init()});function a(n){const e=n.target,t=e.className.split(" "),s=t.includes("broken"),o=t.includes("internal-link");plausible("Link Click",{props:{href:e.href,broken:s,internal:o,graph:!1}})}const r=document.querySelectorAll("a");for(link of r)link.className.includes("root-title")&&link.addEventListener("click",a,{once:!0})},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'’':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/obsidian.codeplayer.org\/js\/router.d6fe6bd821db9ea97f9aeefae814d8e7.min.js"
    attachSPARouting(init, render)
  </script><script defer data-domain=obsidian.codeplayer.org src=https://plausible.io/js/script.js></script>
<script>window.plausible=window.plausible||function(){(window.plausible.q=window.plausible.q||[]).push(arguments)}</script></head><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://obsidian.codeplayer.org/js/full-text-search.e6e2e0c213187ca0c703d6e2c7a77fcd.min.js></script><div class=singlePage><header><h1 id=page-title><a class=root-title href=https://obsidian.codeplayer.org/>Avalon Obsidian Vault</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>etcd</h1><p class=meta>Last updated
Apr 9, 2023
<a href=https://github.com/PetrusZ/avalon-obsidian-vault/tree/main/Cards/CS/Kubernetes/etcd.md rel=noopener>Edit Source</a></p><ul class=tags><li><a href=https://obsidian.codeplayer.org/tags/CS/Kubernetes/>Cs kubernetes</a></li></ul><aside class=mainTOC><details open><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#etcd>etcd</a><ol><li><a href=#主要功能>主要功能</a></li><li><a href=#使用场景>使用场景</a></li><li><a href=#键值对存储>键值对存储</a></li><li><a href=#服务注册和发现>服务注册和发现</a></li><li><a href=#消息发布与订阅>消息发布与订阅</a></li><li><a href=#核心ttl--cas>核心：TTL & CAS</a></li></ol></li><li><a href=#raft协议>Raft协议</a><ol><li><a href=#raft协议概览>Raft协议概览</a></li><li><a href=#理解raft协议>理解Raft协议</a></li><li><a href=#learner>learner</a></li><li><a href=#etcd基于raft的一致性>etcd基于Raft的一致性</a></li><li><a href=#日志复制>日志复制</a></li><li><a href=#安全性>安全性</a></li><li><a href=#失效处理>失效处理</a></li><li><a href=#wal日志>wal日志</a></li></ol></li><li><a href=#etcd-v3-存储watch以及过期机制>etcd v3 存储，Watch以及过期机制</a><ol><li><a href=#存储机制>存储机制</a></li><li><a href=#watch机制>Watch机制</a></li><li><a href=#容量管理>容量管理</a></li></ol></li><li><a href=#etcd在集群中所处的位置>etcd在集群中所处的位置</a></li><li><a href=#etcd拓扑>etcd拓扑</a></li></ol></nav></details></aside><a href=#etcd><h1 id=etcd><span class=hanchor arialabel=Anchor># </span>etcd</h1></a><p>Etcd是CoreOS基于Raft开发的分布式key-value存储，可用于服务发现、共享配置以及一致性保障（如数据库选主、分布式锁等）。</p><p>在分布式系统中，如何管理节点间的状态一直是一个难题，etcd像是专门为集群环境的服务发现和注册而设计，它提供了数据TTL失效、数据改变监视、多值、目录监听、分布式锁原子操作等功能，可以方便的跟踪并管理集群节点的状态。</p><ul><li>键值对存储：将数据存储在分层组织的目录中，如同在标准文件系统中</li><li>监测变更：监测特定的键或目录以进行更改，并对值的更改做出反应</li><li>简单: curl可访问的用户的API（HTTP+JSON）</li><li>安全: 可选的SSL客户端证书认证</li><li>快速: 单实例每秒1000次写操作，2000+次读操作</li><li>可靠: 使用Raft算法保证一致性</li></ul><a href=#主要功能><h2 id=主要功能><span class=hanchor arialabel=Anchor># </span>主要功能</h2></a><ul><li>基本的key-value存储</li><li>监听机制</li><li>key的过期及续约机制，用于监控和服务发现</li><li>原子Compare And Swap和Compare And Delete，用于分布式锁和leader选举</li></ul><a href=#使用场景><h2 id=使用场景><span class=hanchor arialabel=Anchor># </span>使用场景</h2></a><ul><li>也可以用于键值对存储，应用程序可以读取和写入 etcd 中的数据</li><li>etcd 比较多的应用场景是用于服务注册与发现</li><li>基于监听机制的分布式异步系统</li></ul><a href=#键值对存储><h2 id=键值对存储><span class=hanchor arialabel=Anchor># </span>键值对存储</h2></a><p>etcd 是一个<strong>键值存储</strong>的组件，其他的应用都是基于其键值存储的功能展开。</p><ul><li>采用kv型数据存储，一般情况下比关系型数据库快。</li><li>支持动态存储(内存)以及静态存储(磁盘)。</li><li>分布式存储，可集成为多节点集群。</li><li>存储方式，采用类似目录结构。（B+tree）<ul><li>只有叶子节点才能真正存储数据，相当于文件。</li><li>叶子节点的父节点一定是目录，目录不能存储数据。</li></ul></li></ul><a href=#服务注册和发现><h2 id=服务注册和发现><span class=hanchor arialabel=Anchor># </span>服务注册和发现</h2></a><ul><li>强一致性、高可用的服务存储目录。<ul><li>基于 Raft 算法的 etcd 天生就是这样一个强一致性、高可用的服务存储目录。</li></ul></li><li>一种注册服务和服务健康状况的机制。<ul><li>用户可以在 etcd 中注册服务，并且对注册的服务配置 key TTL，定时保持服务的心跳以达到监控健康状态的效果。</li></ul></li></ul><p><img src=https://obsidian.codeplayer.org//Extras/Images/image_1665845808268_0.png width=auto alt=image.png></p><a href=#消息发布与订阅><h2 id=消息发布与订阅><span class=hanchor arialabel=Anchor># </span>消息发布与订阅</h2></a><p>在分布式系统中，最适用的一种组件间通信方式就是消息发布与订阅。</p><p>即构建一个配置共享中心，数据提供者在这个配置中心发布消息，而消息使用者则订阅他们关心的主题，一旦主题有消息发布，就会实时通知订阅者。</p><p>通过这种方式可以做到分布式系统配置的集中式管理与动态更新。</p><p>应用中用到的一些配置信息放到etcd上进行集中管理。</p><p>应用在启动的时候主动从etcd获取一次配置信息，同时，在etcd节点上注册一个Watcher并等待，以后每次配置有更新的时候，etcd都会实时通知订阅者，以此达到获取最新配置信息的目的。</p><a href=#核心ttl--cas><h2 id=核心ttl--cas><span class=hanchor arialabel=Anchor># </span>核心：TTL & CAS</h2></a><p>TTL（time to live）指的是给一个key设置一个有效期，到期后这个key就会被自动删掉，这在很多分布式锁的实现上都会用到，可以保证锁的实时有效性。</p><p>Atomic Compare-and-Swap（CAS）指的是在对key进行赋值的时候，客户端需要提供一些条件，当这些条件满足后，才能赋值成功。这些条件包括：</p><ul><li>prevExist：key当前赋值前是否存在</li><li>prevValue：key当前赋值前的值</li><li>prevIndex：key当前赋值前的Index</li></ul><p>这样的话，key的设置是有前提的，需要知道这个key当前的具体情况才可以对其设</p><a href=#raft协议><h1 id=raft协议><span class=hanchor arialabel=Anchor># </span>Raft协议</h1></a><a href=#raft协议概览><h2 id=raft协议概览><span class=hanchor arialabel=Anchor># </span>Raft协议概览</h2></a><p>Raft协议基于quorum机制，即大多数同意原则，任何的变更都需超过半数的成员确认</p><p><img src=https://obsidian.codeplayer.org//Extras/Images/image_1665850658533_0.png width=auto alt=image.png></p><a href=#理解raft协议><h2 id=理解raft协议><span class=hanchor arialabel=Anchor># </span>理解Raft协议</h2></a><p><a href=http://thesecretlivesofdata.com/raft/ rel=noopener>http://thesecretlivesofdata.com/raft/</a></p><a href=#learner><h2 id=learner><span class=hanchor arialabel=Anchor># </span>learner</h2></a><p>Raft 4.2.1引入的新角色</p><p>当出现一个etcd集群需要增加节点时，新节点与Leader的数据差异较大，需要较多数据同步才能跟上leader的最新的数据。</p><p>此时Leader的网络带宽很可能被用尽，进而使得leader无法正常保持心跳。</p><p>进而导致follower重新发起投票。</p><p>进而可能引发etcd集群不可用。</p><p><strong>Learner角色只接收数据而不参与投票，因此增加learner节点时，集群的quorum不变。</strong></p><p><img src=https://obsidian.codeplayer.org//Extras/Images/image_1665853509499_0.png width=auto alt=image.png></p><a href=#etcd基于raft的一致性><h2 id=etcd基于raft的一致性><span class=hanchor arialabel=Anchor># </span>etcd基于Raft的一致性</h2></a><p>选举方法</p><p>初始启动时，节点处于follower状态并被设定一个election timeout，如果在这一时间周期内没有收到来自 leader 的 heartbeat，节点将发起选举：将自己切换为 candidate 之后，向集群中其它 follower节点发送请求，询问其是否选举自己成为 leader。</p><p>当收到来自集群中过半数节点的接受投票后，节点即成为 leader，开始接收保存 client 的数据并向其它的 follower 节点同步日志。如果没有达成一致，则candidate随机选择一个等待间隔（150ms ~ 300ms）再次发起投票，得到集群中半数以上follower接受的candidate将成为leader</p><p>leader节点依靠定时向 follower 发送heartbeat来保持其地位。</p><p>任何时候如果其它 follower 在 election timeout 期间都没有收到来自 leader 的 heartbeat，同样会将自己的状态切换为 candidate 并发起选举。每成功选举一次，新 leader 的任期（Term）都会比之前leader 的任期大1。</p><a href=#日志复制><h2 id=日志复制><span class=hanchor arialabel=Anchor># </span>日志复制</h2></a><p>当接Leader收到客户端的日志（事务请求）后先把该日志追加到本地的Log中，然后通过heartbeat把该Entry同步给其他Follower，Follower接收到日志后记录日志然后向Leader发送ACK，当Leader收到大多数（n/2+1）Follower的ACK信息后将该日志设置为已提交并追加到本地磁盘中，通知客户端并在下个heartbeat中Leader将通知所有的Follower将该日志存储在自己的本地磁盘中。</p><a href=#安全性><h2 id=安全性><span class=hanchor arialabel=Anchor># </span>安全性</h2></a><p>安全性是用于保证每个节点都执行相同序列的安全机制，如当某个Follower在当前Leadercommit Log时变得不可用了，稍后可能该Follower又会被选举为Leader，这时新Leader可能会用新的Log覆盖先前已committed的Log，这就是导致节点执行不同序列；Safety就是用于保证选举出来的Leader一定包含先前 committed Log的机制；</p><p>选举安全性（Election Safety）：每个任期（Term）只能选举出一个Leader</p><p>Leader完整性（Leader Completeness）：指Leader日志的完整性，当Log在任期Term1被Commit后，那么以后任期Term2、Term3…等的Leader必须包含该Log；Raft在选举阶段就使用Term的判断用于保证完整性：当请求投票的该Candidate的Term较大或Term相同Index更大则投票，否则拒绝该请求。</p><a href=#失效处理><h2 id=失效处理><span class=hanchor arialabel=Anchor># </span>失效处理</h2></a><ol><li>Leader失效：其他没有收到heartbeat的节点会发起新的选举，而当Leader恢复后由于步进数小会自动成为follower（日志也会被新leader的日志覆盖）</li></ol><p>2）follower节点不可用：follower 节点不可用的情况相对容易解决。因为集群中的日志内容始终是从 leader 节点同步的，只要这一节点再次加入集群时重新从 leader 节点处复制日志即可。</p><p>3）多个candidate：冲突后candidate将随机选择一个等待间隔（150ms ~ 300ms）再次发起投票，得到集群中半数以上follower接受的candidate将成为leader</p><a href=#wal日志><h2 id=wal日志><span class=hanchor arialabel=Anchor># </span>wal日志</h2></a><p>wal日志是二进制的，解析出来后是以上数据结构LogEntry。其中第一个字段type，只有两种，一种是0表示Normal，1表示ConfChange（ConfChange表示 Etcd 本身的配置变更同步，比如有新的节点加入等）。第二个字段是term，每个term代表一个主节点的任期，每次主节点变更term就会变化。第三个字段是index，这个序号是严格有序递增的，代表变更序号。第四个字段是二进制的data，将raft request对象的pb结构整个保存下。etcd 源码下有个tools/etcddump-logs，可以将wal日志dump成文本查看，可以协助分析Raft协议。</p><p>Raft协议本身不关心应用数据，也就是data中的部分，一致性都通过同步wal日志来实现，每个节点将从主节点收到的data apply到本地的存储，Raft只关心日志的同步状态，如果本地存储实现的有bug，比如没有正确的将data apply到本地，也可能会导致数据不一致。</p><p><img src=https://obsidian.codeplayer.org//Extras/Images/image_1665854364816_0.png width=auto alt=image.png></p><a href=#etcd-v3-存储watch以及过期机制><h1 id=etcd-v3-存储watch以及过期机制><span class=hanchor arialabel=Anchor># </span>etcd v3 存储，Watch以及过期机制</h1></a><p><img src=https://obsidian.codeplayer.org//Extras/Images/image_1665854412122_0.png width=auto alt=image.png></p><a href=#存储机制><h2 id=存储机制><span class=hanchor arialabel=Anchor># </span>存储机制</h2></a><p>etcd v3 store 分为两部分，一部分是内存中的索引，kvindex，是基于Google开源的一个Golang的btree实现的，另外一部分是后端存储。按照它的设计，backend可以对接多种存储，当前使用的boltdb。boltdb是一个单机的支持事务的kv存储，etcd 的事务是基于boltdb的事务实现的。etcd 在boltdb中存储的key是reversion，value是 etcd 自己的key-value组合，也就是说 etcd 会在boltdb中把每个版本都保存下，从而实现了多版本机制。</p><p>reversion主要由两部分组成，第一部分main rev，每次事务进行加一，第二部分sub rev，同一个事务中的每次操作加一。</p><p>etcd 提供了命令和设置选项来控制compact，同时支持put操作的参数来精确控制某个key的历史版本数。</p><p>内存kvindex保存的就是key和reversion之前的映射关系，用来加速查询。</p><p><img src=https://obsidian.codeplayer.org//Extras/Images/image_1665909521087_0.png width=auto alt=image.png></p><a href=#watch机制><h2 id=watch机制><span class=hanchor arialabel=Anchor># </span>Watch机制</h2></a><p>etcd v3 的watch机制支持watch某个固定的key，也支持watch一个范围（可以用于模拟目录的结构的watch），所以 watchGroup 包含两种watcher，一种是 key watchers，数据结构是每个key对应一组watcher，另外一种是 range watchers, 数据结构是一个 IntervalTree，方便通过区间查找到对应的watcher。</p><p>同时，每个 WatchableStore 包含两种 watcherGroup，一种是synced，一种是unsynced，前者表示该group的watcher数据都已经同步完毕，在等待新的变更，后者表示该group的watcher数据同步落后于当前最新变更，还在追赶。</p><p>当 etcd 收到客户端的watch请求，如果请求携带了revision参数，则比较请求的revision和store当前的revision，如果大于当前revision，则放入synced组中，否则放入unsynced组。同时 etcd 会启动一个后台的goroutine持续同步unsynced的watcher，然后将其迁移到synced组。也就是这种机制下，etcd v3 支持从任意版本开始watch，没有v2的1000条历史event表限制的问题（当然这是指没有compact的情况下）</p><a href=#容量管理><h2 id=容量管理><span class=hanchor arialabel=Anchor># </span>容量管理</h2></a><ul><li>单个对象不建议超过1.5M</li><li>默认容量2G</li><li>不建议超过8G</li></ul><a href=#etcd在集群中所处的位置><h1 id=etcd在集群中所处的位置><span class=hanchor arialabel=Anchor># </span>etcd在集群中所处的位置</h1></a><p><img src=https://obsidian.codeplayer.org//Extras/Images/image_1665928249958_0.png width=auto alt=image.png></p><a href=#etcd拓扑><h1 id=etcd拓扑><span class=hanchor arialabel=Anchor># </span>etcd拓扑</h1></a><p>堆叠式etcd集群的高可用拓扑</p><p>这种拓扑将相同节点上的控制平面和etcd成员耦合在一起。优点在于建立起来非常容易，并且对副本的管理也更容易。但是，堆叠式存在耦合失败的风险。如果一个节点发生故障，则etcd成员和控制平面实例都会丢失，并且集群冗余也会受到损害。可以通过添加更多控制平面节来减轻这种风险。因此为实现集群高可用应该至少运行三个堆叠的Master节点。</p><p><img src=https://obsidian.codeplayer.org//Extras/Images/image_1665928763555_0.png width=auto alt=image.png></p><p>外部etcd集群的高可用拓扑</p><p>该拓扑将控制平面和etcd成员解耦。如果丢失一个Master节点，对etcd成员的影响较小，并且不会像堆叠式拓扑那样对集群冗余产生太大影响。但是，此拓扑所需的主机数量是堆叠式拓扑的两倍。具有此拓扑的群集至少需要三个主机用于控制平面节点，三个主机用于etcd集群。</p><p><img src=https://obsidian.codeplayer.org//Extras/Images/image_1665928794361_0.png width=auto alt=image.png></p></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li>No backlinks found</li></ul></div><div><script async src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://obsidian.codeplayer.org/js/graph.6579af7b10c818dbd2ca038702db0224.js></script></div></div><div id=contact_buttons><footer><p>Made by Patrick Zhao using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, © 2023</p><ul><li><a href=https://obsidian.codeplayer.org/>Home</a></li><li><a href=https://github.com/PetrusZ>GitHub</a></li><li><a href=https://t.me/Petrus_Z>Telegram</a></li><li><a href=mailto:silencly07@gmail.com>Email</a></li></ul></footer></div><hr><script src=https://giscus.app/client.js data-repo=PetrusZ/ObsidianPublish data-repo-id=R_kgDOJTGL0A data-category=Announcements data-category-id=DIC_kwDOJTGL0M4CVohQ data-mapping=title data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=preferred_color_scheme data-lang=zh-CN crossorigin=anonymous async></script></div></body></html>