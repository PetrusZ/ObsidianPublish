<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>CS on</title><link>https://obsidian.codeplayer.org/cs/</link><description>Recent content in CS on</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sun, 09 Apr 2023 17:22:36 +0800</lastBuildDate><atom:link href="https://obsidian.codeplayer.org/cs/index.xml" rel="self" type="application/rss+xml"/><item><title>系统资源计算</title><link>https://obsidian.codeplayer.org/CS/Linux/%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90%E8%AE%A1%E7%AE%97/</link><pubDate>Sun, 09 Apr 2023 17:22:36 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Linux/%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90%E8%AE%A1%E7%AE%97/</guid><description>内存 VIRT 进程“需要的”虚拟内存大小，包括进程使用的库、代码、数据，以及malloc、new分配的堆空间和分配的栈空间等； 假如进程新申请10MB的内存，但实际只使用了1MB，那么它会增长10MB，而不是实际的1MB使用量。 VIRT = SWAP + RES RES 进程当前使用的内存大小，包括使用中的malloc、new分配的堆空间和分配的栈空间，但不包括swap out量； 包含其他进程的共享； 如果申请10MB的内存，实际使用1MB，它只增长1MB，与VIRT相反； 关于库占用内存的情况，它只统计加载的库文件所占内存大小。 RES = CODE + DATA SHR 除了自身进程的共享内存，也包括其他进程的共享内存； 虽然进程只使用了几个共享库的函数，但它包含了整个共享库的大小； 计算某个进程所占的物理内存大小公式：RES – SHR； swap out后，它将会降下来。</description></item><item><title>APIServer</title><link>https://obsidian.codeplayer.org/CS/Kubernetes/APIServer/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Kubernetes/APIServer/</guid><description>API Server kube-apiserver是Kubernetes最重要的核心组件之一，主要提供以下的功能
提供集群管理的REST API接口，包括认证授权、数据校验以及集群状态变更等
提供其他模块之间的数据交互和通信的枢纽（其他模块通过API Server查询或修改数据，只有API Server才直接操作etcd）
访问控制概览 Kubernetes API的每个请求都会经过多阶段的访问控制之后才会被接受，这包括认证、授权以及准入控制（Admission Control）等。
访问控制细节 认证 开启TLS时，所有的请求都需要首先认证。Kubernetes支持多种认证机制，并支持同时开启多个认证插件（只要有一个认证通过即可）。如果认证成功，则用户的username会传入授权模块做进一步授权验证；而对于认证失败的请求则返回HTTP 401。
认证插件 X509证书 使用X509客户端证书只需要API Server启动时配置&amp;ndash;client-ca-file=SOMEFILE。在证书认证时，其CN域用作用户名，而组织机构域则用作group名。 静态Token文件 使用静态Token文件认证只需要API Server启动时配置&amp;ndash;token-auth-file=SOMEFILE。 该文件为csv格式，每行至少包括三列token,username,user id， token,user,uid,&amp;quot;group1,group2,group3” 引导Token 为了支持平滑地启动引导新的集群，Kubernetes 包含了一种动态管理的持有者令牌类型， 称作 启动引导令牌（BootstrapToken）。 这些令牌以 Secret 的形式保存在 kube-system 名字空间中，可以被动态管理和创建。 控制器管理器包含的 TokenCleaner 控制器能够在启动引导令牌过期时将其删除。 在使用kubeadm部署Kubernetes时，可通过kubeadm token list命令查询。 静态密码文件 需要API Server启动时配置&amp;ndash;basic-auth-file=SOMEFILE，文件格式为csv，每行至少三列password, user, uid，后面是可选的group名 password,user,uid,&amp;quot;group1,group2,group3” ServiceAccount ServiceAccount是Kubernetes自动生成的，并会自动挂载到容器的/run/secrets/kubernetes.</description></item><item><title>CNI</title><link>https://obsidian.codeplayer.org/CS/Kubernetes/CNI/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Kubernetes/CNI/</guid><description>CNI Kubernetes 网络模型设计的基础原则是：
所有的 Pod 能够不通过 NAT就能相互访问。 所有的节点能够不通过NAT就能相互访问。 容器内看见的 IP地址和外部组件看到的容器 IP是一样的。 Kubernetes 的集群里，IP地址是以 Pod为单位进行分配的，每个 Pod都拥有一个独立的 IP地址。一个Pod内部的所有容器共享一个网络栈，即宿主机上的一个网络命名空间，包括它们的IP 地址、网络设备、配置等都是共享的。也就是说，Pod 里面的所有容器能通过localhost:port来连接对方。在Kubernetes中，提供了一个轻量的通用容器网络接口 CNI（Container Network Interface），专门用于设置和删除容器的网络连通性。容器运行时通过 CNI调用网络插件来完成容器的网络设置。</description></item><item><title>Controller Manager</title><link>https://obsidian.codeplayer.org/CS/Kubernetes/Controller-Manager/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Kubernetes/Controller-Manager/</guid><description>控制器的工作流程 Informer 的内部机制 控制器的协同工作原理 通用 Controller Job Controller：处理job。
Pod AutoScaler：处理 pod 的自动缩容/扩容。
RelicaSet：依据 Replicaset Spec 创建 Pod。</description></item><item><title>CRI</title><link>https://obsidian.codeplayer.org/CS/Kubernetes/CRI/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Kubernetes/CRI/</guid><description>CRI 容器运行时（Container Runtime），运行于Kubernetes（k8s）集群的每个节点中，负责容器的整个生命周期。其中 Docker 是目前应用最广的。随着容器云的发展，越来越多的容器运行时涌现。为了解决这些容器运行时和 Kubernetes 的集成问题，在 Kubernetes1.5版本中，社区推出了CRI（Container Runtime Interface，容器运行时接口）以支持更多的容器运行时。
CRI是 Kubernetes定义的一组 gRPC服务。kubelet作为客户端，基于gRPC框架，通过 Socket 和容器运行时通信。 它包括两类服务∶镜像服务（Image Service）和运行时服务（Runtime Service）。 镜像服务提供下载、检查和删除镜像的远程程序调用。 运行时服务 包含用于管理容器生命周期，以及与容器交互的调用（exeC/ attach/ port-forward）的远程程序调用。</description></item><item><title>CSI</title><link>https://obsidian.codeplayer.org/CS/Kubernetes/CSI/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Kubernetes/CSI/</guid><description>容器运行时存储 除外挂存储卷外，容器启动后，运行时所需文件系统性能直接影响容器性能；
早期的 Docker 采用 Device Mapper 作为容器运行时存储驱动，因为 OverlayFS尚未合并进Kernel；
目前 Docker 和 containerd都默认以OverlayFS 作为运行时存储驱动；
OverlayFS目前已经有非常好的性能，与DeviceMapper 相比优 20%，与操作主机文件性能几乎一致
存储卷插件管理 Kubernetes支持以插件的形式来实现对不同存储的支持和扩展，这些扩展基于如下三种方式：
out-of-tree CSI插件 CSI 通过 RPC与存储驱动进行交互。</description></item><item><title>DDD领域驱动设计</title><link>https://obsidian.codeplayer.org/CS/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/</guid><description>基础 Domain-Driven Design Domain-Driven Design：基于 领域 的工程设计。
领域暂时可以将其理解为“业务问题的范畴“。
领域可大可小，对应着大小业务问题的边界。简单来说，领域驱动设计就是将业务上要做的一件大事，通过推演和抽象，拆分成多个内聚的领域。
面向接口编程，高内聚、低耦合。
DP(Domain Primitive) 构建领域的基础类型。作用：明确接口语义、内聚隐性逻辑、简化单元测试。
定义：在 DDD里，DP 可以说是一切模型、方法、架构的基础。它是在特定领域、拥有精准定义、可以自我验证、拥有行为的对象。可以认为是领域的最小组成部分。
DP三条原则：
让隐性的概念显性化
让隐性的上下文显性化
封装多对象行为</description></item><item><title>Dockerfile</title><link>https://obsidian.codeplayer.org/CS/Docker/Dockerfile/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Docker/Dockerfile/</guid><description>回顾 12 Factor 之进程 [[系统架构#12 factors|12 factors]]
运行环境中，应用程序通常是以一个和多个进程运行的。 12-Factor 应用的进程必须无状态（Stateless）且无共享（Share nothing）。 任何需要持久化的数据都要存储在后端服务内，比如数据库。 应在构建阶段将源代码编译成待执行应用。 Session Sticky 是 12-Factor 极力反对的。 Session 中的数据应该保存在诸如 Memcached 或 Redis 这样的带有过期时间的缓存中 Docker 遵循以上原则管理和构建应用。 理解构建上下文（Build Context） 当运行 docker build 命令时，当前工作目录被称为构建上下文。 docker build 默认查找当前目录的 Dockerfile 作为构建输入，也可以通过 –f 指定 Dockerfile。 docker build –f .</description></item><item><title>etcd</title><link>https://obsidian.codeplayer.org/CS/Kubernetes/etcd/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Kubernetes/etcd/</guid><description>etcd Etcd是CoreOS基于Raft开发的分布式key-value存储，可用于服务发现、共享配置以及一致性保障（如数据库选主、分布式锁等）。
在分布式系统中，如何管理节点间的状态一直是一个难题，etcd像是专门为集群环境的服务发现和注册而设计，它提供了数据TTL失效、数据改变监视、多值、目录监听、分布式锁原子操作等功能，可以方便的跟踪并管理集群节点的状态。
键值对存储：将数据存储在分层组织的目录中，如同在标准文件系统中 监测变更：监测特定的键或目录以进行更改，并对值的更改做出反应 简单: curl可访问的用户的API（HTTP+JSON） 安全: 可选的SSL客户端证书认证 快速: 单实例每秒1000次写操作，2000+次读操作 可靠: 使用Raft算法保证一致性 主要功能 基本的key-value存储 监听机制 key的过期及续约机制，用于监控和服务发现 原子Compare And Swap和Compare And Delete，用于分布式锁和leader选举 使用场景 也可以用于键值对存储，应用程序可以读取和写入 etcd 中的数据 etcd 比较多的应用场景是用于服务注册与发现 基于监听机制的分布式异步系统 键值对存储 etcd 是一个键值存储的组件，其他的应用都是基于其键值存储的功能展开。</description></item><item><title>GMP</title><link>https://obsidian.codeplayer.org/CS/Golang/GMP/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Golang/GMP/</guid><description>有关系统的进程和进程的知识，可参考 [[Linux进程]]
协程 进程： 分配系统资源（CPU 时间、内存等）基本单位 有独立的内存空间，切换开销大 线程：进程的一个执行流，是 CPU 调度并能独立运行的的基本单位 同一进程中的多线程共享内存空间，线程切换代价小 多线程通信方便 从内核层面来看线程其实也是一种特殊的进程，它跟父进程共享了打开的文件和文件系统信息，共享了地址空间和信号处理函数 协程 Go 语言中的轻量级线程实现 Golang 在 runtime、系统调用等多方面对 goroutine 调度进行了封装和处理，当遇到长时间执行或者进行系统调用时，会主动把当前 goroutine 的 CPU (P) 转让出去，让其他 goroutine 能被调度并执行，也就是 Golang 从语言层面支持了协程 线程和协程的差异 每个 goroutine (协程) 默认占用内存远比 Java 、C 的线程少 goroutine：2KB 线程：8MB 线程/goroutine 切换开销方面，goroutine 远比线程小 线程：涉及模式切换(从用户态切换到内核态)、16个寄存器、PC、SP&amp;hellip;等寄存器的刷新 goroutine：只有三个寄存器的值修改 - PC / SP / DX.</description></item><item><title>Headless</title><link>https://obsidian.codeplayer.org/CS/Kubernetes/Headless/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Kubernetes/Headless/</guid><description>Headless和ClusterIP的区别 CoreDNS的作用：在K8S里，我们想要通过name来访问服务的方式就是在Deployment上面添加一层Service，这样我们就可以通过Service name来访问服务了，那其中的原理就是和CoreDNS有关，它将Service name解析成Cluster IP。
这样我们访问Cluster IP的时候就通过Cluster IP作负载均衡，把流量分布到各个POD上面。
K8s中资源的全局FQDN格式:
1 2 Service_NAME.NameSpace_NAME.Domain.LTD. Domain.LTD.=svc.cluster.local.　#这是默认k8s集群的域名。 ClusterIP ClusterIP的原理：一个Service可能对应多个EndPoint(Pod)，client访问的是Cluster IP，通过iptables规则转到Real Server，从而达到负载均衡的效果。</description></item><item><title>homelab</title><link>https://obsidian.codeplayer.org/CS/Linux/homelab/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Linux/homelab/</guid><description> 路由器 openwrt openclash zerotier K8S K9S registry harbor 支持docker镜像 支持K8S helm OSS Minio</description></item><item><title>istio</title><link>https://obsidian.codeplayer.org/CS/Kubernetes/istio/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Kubernetes/istio/</guid><description>问题 No tracing问题 没有正确设置meshConfig.defaultConfig.tracing.zipkin.address和meshConfig.defaultConfig.tracing.sampling istioctl install --set profile=demo --set meshConfig.defaultConfig.tracing.zipkin.address=jaeger-collector.istio-system:9411 --set meshConfig.defaultConfig.tracing.sampling=100 -y 重建、更新istio后，可能需要把sidecar重启/重建 jaeger暂时使用allinone即可，因为用es做后端存储太难配置 kiali的Graph为空或prometheus没有数据 prometheus.</description></item><item><title>K0S</title><link>https://obsidian.codeplayer.org/CS/Kubernetes/K0S/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Kubernetes/K0S/</guid><description>安装K0S https://docs.k0sproject.io/v1.23.6+k0s.2/install/
curl -sSLf [https://get.k0s.sh](https://get.k0s.sh) | sudo sh sudo k0s install controller --single sudo k0s start sudo k0s status sudo k0s kubectl get nodes 卸载K0S sudo k0s stop sudo k0s reset reboot system 💡 A few small k0s fragments persist even after the reset (for example, iptables).</description></item><item><title>kube-proxy</title><link>https://obsidian.codeplayer.org/CS/Kubernetes/kube-proxy/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Kubernetes/kube-proxy/</guid><description>kube-proxy 每台机器上都运行一个kube-proxy服务，它监听API server中service和endpoint的变化情况，并通过iptables等来为服务配置负载均衡（仅支持TCP和UDP）。
kube-proxy可以直接运行在物理机上，也可以以static pod或者DaemonSet的方式运行。
kube-proxy当前支持一下几种实现
userspace：最早的负载均衡方案，它在用户空间监听一个端口，所有服务通过iptables转发到这个端口，然后在其内部负载均衡到实际的Pod。该方式最主要的问题是效率低，有明显的性能瓶颈。 iptables：目前推荐的方案，完全以iptables规则的方式来实现service负载均衡。该方式最主要的问题是在服务多的时候产生太多的iptables规则，非增量式更新会引入一定的时延，大规模情况下有明显的性能问题 ipvs：为解决iptables模式的性能问题，v1.8新增了ipvs模式，采用增量式更新，并可以保证service更新期间连接保持不断开 winuserspace∶ 同userspace，但仅工作在windows上 Linux内核处理数据包：Netfilter框架 Netfilter和iptables iptables iptables支持的锚点 kube-proxy工作原理 Kubernetes iptables规则 IPVS IPVS支持的锚点和核心函数 域名服务 Kubernetes Service通过虚拟IP地址或者节点端口为用户应用提供访问入口</description></item><item><title>Kubelet</title><link>https://obsidian.codeplayer.org/CS/Kubernetes/Kubelet/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Kubernetes/Kubelet/</guid><description>kubelet 架构 kubelet 管理 Pod 的核心流程 kubelet 每个节点上都运行一个kubelet 服务进程，默认监听 10250端口。
接收并执行 master 发来的指令； 管理 Pod及Pod 中的容器； 每个kubelet 进程会在API Server 上注册节点自身信息，定期向 master 节点汇报节点的资源使用情况，并通过 cAdvisor监控节点和容器的资源。 节点管理 节点管理主要是节点自注册和节点状态更新：</description></item><item><title>Modules</title><link>https://obsidian.codeplayer.org/CS/Golang/Modules/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Golang/Modules/</guid><description>开启modules
$ go env -w GO111MODULE=on</description></item><item><title>Proxy</title><link>https://obsidian.codeplayer.org/CS/Golang/Proxy/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Golang/Proxy/</guid><description>GOPROXY 和 GOPRIVAT 为拉取 Go 依赖设置代理
export GOPROXY=https://goproxy.cn
在设置 GOPROXY 以后，默认所有依赖拉取都需要经过 proxy 连接 git repo，拉取代码，并做checksum 校验
某些私有代码仓库是 goproxy.cn 无法连接的，因此需要设置 GOPRIVATE 来声明私有代码仓库</description></item><item><title>Service</title><link>https://obsidian.codeplayer.org/CS/Kubernetes/Service/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Kubernetes/Service/</guid><description>Service对象 Service Selector Kubernetes允许将Pod对象通过标签（Label）进行标记，并通过Service Selector定义基于Pod标签的过滤规则，以便选择服务的上游应用实例 Ports Ports属性中定义了服务的端口、协议目标端口等信息 1 2 3 4 5 6 7 8 9 10 11 apiVersion:v1kind:Servicemetadata:name:nginx-serviceSpec:selector:app:nginxports:- protocol:TCPport:80targetPort:80 Endpoint对象 当Service的selector不为空时，Kubernetes EndpointController会侦听服务创建事件，创建与Service同名的Endpoint对象 selector能够选取的所有PodIP都会被配置到addresses属性中 如果此时selector所对应的filter查询不到对应的Pod，则addresses列表为空 默认配置下，如果此时对应的Pod为not ready状态，则对应的PodIP只会出现在subsets的notReadyAddresses属性中，这意味着对应的Pod还没准备好提供服务，不能作为流量转发的目标。 如果设置了PublishNotReadyAdddress为true，则无论Pod是否就绪都会被加入readyAddress list 1 2 3 4 5 6 7 8 9 10 11 12 13 14 apiVersion:v1kind:Endpointmetadata:name:nginx-servicesubsets:- addresses:- ip:10.</description></item><item><title>tmux</title><link>https://obsidian.codeplayer.org/CS/Linux/tmux/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Linux/tmux/</guid><description>快捷键 tmux窗口最大化：prefix+z</description></item><item><title>VSCode</title><link>https://obsidian.codeplayer.org/CS/%E7%BC%96%E8%BE%91%E5%99%A8/VSCode/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/%E7%BC%96%E8%BE%91%E5%99%A8/VSCode/</guid><description>多光标 按住Alt，用鼠标左键点击，可以出现多个光标，输入的代码可以在光标处同时增加。 按住Ctrl+Alt，再按键盘上向上或者向下的键，可以使一列上出现多个光标。 选中一段文字，按Shift+Alt+i，可以在每行末尾出现光标 光标放在一个地方，按Ctrl+Shift+l或者ctrl+F2，可以在页面中出现这个词的不同地方都出现光标（不区分大小写）。有时候这个快捷键的作用和F2重命名变量类似，但是它更加广泛，因为还可以对比如字符串相同的非同一变量或函数类的东西修改。 Ctrl+d，第一次按下时，它会选中光标附近的单词；第二次按下时，它会找到这个单词第二次出现的位置，创建一个新的光标，并且选中它 按Shift+Alt，再使用鼠标拖动，也可以出现竖直的列光标，同时可以选中多列。 任何光标操作，可以按Ctrl + U取消 参考资料 VSCode 又酷又实用的多光标编辑 VS Code 多光标模式 拒绝重复，你一定要学会的多光标特性 Tips 触发参数提示：Shift+Cmd+Space</description></item><item><title>Yubikey</title><link>https://obsidian.codeplayer.org/CS/%E5%AE%89%E5%85%A8/Yubikey/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/%E5%AE%89%E5%85%A8/Yubikey/</guid><description>初始化设置 https://xiaoqiang.blog/yubikey-shiyong/
设置PIV功能的PIN和PUK
设置FIDO2功能的PIN
设置OTP功能
Mac登陆配置 https://support.yubico.com/hc/en-us/articles/360016649059-Using-Your-YubiKey-as-a-Smart-Card-in-macOS
注意需要在Yubikey Manger的Applications &amp;gt; PIV里，点击setup for macOS
开启card only验证后，只有最近使用过验证的yubikey能解锁macOS的启动过程中的登陆</description></item><item><title>zerotier-moon</title><link>https://obsidian.codeplayer.org/CS/Linux/zerotier-moon/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Linux/zerotier-moon/</guid><description>使用docker搭建 部署命令：docker run --name zerotier-moon -d --restart always -p 9993:9993/udp -v &amp;lt;zerotier-moon-config dir&amp;gt;:/var/lib/zerotier-one seedgou/zerotier-moon -4 &amp;lt;public ipv4 addression&amp;gt; 查看moon id：docker logs zerotier-moon 防火墙设置 9993端口的TCP和UDP均要打开 客户端配置 直接使用命令 zerotier-cli orbit xxxxxx xxxxxx 添加 将moon生成的配置的moons.</description></item><item><title>ZFS</title><link>https://obsidian.codeplayer.org/CS/Linux/ZFS/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Linux/ZFS/</guid><description>ARC缓存限制
需要把参数写到cmdline中，写在 /etc/modprobe.d 中不生效
GRUB_CMDLINE_LINUX=&amp;quot;zfs.zfs_arc_max=8589934592 zfs.zfs_arc_min=4294967296&amp;quot;</description></item><item><title>内存管理</title><link>https://obsidian.codeplayer.org/CS/Golang/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Golang/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid><description>堆内存管理 堆内存管理 初始化连续内存块作为堆
有内存申请的时候，Allocator 从堆内存的未分配区域分割小内存块
用链表将已分配内存连接起来
需要信息描述每个内存块的元数据：大小，是否使用，下一个内存块的地址等
TCMalloc 概览 page:内存页，一块 8K 大小的内存空间。Go 与操作系统之间的内存申请和释放，都是以page 为单位
span: 内存块，一个或多个连续的 page 组成一个 span</description></item><item><title>内核</title><link>https://obsidian.codeplayer.org/CS/Linux/%E5%86%85%E6%A0%B8/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Linux/%E5%86%85%E6%A0%B8/</guid><description>/etc/modules-load.d 与 In /etc/modprobe.d的区别
/etc/modules-load.d can only load modules, nothing more. You can’t blacklist a module and you can’t insert a module with special options.</description></item><item><title>基于Istio的高级流量管理</title><link>https://obsidian.codeplayer.org/CS/Kubernetes/%E5%9F%BA%E4%BA%8EIstio%E7%9A%84%E9%AB%98%E7%BA%A7%E6%B5%81%E9%87%8F%E7%AE%A1%E7%90%86/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Kubernetes/%E5%9F%BA%E4%BA%8EIstio%E7%9A%84%E9%AB%98%E7%BA%A7%E6%B5%81%E9%87%8F%E7%AE%A1%E7%90%86/</guid><description>微服务架构的演变 Evolution 从单块系统到微服务系统的演进 微服务架构的演进 典型的微服务业务场景 更完整的微服务架构 系统边界 微服务到服务网格还缺什么? Sidecar 的工作原理 Service Mesh 适应性</description></item><item><title>基于Kubernetes和Istio的安全保证</title><link>https://obsidian.codeplayer.org/CS/Kubernetes/%E5%9F%BA%E4%BA%8EKubernetes%E5%92%8CIstio%E7%9A%84%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Kubernetes/%E5%9F%BA%E4%BA%8EKubernetes%E5%92%8CIstio%E7%9A%84%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81/</guid><description>云原生语境下的安全保证 云原生语境下的安全保证 安全保证是贯穿软件整个生命周期的重要部分。
安全与效率有时候是相违背的。
如何将二者统一起来，提升整体效率是关键。
这需要我们将安全思想贯穿到软件开发运维的所有环节。
云原生层次模型 软件的生命周期∶开发-&amp;gt;分发→部署-&amp;gt;运行
开发环节的安全保证 SaaS 应用的 [[系统架构#12 factors|12-factor]] 设计原则的一些理念与云原生安全不谋而合。
传统的安全三元素 CIA（ConfidentialitVIntegrity和 AVailability），在云原生安全中被充分应用，如对工作负载的完整性保护，与I（Integrity）完整性保护相对应。
机密性（Confidentiality）指只有授权用户可以获取信息。 完整性（Integrity）指信息在输入和传输的过程中，不被非法授权修改和破坏，保证数据的一致性。 可用性（Availability）指保证合法用户对信息和资源的使用不会被不正当地拒绝。 **基础设施即代码（Infrastructure as Code，简称 laC）**也与云原生的实践紧密相关。</description></item><item><title>将应用迁移至Kubernetes平台</title><link>https://obsidian.codeplayer.org/CS/Kubernetes/%E5%B0%86%E5%BA%94%E7%94%A8%E8%BF%81%E7%A7%BB%E8%87%B3Kubernetes%E5%B9%B3%E5%8F%B0/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Kubernetes/%E5%B0%86%E5%BA%94%E7%94%A8%E8%BF%81%E7%A7%BB%E8%87%B3Kubernetes%E5%B9%B3%E5%8F%B0/</guid><description>应用接入最佳实践 应用容器化 目标 稳定性、可用性、性能、安全
从多维度思考高可用的问题
应用容器化的思考 容器额外开销和风险 Log driver Blocking mode Non blocking mode 共用 kernel 所以 系统参数配置共享 进程数共享-Fork bomb fd 数共享 主机磁盘共享 容器化应用的资源监控 容器中看到的资源是主机资源</description></item><item><title>常用命令</title><link>https://obsidian.codeplayer.org/CS/Docker/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Docker/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid><description>远程构建image 使用build构建 1 2 3 DOCKER_HOST=&amp;#34;ssh://user@docker-build.dev&amp;#34; docker build -t {tag} . docker use context remote-build-host &amp;amp;&amp;amp; docker build -t {tag} .</description></item><item><title>常用命令</title><link>https://obsidian.codeplayer.org/CS/Kubernetes/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Kubernetes/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid><description>Kubectl Kubectl 命令和 kubeconfig kubectl 是一个 Kubernetes 的命令行工具，它允许Kubernetes 用户以命令行的方式与 Kubernetes 交互，其默认读取配置文件 ~/.kube/config。 kubectl 会将接收到的用户请求转化为 rest 调用以rest client 的形式与 apiserver 通讯。 apiserver 的地址，用户信息等配置在 kubeconfig。 常用命令 kubectl get po –oyaml -w kubectl 可查看对象。 -oyaml 输出详细信息为 yaml 格式。 -w watch 该对象的后续变化。 -owide 以详细列表的格式查看对象。 在终端通过stdin读取inline YAML 1 2 3 4 $ kubectl apply -f - &amp;lt;&amp;lt;EOF &amp;lt;-- insert YAML content here --&amp;gt; EOF OR</description></item><item><title>常见问题</title><link>https://obsidian.codeplayer.org/CS/ElasticSearch/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/ElasticSearch/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</guid><description>Search加.keyword与不加.keyword的区别，为什么没有结果 https://segmentfault.com/q/1010000017312707
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 GET production-index-info/index_info/_search { &amp;#34;query&amp;#34;: { &amp;#34;bool&amp;#34;: { &amp;#34;minimum_should_match&amp;#34;: 0, &amp;#34;must&amp;#34;: [ { &amp;#34;term&amp;#34;: { &amp;#34;is_resolved.</description></item><item><title>数据结构与算法总结</title><link>https://obsidian.codeplayer.org/CS/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</guid><description>数据结构与算法总结 数据结构 20个最常用的、最基础数据结构与算法：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；10 个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。
我们学习数据结构和算法，要学习它的由来、特性、适用的场景以及它能解决的问题。
数组 数组可以说是最基础、最简单的数据结构了。数组用一块连续的内存空间，来存储相同类型的一组数据，最大的特点就是支持随机访问，但插入、删除操作也因此变得比较低效，平均情况时间复杂度为 O(n)。在平时的业务开发中，我们可以直接使用编程语言提供的容器类，但是，如果是特别底层的开发，直接使用数组可能会更合适。
链表 链表跟数组一样，也是非常基础、非常常用的数据结构。不过链表要比数组稍微复杂，从普通的单链表衍生出来好几种链表结构，比如双向链表、循环链表、双向循环链表。
和数组相比，链表更适合插入、删除操作频繁的场景，查询的时间复杂度较高。不过，在具体软件开发中，要对数组和链表的各种性能进行对比，综合来选择使用两者中的哪一个。
写出正确链表代码的六个技巧。分别是理解指针或引用的含义、警惕指针丢失和内存泄漏、利用哨兵简化实现难度、重点留意边界条件处理，以及举例画图、辅助思考，还有多写多练。
写链表代码是最考验逻辑思维能力的。因为，链表代码到处都是指针的操作、边界条件的处理，稍有不慎就容易产生 Bug。链表代码写得好坏，可以看出一个人写代码是否够细心，考虑问题是否全面，思维是否缜密。所以，这也是很多面试官喜欢让人手写链表代码的原因。所以，这一节讲到的东西，你一定要自己写代码实现一下，才有效果。
栈 栈是一种操作受限的数据结构，只支持入栈和出栈操作。后进先出是它最大的特点。栈既可以通过数组实现，也可以通过链表来实现。**不管基于数组还是链表，入栈、出栈的时间复杂度都为 O(1)。**除此之外，我们还讲了一种支持动态扩容的顺序栈，你需要重点掌握它的均摊时间复杂度分析方法。
队列 队列最大的特点就是先进先出，主要的两个操作是入队和出队。跟栈一样，它既可以用数组来实现，也可以用链表来实现。用数组实现的叫顺序队列，用链表实现的叫链式队列。特别是长得像一个环的循环队列。在数组实现队列的时候，会有数据搬移操作，要想解决数据搬移的问题，我们就需要像环一样的循环队列。</description></item><item><title>数据迁移</title><link>https://obsidian.codeplayer.org/CS/ElasticSearch/%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/ElasticSearch/%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB/</guid><description>Elasticdump 适合数据量较小​​的场景
elasticdump --input=${SOURCE_ES}/$index --output=${DESTINATION_ES}/$index --type data --limit 1000 --overwrite true</description></item><item><title>服务发现</title><link>https://obsidian.codeplayer.org/CS/Kubernetes/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Kubernetes/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/</guid><description>服务发布 需要把服务发布至集群内部或者外部，服务的不同类型 ClusterlP(Headless) NodePort LoadBalancer ExternalName 证书管理和七层负载均衡的需求 需要gRPC负载均衡如何做? DNS需求 与上下游服务的关系 服务发布的挑战 kube-dns DNS TTL问题 Service ClusterIP只能对内 kube-proxy支持的iptables/ipvs规模有限 IPVS的性能和生产化问题 kube-proxy的drift问题 频繁的Pod变动（spec change，failover，crashloop）导致LB频繁变更 对外发布的Service需要与企业ELB即成 不支持gRPC 不支持自定义DNS和高级路由功能 Ingress Spec的成熟度?</description></item><item><title>架构基础</title><link>https://obsidian.codeplayer.org/CS/Kubernetes/%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Kubernetes/%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80/</guid><description>主要组件 Kubernetes 的主节点（Master Node） API服务器：API Server 这是 Kubernetes 控制面板中唯一带有用户可访问 API 以及用户可交互的组件。API 服务器会暴露一个 RESTful 的 Kubernetes API 并使用 JSON 格式的清单文件（manifest files）。 群的数据存储：Cluster Data Store Kubernetes 使用“etcd”。这是一个强大的、稳定的、高可用的键值存储，被Kubernetes 用于长久储存所有的 API 对象。 控制管理器：Controller Manager 被称为“kube-controller manager”，它运行着所有处理集群日常任务的控制器。包括了节点控制器、副本控制器、端点（endpoint）控制器以及服务账户等。 调度器：Scheduler 调度器会监控新建的 pods（一组或一个容器）并将其分配给节点。 Kubernetes 的工作节点（Worker Node） Kubelet 负责调度到对应节点的 Pod 的生命周期管理，执行任务并将 Pod 状态报告给主节点的渠道，通过容器运行时（拉取镜像、启动和停止容器等）来运行这些容器。它还会定期执行被请求的容器的健康探测程序。 Kube-proxy 它负责节点的网络，在主机上维护网络规则并执行连接转发。它还负责对正在服务的 pods 进行负载平衡。 etcd etcd 是 CoreOS 基于 Raft 开发的分布式 key-value 存储，可用于服务发现、共享配置以及一致性保障（如数据库选主、分布式锁等）。</description></item><item><title>查询与聚合</title><link>https://obsidian.codeplayer.org/CS/ElasticSearch/%E6%9F%A5%E8%AF%A2%E4%B8%8E%E8%81%9A%E5%90%88/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/ElasticSearch/%E6%9F%A5%E8%AF%A2%E4%B8%8E%E8%81%9A%E5%90%88/</guid><description>查询和聚合的基础使用 查询数据 查询所有 match_all表示查询所有的数据，sort即按照什么字段排序
1 2 3 4 5 6 7 GET /bank/_search { &amp;#34;query&amp;#34;: { &amp;#34;match_all&amp;#34;: {} }, &amp;#34;sort&amp;#34;: [ { &amp;#34;account_number&amp;#34;: &amp;#34;asc&amp;#34; } ] } 结果</description></item><item><title>核心技术</title><link>https://obsidian.codeplayer.org/CS/Docker/%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Docker/%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/</guid><description>Docker 基于 Linux 内核的 Cgroup，Namespace，以及 Union FS 等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术，由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。
最初实现是基于 LXC，从 0.7 以后开始去除 LXC，转而使用自行开发的 Libcontainer，从 1.11 开始，则进一步演进为使用 runC 和 Containerd。
Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护，使得 Docker 技术比虚拟机技术更为轻便、快捷。</description></item><item><title>深入理解</title><link>https://obsidian.codeplayer.org/CS/Kubernetes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Kubernetes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/</guid><description>API 设计原则 所有 API 都应是声明式的
相对于命令式操作，声明式操作对于重复操作的效果是稳定的，这对于容易出现数据丢失或重复的分布式环境来说是很重要的。
声明式操作更易被用户使用，可以使系统向用户隐藏实现的细节，同时也保留了系统未来持续优化的可能性。
此外，声明式的 API 还隐含了所有的 API 对象都是名词性质的，例如 Service、Volume 这些 API 都是名词，这些名词描述了用户所
期望得到的一个目标对象。
API 对象是彼此互补而且可组合的
这实际上鼓励 API 对象尽量实现面向对象设计时的要求，即“高内聚，松耦合”，对业务相关的概念有一个合适的分解，提高分解出来的对象的可重用性。</description></item><item><title>深入理解Pod的生命周期</title><link>https://obsidian.codeplayer.org/CS/Kubernetes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pod%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Kubernetes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pod%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</guid><description>如何优雅的管理Pod的完整生命周期 Pod状态机 Pod Phase Pod Phase Pending Running Succeeded Failed Unknown kubectl get pod显示的状态信息是由podstatus 的conditions和phase计算出来的 查看pod细节 kubectl get pod $podname-oyaml 查看pod相关事件 kubectl describe pod Pod状态计算细节 如何确保Pod的高可用 避免容器进程被终止避免Pod被驱逐</description></item><item><title>生产化运维</title><link>https://obsidian.codeplayer.org/CS/Kubernetes/%E7%94%9F%E4%BA%A7%E5%8C%96%E8%BF%90%E7%BB%B4/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Kubernetes/%E7%94%9F%E4%BA%A7%E5%8C%96%E8%BF%90%E7%BB%B4/</guid><description>镜像仓库 镜像仓库 镜像仓库（Docker Registry）负责存储、管理和分发镜像。 镜像仓库管理多个Repository，Repository通过命名来区分。每个Repository包含一个或多个镜像，镜像通过镜像名称和标签（Tag）来区分。 客户端拉取镜像时，要指定三要素： 镜像仓库：要从哪一个镜像仓库拉取镜像，通常通过DNS或IP地址来确定一个镜像仓库，如hub.docker.com Repository：组织名，如cncamp 镜像名称+标签：如nginx∶latest 公有镜像仓库优势
开放：任何开发者都可以上传、分享镜像到公有镜像仓库中。
便捷：开发者可以非常方便地搜索、拉取其他开发者的镜像，避免重复造轮子。
免运维：开发者只需要关注应用开发，不必关心镜像仓库的更新、升级、维护等。</description></item><item><title>生产化集群的管理</title><link>https://obsidian.codeplayer.org/CS/Kubernetes/%E7%94%9F%E4%BA%A7%E5%8C%96%E9%9B%86%E7%BE%A4%E7%9A%84%E7%AE%A1%E7%90%86/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Kubernetes/%E7%94%9F%E4%BA%A7%E5%8C%96%E9%9B%86%E7%BE%A4%E7%9A%84%E7%AE%A1%E7%90%86/</guid><description>计算节点 生产化集群的考量 计算节点： 如何批量安装和升级计算节点的操作系统? 如何管理配置计算节点的网络信息? 如何管理不同SKU（StockKeeping Unit）的计算节点? 如何快速下架故障的计算节点? 如何快速扩缩集群的规模? 控制平面： 如何在主节点上下载、安装和升级控制平面组件及其所需的配置文件? 如何确保集群所需的其他插件，例如CoreDNS、监控系统等部署完成? 如何准备控制平面组件的各种安全证书? 如何快速升级或回滚控制平面组件的版本? 操作系统的选择 操作系统的评估与选择 通用操作系统 Ubuntu Centos Fedora 专为容器优化的操作系统 最小化操作系统 CoreOS RedHat Atomic Snappy Ubuntu Core RancherOS 操作系统的评估与选择 操作系统评估和选型的标准</description></item><item><title>疑难问题</title><link>https://obsidian.codeplayer.org/CS/git/%E7%96%91%E9%9A%BE%E9%97%AE%E9%A2%98/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/git/%E7%96%91%E9%9A%BE%E9%97%AE%E9%A2%98/</guid><description>如果理解”gpg failed to sign the data“问题</description></item><item><title>算法与数据结构</title><link>https://obsidian.codeplayer.org/CS/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid><description>算法与数据结构 前言 想要学习数据结构与算法，首先要掌握一个数据结构与算法中最重要的概念——复杂度分析。
这个概念究竟有多重要呢？可以这么说，它几乎占了数据结构和算法这门课的半壁江山，是数据结构和算法学习的精髓。
数据结构和算法解决的是如何更省、更快地存储和处理数据的问题，因此，我们就需要一个考量效率和资源消耗的方法，这就是复杂度分析方法。所以，如果你只掌握了数据结构和算法的特点、用法，但是没有学会复杂度分析，那就相当于只知道操作口诀，而没掌握心法。只有把心法了然于胸，才能做到无招胜有招！
我们学习数据结构和算法，要学习它的由来、特性、适用的场景以及它能解决的问题。
作为初学者，或者一个非算法工程师来说，需要掌握的20个最常用的、最基础数据结构与算法：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；10 个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。
一些可以让你事半功倍的学习技巧 边学边练，适度刷题 建议你每周花 1～2 个小时的时间，集中把学习的数据结构和算法，全都自己写出来，用代码实现一遍。这样一定会比单纯地看或者听的效果要好很多！
多问、多思考、多互动 学习最好的方法是，找到几个人一起学习，一块儿讨论切磋，有问题及时寻求老师答疑。
打怪升级学习法 学习的过程中，我们碰到最大的问题就是，坚持不下来。 是的，很多基础课程学起来都非常枯燥。为此，我自己总结了一套“打怪升级学习法”。</description></item><item><title>系统架构</title><link>https://obsidian.codeplayer.org/CS/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/</guid><description>传统分层架构 vs 微服务 微服务改造 分离微服务的方法建议： 审视并发现可以分离的业务逻辑业务逻辑 寻找天生隔离的代码模块，可以借助于静态代码分析工具 不同并发规模，不同内存需求的模块都可以分离出不同的微服务，此方法可提高资源利用率，节省成本 一些常用的可微服务化的组件： 用户和账户管理 授权和会话管理 系统配置 通知和通讯服务 照片，多媒体，元数据等 分解原则：基于 size, scope and capabilities 微服务通信 点对点 多用于系统内部多组件之间通讯；</description></item><item><title>索引</title><link>https://obsidian.codeplayer.org/CS/MongoDB/%E7%B4%A2%E5%BC%95/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/MongoDB/%E7%B4%A2%E5%BC%95/</guid><description>date created: 2023-04-03 09:41 date modified: 2023-04-05 13:57 layout: page tags: MongoDB title: &amp;ldquo;索引&amp;rdquo; 索引排序 单字段的索引，创建时不论指定升序还是降序，它查询时用的 sort 可以是任意方向的（升序或降序）。 多字段的索引按前缀匹配 排序字段的 “排序顺序”，必须和索引中的对应字段的排序顺序完全相同或完全相反。 sort 条件是 index 的前缀子集时，query 条件可以为空，也可以为任何 index 的前缀子集。 sort 条件不是 index 的前缀子集时，query 条件必须包含 index 字段中 sort 字段前方的所有字段。 数据结构 MongoDb 真的用的是 B 树吗？ 通过查阅资料，我从 MongoDb 的官网和 WiredTiger 官网找到了答案。MongoDb 官网关于存储引擎（Storage Engine）的描述写道：从 MongoDb 3.</description></item><item><title>调度</title><link>https://obsidian.codeplayer.org/CS/Kubernetes/%E8%B0%83%E5%BA%A6/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Kubernetes/%E8%B0%83%E5%BA%A6/</guid><description>kube-scheduler kube-scheduler负责分配调度Pod 到集群内的节点上，它监听 kube-apiserver，查询还未分配
Node 的Pod，然后根据调度策略为这些 Pod 分配节点（更新 Pod 的 NodeName 字段）。
调度器需要充分考虑诸多的因素∶
公平调度； 资源高效利用； QoS； affinity和 anti-affinity； 数据本地化（data locality）； 内部负载干扰（inter-workload interference）； deadlines。 调度器 kube-scheduler 调度分为两个阶段，predicate 和 priority：</description></item><item><title>进程</title><link>https://obsidian.codeplayer.org/CS/Linux/%E8%BF%9B%E7%A8%8B/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Linux/%E8%BF%9B%E7%A8%8B/</guid><description>进程与线程 进程：资源分配的基本单位
线程：调度的基本单位
无论是线程还是进程，在 linux 中都以 task_struct 描述，从内核角度看，与进程无本质区别
Glibc 中的 pthread 库提供 NPTL（Native POSIX Threading Library）支持
进程的内存使用 CPU对内存的访问 CPU 上有个 Memory Management Unit（MMU） 单元</description></item><item><title>远程调试</title><link>https://obsidian.codeplayer.org/CS/Kubernetes/%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Kubernetes/%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/</guid><description> 原理：https://learn.microsoft.com/zh-cn/visualstudio/bridge/overview-bridge-to-kubernetes
教程：https://learn.microsoft.com/zh-cn/visualstudio/bridge/bridge-to-kubernetes-vs-code
示例：https://learn.microsoft.com/zh-cn/visualstudio/bridge/bridge-to-kubernetes-sample
安装 安装vscode 安装vscode扩展Kubernetes和Bridge to Kubernetes 安装go扩展 配置 打开项目 选择kubernetes namespace 打开命令面板，运行命令“Bridge to Kubernetes: 配置” 选择需要重定向到本地的服务 输入本地运行的程序的端口号 选择或创建调试的启动配置（与本地开发的配置相同） 选择在隔离或非隔离模式下运行，隔离模式需要转发header kubernetes-route-as 在调试中选择刚才创建的配置启动 限制 要使 Bridge to Kubernetes 成功连接，一个 pod 只能有一个容器在该 pod 中运行。 目前，Bridge to Kubernetes pod 必须是 Linux 容器。 不支持 Windows 容器。 Bridge to Kubernetes 需要提升的权限才能在开发计算机上运行，以便编辑主机文件。 Bridge to Kubernetes 不能用于已启用 Azure Dev Spaces 的群集。</description></item><item><title>部署KubeSphere</title><link>https://obsidian.codeplayer.org/CS/Kubernetes/%E9%83%A8%E7%BD%B2KubeSphere/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Kubernetes/%E9%83%A8%E7%BD%B2KubeSphere/</guid><description>安装KubeSphere 直接在k8s中安装 1 2 3 kubectl apply -f https://github.com/kubesphere/ks-installer/releases/download/v3.3.0/kubesphere-installer.yaml kubectl apply -f https://github.com/kubesphere/ks-installer/releases/download/v3.3.0/cluster-configuration.yaml 检查安装日志 kubectl logs -n kubesphere-system $(kubectl get pod -n kubesphere-system -l 'app in (ks-install, ks-installer)' -o jsonpath='{.</description></item><item><title>镜像站</title><link>https://obsidian.codeplayer.org/CS/Linux/%E9%95%9C%E5%83%8F%E7%AB%99/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Linux/%E9%95%9C%E5%83%8F%E7%AB%99/</guid><description>北京外国语大学开源软件镜像站</description></item><item><title>集群联邦和Istio多集群管理</title><link>https://obsidian.codeplayer.org/CS/Kubernetes/%E9%9B%86%E7%BE%A4%E8%81%94%E9%82%A6%E5%92%8CIstio%E5%A4%9A%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Kubernetes/%E9%9B%86%E7%BE%A4%E8%81%94%E9%82%A6%E5%92%8CIstio%E5%A4%9A%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86/</guid><description>集群治理的驱动力 分布式云是未来 成本优化（Cost Effective） 更好的弹性及灵活性（Elasticity&amp;amp;Flexibility） 避免厂商锁定（Avoid Vendor Lock-in） 第一时间获取云上的新功能（Innovation） 容灾（Resilience &amp;amp;Recovery） 数据保护及风险管理（Data Protection&amp;amp;Risk Management） 提升响应速度（NetworkPerformance Improvements） 分布式云的挑战 Kubernetes单集群承载能力有限 异构的基础设施 存量资源接入 配置变更及下发 跨地域、跨机房应用部署及管理 容灾与隔离性，异地多活 弹性调度及自动伸缩 监控告警 如何应对 通过Kubernetes 屏蔽底层基础设施，提供统一的接入层 多云架构 多集群+多云 多集群管控 统一的管控面 方便接入，降低使用门槛 跨地域的集群管理 集群联邦 集群联邦的必要性 单一集群的管理规模有上限 数据库存储</description></item><item><title>面向对象</title><link>https://obsidian.codeplayer.org/CS/Golang/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/CS/Golang/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</guid><description>常用方法 可见性控制 public - 常量、变量、类型、接口、结构、函数等的名称大写 private - 非大写就只能在包内使用 继承 通过组合实现，内嵌一个或多个 struct 多态 通过接口实现，通过接口定义方法集，编写多套实现</description></item></channel></rss>