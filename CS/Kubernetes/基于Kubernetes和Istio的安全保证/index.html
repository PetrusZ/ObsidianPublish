<!doctype html><html lang=en><head><script async defer data-website-id=de560d7e-374a-4694-943f-f3f01b8dba46 src=https://umami.codeplayer.org:1443/umami.js></script>
<script>function _howxm(){_howxmQueue.push(arguments)}window._howxmQueue=window._howxmQueue||[],_howxm("setAppID","21c1239b-b2d0-45c5-8eab-246d8b16a9d6"),function(){if(t="howxm_script",!document.getElementById(t)){var t,e=document.createElement("script"),n=document.getElementsByTagName("script")[0];e.setAttribute("id",t),e.type="text/javascript",e.async=!0,e.src="https://static.howxm.com/sdk.js",n.parentNode.insertBefore(e,n)}}()</script><meta charset=utf-8><meta name=description content="云原生语境下的安全保证 云原生语境下的安全保证 安全保证是贯穿软件整个生命周期的重要部分。
安全与效率有时候是相违背的。
如何将二者统一起来，提升整体效率是关键。
这需要我们将安全思想贯穿到软件开发运维的所有环节。
云原生层次模型 软件的生命周期∶开发->分发→部署->运行
 开发环节的安全保证 SaaS 应用的 [[系统架构#12 factors|12-factor]] 设计原则的一些理念与云原生安全不谋而合。
传统的安全三元素 CIA（ConfidentialitVIntegrity和 AVailability），在云原生安全中被充分应用，如对工作负载的完整性保护，与I（Integrity）完整性保护相对应。
 机密性（Confidentiality）指只有授权用户可以获取信息。 完整性（Integrity）指信息在输入和传输的过程中，不被非法授权修改和破坏，保证数据的一致性。 可用性（Availability）指保证合法用户对信息和资源的使用不会被不正当地拒绝。  **基础设施即代码（Infrastructure as Code，简称 laC）**也与云原生的实践紧密相关。"><meta property="og:title" content="基于Kubernetes和Istio的安全保证"><meta property="og:description" content="云原生语境下的安全保证 云原生语境下的安全保证 安全保证是贯穿软件整个生命周期的重要部分。
安全与效率有时候是相违背的。
如何将二者统一起来，提升整体效率是关键。
这需要我们将安全思想贯穿到软件开发运维的所有环节。
云原生层次模型 软件的生命周期∶开发->分发→部署->运行
 开发环节的安全保证 SaaS 应用的 [[系统架构#12 factors|12-factor]] 设计原则的一些理念与云原生安全不谋而合。
传统的安全三元素 CIA（ConfidentialitVIntegrity和 AVailability），在云原生安全中被充分应用，如对工作负载的完整性保护，与I（Integrity）完整性保护相对应。
 机密性（Confidentiality）指只有授权用户可以获取信息。 完整性（Integrity）指信息在输入和传输的过程中，不被非法授权修改和破坏，保证数据的一致性。 可用性（Availability）指保证合法用户对信息和资源的使用不会被不正当地拒绝。  **基础设施即代码（Infrastructure as Code，简称 laC）**也与云原生的实践紧密相关。"><meta property="og:type" content="website"><meta property="og:image" content="https://obsidian.codeplayer.org/icon.png"><meta property="og:url" content="https://obsidian.codeplayer.org/CS/Kubernetes/%E5%9F%BA%E4%BA%8EKubernetes%E5%92%8CIstio%E7%9A%84%E5%AE%89%E5%85%A8%E4%BF%9D%E8%AF%81/"><meta property="og:width" content="200"><meta property="og:height" content="200"><meta name=twitter:card content="summary"><meta name=twitter:title content="基于Kubernetes和Istio的安全保证"><meta name=twitter:description content="云原生语境下的安全保证 云原生语境下的安全保证 安全保证是贯穿软件整个生命周期的重要部分。
安全与效率有时候是相违背的。
如何将二者统一起来，提升整体效率是关键。
这需要我们将安全思想贯穿到软件开发运维的所有环节。
云原生层次模型 软件的生命周期∶开发->分发→部署->运行
 开发环节的安全保证 SaaS 应用的 [[系统架构#12 factors|12-factor]] 设计原则的一些理念与云原生安全不谋而合。
传统的安全三元素 CIA（ConfidentialitVIntegrity和 AVailability），在云原生安全中被充分应用，如对工作负载的完整性保护，与I（Integrity）完整性保护相对应。
 机密性（Confidentiality）指只有授权用户可以获取信息。 完整性（Integrity）指信息在输入和传输的过程中，不被非法授权修改和破坏，保证数据的一致性。 可用性（Availability）指保证合法用户对信息和资源的使用不会被不正当地拒绝。  **基础设施即代码（Infrastructure as Code，简称 laC）**也与云原生的实践紧密相关。"><meta name=twitter:image content="https://obsidian.codeplayer.org/icon.png"><title>基于Kubernetes和Istio的安全保证</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://obsidian.codeplayer.org//icon.png><link href=https://obsidian.codeplayer.org/styles.80333fa2099c0bee674efa435fde378c.min.css rel=stylesheet><link href=https://obsidian.codeplayer.org/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://obsidian.codeplayer.org/js/darkmode.245a0a31da505f6b327aec1fcae860c8.min.js></script>
<script src=https://obsidian.codeplayer.org/js/util.00639692264b21bc3ee219733d38a8be.min.js></script>
<link rel=preload href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css as=style onload='this.onload=null,this.rel="stylesheet"' integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/core@1.2.1></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/dom@1.2.1></script>
<script async src=https://obsidian.codeplayer.org/js/popover.aa9bc99c7c38d3ae9538f218f1416adb.min.js></script>
<script defer src=https://obsidian.codeplayer.org/js/code-title.ce4a43f09239a9efb48fee342e8ef2df.min.js></script>
<script defer src=https://obsidian.codeplayer.org/js/clipboard.2913da76d3cb21c5deaa4bae7da38c9f.min.js></script>
<script defer src=https://obsidian.codeplayer.org/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const SEARCH_ENABLED=!1,LATEX_ENABLED=!0,PRODUCTION=!0,BASE_URL="https://obsidian.codeplayer.org/",fetchData=Promise.all([fetch("https://obsidian.codeplayer.org/indices/linkIndex.ecc459e836d07bbce975501c056ebc51.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://obsidian.codeplayer.org/indices/contentIndex.3b6a954c67318811059e65441df4ffae.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://obsidian.codeplayer.org",!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!1;drawGraph("https://obsidian.codeplayer.org",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}var i=document.getElementsByClassName("mermaid");i.length>0&&import("https://unpkg.com/mermaid@9/dist/mermaid.esm.min.mjs").then(e=>{e.default.init()});function a(n){const e=n.target,t=e.className.split(" "),s=t.includes("broken"),o=t.includes("internal-link");plausible("Link Click",{props:{href:e.href,broken:s,internal:o,graph:!1}})}const r=document.querySelectorAll("a");for(link of r)link.className.includes("root-title")&&link.addEventListener("click",a,{once:!0})},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'’':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/obsidian.codeplayer.org\/js\/router.d6fe6bd821db9ea97f9aeefae814d8e7.min.js"
    attachSPARouting(init, render)
  </script><script defer data-domain=obsidian.codeplayer.org src=https://plausible.io/js/script.js></script>
<script>window.plausible=window.plausible||function(){(window.plausible.q=window.plausible.q||[]).push(arguments)}</script></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-11MD77L81V"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-11MD77L81V",{anonymize_ip:!1})}</script><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://obsidian.codeplayer.org/js/full-text-search.e6e2e0c213187ca0c703d6e2c7a77fcd.min.js></script><div class=singlePage><header><h1 id=page-title><a class=root-title href=https://obsidian.codeplayer.org/>Avalon Obsidian Vault</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>基于Kubernetes和Istio的安全保证</h1><p class=meta>Last updated
Apr 9, 2023
<a href=https://github.com/PetrusZ/avalon-obsidian-vault/tree/main/CS/Kubernetes/%e5%9f%ba%e4%ba%8eKubernetes%e5%92%8cIstio%e7%9a%84%e5%ae%89%e5%85%a8%e4%bf%9d%e8%af%81.md rel=noopener>Edit Source</a></p><ul class=tags><li><a href=https://obsidian.codeplayer.org/tags/CS/Kubernetes/>Cs kubernetes</a></li></ul><aside class=mainTOC><details open><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#云原生语境下的安全保证>云原生语境下的安全保证</a><ol><li><a href=#云原生语境下的安全保证-1>云原生语境下的安全保证</a></li><li><a href=#云原生层次模型>云原生层次模型</a></li><li><a href=#开发环节的安全保证>开发环节的安全保证</a></li><li><a href=#开发>开发</a></li><li><a href=#分发环节的安全保证>分发环节的安全保证</a></li><li><a href=#分发>分发</a></li><li><a href=#部署环节的安全保证>部署环节的安全保证</a></li></ol></li><li><a href=#部署>部署</a><ol><li><a href=#运行时环节的安全保>运行时环节的安全保</a></li><li><a href=#运行环境>运行环境</a></li></ol></li><li><a href=#容器运行时的安全保证>容器运行时的安全保证</a><ol><li><a href=#以-non-root-身份运行容器>以 Non-root 身份运行容器</a></li><li><a href=#user-namespace-和-rootless-container>User Namespace 和 rootless container</a></li><li><a href=#集群的安全性保证>集群的安全性保证</a></li></ol></li><li><a href=#kubernetes-的安全保证>Kubernetes 的安全保证</a><ol><li><a href=#集群的安全通信>集群的安全通信</a></li><li><a href=#控制面安全保证>控制面安全保证</a></li><li><a href=#noderestriction>NodeRestriction</a></li><li><a href=#security-context>Security Context</a></li><li><a href=#container-level-security-context>Container-level Security Context</a></li><li><a href=#pod-level-security-context>Pod-level Security Context</a></li><li><a href=#pod-security-policiespsp>Pod Security Policies(PSP)</a></li><li><a href=#psp示例>PSP示例</a></li></ol></li><li><a href=#taint>Taint</a><ol><li><a href=#为节点增加-taint>为节点增加 taint</a></li><li><a href=#taint-1>Taint</a></li></ol></li><li><a href=#networkpolicy>NetworkPolicy</a><ol><li><a href=#networkpolicy-1>NetworkPolicy</a></li><li><a href=#隔离和非隔离的pod>隔离和非隔离的Pod</a></li><li><a href=#安全策略属性>安全策略属性</a></li><li><a href=#安全策略属性-1>安全策略属性</a></li><li><a href=#networkpolicy-2>NetworkPolicy</a></li><li><a href=#默认策略>默认策略</a></li></ol></li><li><a href=#依托于calico-的networkpolicy>依托于Calico 的NetworkPolicy</a><ol><li><a href=#networkpolicy-3>NetworkPolicy</a></li><li><a href=#globalnetworkpolicy>GlobalNetworkPolicy</a></li><li><a href=#理解calico-的防火墙规则>理解Calico 的防火墙规则</a></li><li><a href=#创建-networkpolicy并查看结果>创建 NetworkPolicy并查看结果</a></li><li><a href=#创建规则允许-icmp并查看规则变化>创建规则允许 ICMP并查看规则变化</a></li></ol></li><li><a href=#零信任架构zta>零信任架构（ZTA）</a><ol><li><a href=#传统安全模型>传统安全模型</a></li><li><a href=#零信任架构zero-trust-architecture-zta>零信任架构（Zero Trust Architecture， ZTA）</a></li><li><a href=#zta-安全模型>ZTA 安全模型</a></li><li><a href=#零信任架构的三大技术sim>零信任架构的三大技术"SIM"</a></li><li><a href=#软件定义边界sdp>软件定义边界（SDP）</a></li><li><a href=#身份识别与访问管理iam>身份识别与访问管理（IAM）</a></li><li><a href=#微隔离msg>微隔离（MSG）</a></li></ol></li><li><a href=#基于istio的安全保证>基于Istio的安全保证</a><ol><li><a href=#微服务架构下的安全挑战>微服务架构下的安全挑战</a></li><li><a href=#istio的安全保证>Istio的安全保证</a></li><li><a href=#高层架构>高层架构</a></li><li><a href=#istio安全架构>Istio安全架构</a></li><li><a href=#istio身份>Istio身份</a></li><li><a href=#sds>SDS</a></li></ol></li><li><a href=#认证>认证</a><ol><li><a href=#基于istio的认证>基于Istio的认证</a></li><li><a href=#istio认证架构>Istio认证架构</a></li><li><a href=#双向tls认证>双向TLS认证</a></li><li><a href=#宽容模式permissive-mode>宽容模式（permissive mode）</a></li><li><a href=#安全命名>安全命名</a></li><li><a href=#认证策略>认证策略</a></li><li><a href=#requestauthentication>RequestAuthentication</a></li></ol></li><li><a href=#鉴权>鉴权</a><ol><li><a href=#授权架构>授权架构</a></li><li><a href=#授权策略authorizationpolicy>授权策略（AuthorizationPolicy）</a></li><li><a href=#策略目标>策略目标</a></li><li><a href=#值匹配>值匹配</a></li><li><a href=#全部允许和默认全部拒绝授权策略>全部允许和默认全部拒绝授权策略</a></li><li><a href=#自定义条件>自定义条件</a></li><li><a href=#认证与未认证身份>认证与未认证身份</a></li><li><a href=#在普通-tcp协议上使用-istio-授权>在普通 TCP协议上使用 Istio 授权</a></li></ol></li></ol></nav></details></aside><a href=#云原生语境下的安全保证><h1 id=云原生语境下的安全保证><span class=hanchor arialabel=Anchor># </span>云原生语境下的安全保证</h1></a><a href=#云原生语境下的安全保证-1><h2 id=云原生语境下的安全保证-1><span class=hanchor arialabel=Anchor># </span>云原生语境下的安全保证</h2></a><p>安全保证是贯穿软件整个生命周期的重要部分。</p><p>安全与效率有时候是相违背的。</p><p>如何将二者统一起来，提升整体效率是关键。</p><p>这需要我们将安全思想贯穿到软件开发运维的所有环节。</p><a href=#云原生层次模型><h2 id=云原生层次模型><span class=hanchor arialabel=Anchor># </span>云原生层次模型</h2></a><p>软件的生命周期∶开发->分发→部署->运行</p><p><img src=https://obsidian.codeplayer.org//../../assets/image_1667396770608_0.png width=auto alt=image.png></p><a href=#开发环节的安全保证><h2 id=开发环节的安全保证><span class=hanchor arialabel=Anchor># </span>开发环节的安全保证</h2></a><p>SaaS 应用的 <a class="internal-link broken">12-factor</a> 设计原则的一些理念与云原生安全不谋而合。</p><p>传统的<strong>安全三元素 CIA（ConfidentialitVIntegrity和 AVailability）</strong>，在云原生安全中被充分应用，如对工作负载的完整性保护，与I（Integrity）完整性保护相对应。</p><ul><li>机密性（Confidentiality）指只有授权用户可以获取信息。</li><li>完整性（Integrity）指信息在输入和传输的过程中，不被非法授权修改和破坏，保证数据的一致性。</li><li>可用性（Availability）指保证合法用户对信息和资源的使用不会被不正当地拒绝。</li></ul><p>**基础设施即代码（Infrastructure as Code，简称 laC）**也与云原生的实践紧密相关。</p><p>这些方法和原则，都强调通过早期集成安全检测，以确保对过程的控制，使其按预期运行。</p><p>通过早期检测的预防性成本，降低后续的修复成本，提升了安全的价值。</p><a href=#开发><h2 id=开发><span class=hanchor arialabel=Anchor># </span>开发</h2></a><p><img src=https://obsidian.codeplayer.org//../../assets/image_1667397465681_0.png width=auto alt=image.png></p><a href=#分发环节的安全保证><h2 id=分发环节的安全保证><span class=hanchor arialabel=Anchor># </span>分发环节的安全保证</h2></a><p>云原生应用生命周期中的分发阶段不仅需要包括验证工作负载本身的完整性的方法，还需要包括创建工作负载的过程和操作手段。</p><p>对于软件生产周期流水线中产生的工件（如容器镜像），，需要进行持续的自动扫描和更新来确保安全，防止漏洞、恶意软件、不安全的编码和其他不安全的行为。</p><p>在完成这些检查后，更重要的是对产品进行加密签名，以确保产品的完整性及不可抵赖性。</p><a href=#分发><h2 id=分发><span class=hanchor arialabel=Anchor># </span>分发</h2></a><p><img src=https://obsidian.codeplayer.org//../../assets/image_1667397782368_0.png width=auto alt=image.png></p><a href=#部署环节的安全保证><h2 id=部署环节的安全保证><span class=hanchor arialabel=Anchor># </span>部署环节的安全保证</h2></a><p>在整个开发和集成发布阶段，应对候选工作负载的安全性进行实时和持续的验证，如，对签名的工件进行校验，确保容器镜像安全和运行时安全，并可验证主机的适用性。</p><p>安全工作负载的监控能力，应以可信的方式监控日志和可用指标，与工作负载一同部署来完善整体的安全性。</p><a href=#部署><h1 id=部署><span class=hanchor arialabel=Anchor># </span>部署</h1></a><p><img src=https://obsidian.codeplayer.org//../../assets/image_1667397846895_0.png width=auto alt=image.png></p><a href=#运行时环节的安全保><h2 id=运行时环节的安全保><span class=hanchor arialabel=Anchor># </span>运行时环节的安全保</h2></a><p>应用程序通常由多个独立和单一职责的微服务组成，容器编排层使得这些微服务通过服务层抽象进行相互通信。</p><p>确保这种相互关联的组件架构安全的最佳实践，包括以下几点∶</p><ol><li><p>只有经过批准的进程能在容器命名空间内运行;</p></li><li><p>禁止并报告未经授权的资源访问;</p></li><li><p>监控网络流量以检测恶意的活动;</p></li><li><p>服务网格是另一种常见的服务层抽象，它为已经编排的服务提供了整合和补充功能，而不会改变工作负载软件本身（例如，API流量的日志记录、传输加密、可观察性标记、认证和授权）。</p></li></ol><a href=#运行环境><h2 id=运行环境><span class=hanchor arialabel=Anchor># </span>运行环境</h2></a><p><img src=https://obsidian.codeplayer.org//../../assets/image_1667397948189_0.png width=auto alt=image.png></p><a href=#容器运行时的安全保证><h1 id=容器运行时的安全保证><span class=hanchor arialabel=Anchor># </span>容器运行时的安全保证</h1></a><a href=#以-non-root-身份运行容器><h2 id=以-non-root-身份运行容器><span class=hanchor arialabel=Anchor># </span>以 Non-root 身份运行容器</h2></a><p><strong>在 Dockerfile 中通过 USER命令切换成非 root用户。</strong></p><p>原因分析：</p><p>防止某些坏的镜像窃取主机的 root 权限并造成危害。</p><p>有些运行时容器内部的root 用户与主机的 root 用户是同一个用户，如不进行用户切换很可能因为权限过大引发严重的问题，比如一个最简单的 case，主机上的重要文件夹被mount 到容器内部，并被容器修改配置。</p><p>即使在容器内部也应该进行权限隔离，比如当我们希望构建不可变配置的容器镜像时，应该将运行容器的用户切换为非 root 用户，并且限制其读写权限和读写目录。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Dockerfile data-lang=Dockerfile><span class=line><span class=cl><span class=k>FROM</span><span class=s> ubuntu</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> user add patrick<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>USER</span><span class=s> patrick</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><a href=#user-namespace-和-rootless-container><h2 id=user-namespace-和-rootless-container><span class=hanchor arialabel=Anchor># </span>User Namespace 和 rootless container</h2></a><p><strong>User Namespace:</strong></p><ul><li>依赖于 User namespace，任何容器内部的用户都会映射成主机的非 root 用户。</li><li>但该功能未被默认enable，因其引入配置复杂性，比如系统不知道主机用户和容器用户的映射关系， 在 mount 文件的时候无法设置适当的权限。</li></ul><p><strong>Rootless container:</strong></p><ul><li>rootless Container 是指容器运行时以非 root 身份启动。</li><li>在该配置下，即使容器被突破，在主机层面获得的用户权限也是非 root 身份的用户，这确保了安全。</li><li>Docker 和其他运行时本身的后台 Daemon（如Docker Daemon）需要 root 身份运行，然后其他用户的容器才能以rootless 身份运行。</li><li>一些运行时，比如 Podman，无需 Daemon 进程，因为可以完全不需要 root 身份。</li></ul><a href=#集群的安全性保证><h2 id=集群的安全性保证><span class=hanchor arialabel=Anchor># </span>集群的安全性保证</h2></a><p>保证容器与容器之间、容器与主机之间隔离，限制容器对其他容器和主机的消极影响。</p><p>保证组件、用户及容器应用程序都是最小权限，限制它们的权限范围。</p><p>保证集群的敏感数据的传输和存储安全。</p><p>常用手段</p><ul><li>Pod安全上下文（Pod Security Context）</li><li>API Server的认证、授权、审计和准入控制</li><li>数据的加密机制等</li></ul><a href=#kubernetes-的安全保证><h1 id=kubernetes-的安全保证><span class=hanchor arialabel=Anchor># </span>Kubernetes 的安全保证</h1></a><a href=#集群的安全通信><h2 id=集群的安全通信><span class=hanchor arialabel=Anchor># </span>集群的安全通信</h2></a><p>Kubernetes 期望集群中所有的API通信在默认情况下都使用TLS加密，大多数安装方法也允许创建所需的证书并且分发到集群组件中。</p><p><img src=https://obsidian.codeplayer.org//../../assets/image_1667398917035_0.png width=auto alt=image.png></p><a href=#控制面安全保证><h2 id=控制面安全保证><span class=hanchor arialabel=Anchor># </span>控制面安全保证</h2></a><p><strong>认证</strong></p><p>小型的单用户集群可能希望使用简单的证书或静态承载令牌方法。</p><p>更大的集群则可能希望整合现有的、OIDC、LDAP等允许用户分组的服务器。</p><p>所有 API客户端都必须经过身份验证，即使它是基础设施的一部分，比如节点、代理、调度程序和卷插件。这些客户端通常使用<strong>服务帐户或 X509 客户端证书</strong>，并在集群启动时自动创建或是作为集群安装的一部分进行设置。</p><p><strong>授权</strong></p><p>与身份验证一样，简单而广泛的角色可能适合于较小的集群，但是随着更多的用户与集群交互，可能需要将团队划分成有更多角色限制的单独的命名空间。</p><p><strong>配额</strong></p><p>资源配额限制了授予命名空间的资源的数量或容量。这通常用于限制命名空间可以分配的CPU、内存或持久磁盘的数量，但也可以控制每个命名空间中有多少个Pod、服务或卷的存在。</p><a href=#noderestriction><h2 id=noderestriction><span class=hanchor arialabel=Anchor># </span>NodeRestriction</h2></a><p>准入控制器限制了kubelet 可以修改的 Node 和 Pod 对象，kubelet只可修改自己的 Node API对象，只能修改绑定到节点本身的 Pod 对象。</p><p>NodeRestriction准入插件可防止kubelet 删除 Node API对象。</p><p>防止 kubelet 添加/删除/更新带有 node-restriction.kubernetes.io/前缀的标签。</p><p>将来的版本可能会增加其他限制，以确保 kubelet 具有正常运行所需的最小权限集。</p><p>思考为什么?</p><p>降低获得kubelet kubeconfig 的人能做成的破坏。</p><a href=#security-context><h2 id=security-context><span class=hanchor arialabel=Anchor># </span>Security Context</h2></a><p>Pod 定义包含了一个安全上下文，用于描述允许它请求访问某个节点上的特定 Linux用户（如root）、获得特权或访问主机网络，以及允许它在主机节点上不受约束地运行的其它控件。</p><p><strong>Pod 安全策略</strong>可以限制哪些用户或服务帐户可以提供危险的安全上下文设置。例如∶Pod 的安全策略可以限制卷挂载，尤其是 hostpath，这些都是 Pod 应该控制的一些方面。</p><p>一般来说，大多数应用程序需要限制对主机资源的访问，他们可以在不能访问主机信息的情况下成功以根进程（UID 0）运行。但是，考虑到与root 用户相关的特权，在编写应用程序容器时，你应该使用非 root 用户运行。</p><p>类似地，希望阻止客户端应用程序逃避其容器的管理员，应该使用限制性的Pod 安全策略。</p><p><strong>Kubernetes提供了三种配置 Security Context 的方法∶</strong></p><ul><li>Container-level Security Context∶仅应用到指定的容器。</li><li>Pod-level Security Context∶应用到 Pod 内所有容器以及Volume。</li><li>Pod Security Policies（PSP）∶应用到集群内部所有 Pod 以及Volume。</li></ul><a href=#container-level-security-context><h2 id=container-level-security-context><span class=hanchor arialabel=Anchor># </span>Container-level Security Context</h2></a><p><strong>Container-level Security Context</strong>仅应用到指定的容器上，并且不会影响Volume。比如设置容器运行在特权模式：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Pod</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>hello-world</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>containers</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>hello-world-container # The container definition</span><span class=w> </span><span class=c>#…</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>securityContext</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>privileged</span><span class=p>:</span><span class=w> </span><span class=kc>true</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><a href=#pod-level-security-context><h2 id=pod-level-security-context><span class=hanchor arialabel=Anchor># </span>Pod-level Security Context</h2></a><p>Pod-level Security Context 应用到Pod 内所有容器，并且还会影响Volume（包括fsGroup和selinuxOptions）。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Pod</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>hello-world</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>containers</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c># specification of the pod&#39;s containers</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c>#…</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>securityContext</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>fsGroup</span><span class=p>:</span><span class=w> </span><span class=m>1234</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>supplementalGroups</span><span class=p>:</span><span class=w> </span><span class=p>[</span><span class=m>5678</span><span class=p>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>seLinuxOptions</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>level</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;s0:c123,c456&#34;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><a href=#pod-security-policiespsp><h2 id=pod-security-policiespsp><span class=hanchor arialabel=Anchor># </span>Pod Security Policies(PSP)</h2></a><p>Pod Security Policies（PSP）是集群级的Pod安全策略，自动为集群内的Pod和Volume设置Security Context。</p><p><img src=https://obsidian.codeplayer.org//../../assets/image_1667405053981_0.png width=auto alt=image.png></p><a href=#psp示例><h2 id=psp示例><span class=hanchor arialabel=Anchor># </span>PSP示例</h2></a><p><strong>限制容器的 host端口范围为 8000-8080：</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>extensions/v1beta1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>PodSecurityPolicy</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>permissive</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>selinux</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>rule</span><span class=p>:</span><span class=w> </span><span class=l>RunAsAny</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>supplementalGroups</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>rule</span><span class=p>:</span><span class=w> </span><span class=l>RunAsAny</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>runAsUser</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>rule</span><span class=p>:</span><span class=w> </span><span class=l>RunAsAny</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>fsGroup</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>rule</span><span class=p>:</span><span class=w> </span><span class=l>RunAsAny</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>hostPorts</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>min</span><span class=p>:</span><span class=w> </span><span class=m>8000</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>max</span><span class=p>:</span><span class=w> </span><span class=m>8080</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>volumes</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=s1>&#39;*&#39;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><a href=#taint><h1 id=taint><span class=hanchor arialabel=Anchor># </span>Taint</h1></a><a href=#为节点增加-taint><h2 id=为节点增加-taint><span class=hanchor arialabel=Anchor># </span>为节点增加 taint</h2></a><p><strong>使用命令kubectl taint给节点增加一个Taint：</strong></p><p><code>kubectl taint nodes node1 key=value:NoSchedule</code></p><p><strong>运行如下命令删除Taint：</strong></p><p><code>kubectl taint nodes node1 key:NoSchedule-</code></p><p><strong>在 PodSpec中为容器设定容忍标签：</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>tolerations</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- <span class=nt>key</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;key&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>operator</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;Equal&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>value</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;value&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>effect</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;NoSchedule&#34;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>tolerations</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- <span class=nt>key</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;key&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>operator</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;Exists&#39;
</span></span></span><span class=line><span class=cl><span class=s2>  effect: &#34;</span><span class=l>NoSchedule&#34;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><a href=#taint-1><h2 id=taint-1><span class=hanchor arialabel=Anchor># </span>Taint</h2></a><p>可以以租户为粒度，为不同租户的节点增加 Taint，使得节点彼此隔离。</p><p>Taint的作用是让租户独占节点，无对应Toleration的 Pod无法被调度到Taint节点上，实现了应用部署的隔离。</p><a href=#networkpolicy><h1 id=networkpolicy><span class=hanchor arialabel=Anchor># </span>NetworkPolicy</h1></a><a href=#networkpolicy-1><h2 id=networkpolicy-1><span class=hanchor arialabel=Anchor># </span>NetworkPolicy</h2></a><p>如果你希望在 IP地址或端口层面（OSI第 3层或第 4 层）控制网络流量，则你可以考虑为集群中特定应用使用Kubernetes 网络策略（NetworkPolicy）。</p><p>Pod 可以通信的 Pod是通过如下三个标识符的组合来辩识的：</p><ul><li>其他被允许的 Pods；</li><li>被允许的名字空间；</li><li>IP组块。</li></ul><p>网络策略通过网络插件来实现。要使用网络策略，你必须使用支持 NetworkPolicV 的网络解决方案。<strong>创建一个NetworkPolicy资源对象而没有控制器来使它生效的话，是没有任何作用的。</strong></p><a href=#隔离和非隔离的pod><h2 id=隔离和非隔离的pod><span class=hanchor arialabel=Anchor># </span>隔离和非隔离的Pod</h2></a><p>默认情况下，Pod是非隔离的，它们接受任何来源的流量。</p><p>Pod在被某 NetworkPolicy选中时进入被隔离状态。</p><p>一旦名字空间中有NetworkPolicy 选择了特定的 Pod，该 Pod 会拒绝该NetworkPolicy所不允许的连接。</p><p>网络策略不会冲突，它们是累积的。如果任何一个或多个策略选择了一个Pod，则该 Pod 受限于这些策略的<strong>入站（Ingress）/出站（Egress）规则</strong>的并集。因此评估的顺序并不会影响策略的结果。</p><p>为了允许两个Pods 之间的网络数据流，源端 Pod 上的出站（Earess）规则和目标端 Pod 上的入站（Ingress）规则都需要允许该流量。如果源端的出站（Egress）规则或目标端的入站（Ingress）规则拒绝该流量，则流量将被拒绝。</p><a href=#安全策略属性><h2 id=安全策略属性><span class=hanchor arialabel=Anchor># </span>安全策略属性</h2></a><p><strong>spec：</strong> NetworkPolicy规约中包含了在一个名字空间中定义特定网络策略所需的所有信息。</p><p><strong>podSelector：</strong></p><ul><li>每个 NetworkPolicy都包括一个 podSelector，它对该策略所适用的一组 Pod进行选择。</li><li>空的 podSelector 选择名字空间下的所有 Pod。</li></ul><p><strong>policyTypes：</strong></p><ul><li>每个NetworkPolicy都包含一个policyTypes列表，其中包含Ingress或Egress 或两者兼具。</li><li>如果 NetworkPolicy未指定 policyTypes 则默认情况下始终设置Ingress；</li><li>如果 NetworkPolicy 有任何出口规则的话则设置 Egress。</li></ul><a href=#安全策略属性-1><h2 id=安全策略属性-1><span class=hanchor arialabel=Anchor># </span>安全策略属性</h2></a><p>Ingress：</p><ul><li>每个NetworkPolicy可包含一个Ingress规则的白名单列表。</li><li>每个规则都允许同时匹配 from 和 ports 部分的流量。</li></ul><p>Egress：</p><ul><li>每个NetworkPolicy可包含一个Egress 规则的白名单列表。</li><li>每个规则都允许匹配 to 和 port 部分的流量。</li></ul><a href=#networkpolicy-2><h2 id=networkpolicy-2><span class=hanchor arialabel=Anchor># </span>NetworkPolicy</h2></a><p><img src=https://obsidian.codeplayer.org//../../assets/image_1667463041667_0.png width=auto alt=image.png></p><a href=#默认策略><h2 id=默认策略><span class=hanchor arialabel=Anchor># </span>默认策略</h2></a><p><img src=https://obsidian.codeplayer.org//../../assets/image_1667463441696_0.png width=auto alt=image.png></p><p><img src=https://obsidian.codeplayer.org//../../assets/image_1667463453193_0.png width=auto alt=image.png></p><a href=#依托于calico-的networkpolicy><h1 id=依托于calico-的networkpolicy><span class=hanchor arialabel=Anchor># </span>依托于Calico 的NetworkPolicy</h1></a><a href=#networkpolicy-3><h2 id=networkpolicy-3><span class=hanchor arialabel=Anchor># </span>NetworkPolicy</h2></a><p>NetworkPolicy是命名空间级别资源。规则应用于与标签选择器匹配的endpoint 的集合。</p><p><img src=https://obsidian.codeplayer.org//../../assets/image_1667464499256_0.png width=auto alt=image.png></p><a href=#globalnetworkpolicy><h2 id=globalnetworkpolicy><span class=hanchor arialabel=Anchor># </span>GlobalNetworkPolicy</h2></a><p>GlobalNetworkPolicy与 NetworkPolicy 功能一样，是整个集群级别的资源。</p><p>GlobalNetworkPolicy 会在集群中所有 Namespace生效，并且能限制主机（HostEndpoint）。</p><a href=#理解calico-的防火墙规则><h2 id=理解calico-的防火墙规则><span class=hanchor arialabel=Anchor># </span>理解Calico 的防火墙规则</h2></a><p><img src=https://obsidian.codeplayer.org//../../assets/image_1667465894838_0.png width=auto alt=image.png></p><a href=#创建-networkpolicy并查看结果><h2 id=创建-networkpolicy并查看结果><span class=hanchor arialabel=Anchor># </span>创建 NetworkPolicy并查看结果</h2></a><p><img src=https://obsidian.codeplayer.org//../../assets/image_1667465920840_0.png width=auto alt=image.png></p><a href=#创建规则允许-icmp并查看规则变化><h2 id=创建规则允许-icmp并查看规则变化><span class=hanchor arialabel=Anchor># </span>创建规则允许 ICMP并查看规则变化</h2></a><p><img src=https://obsidian.codeplayer.org//../../assets/image_1667465957616_0.png width=auto alt=image.png></p><a href=#零信任架构zta><h1 id=零信任架构zta><span class=hanchor arialabel=Anchor># </span>零信任架构（ZTA）</h1></a><a href=#传统安全模型><h2 id=传统安全模型><span class=hanchor arialabel=Anchor># </span>传统安全模型</h2></a><p><strong>DMZ模式</strong></p><p>传统的网络安全架构理念是基于边界的安全架构，企业构建网络安全体系时，首先寻找安全边界，把网络划分为外网、内网、DMZ（DeMilitarized Zone）区等不同的区域然后在边界上部署防火墙、入侵检测、WAF等产品。</p><p>这种网络安全架构假设或默认了内网比外网更安全，在某种程度上预设了对内网中的人、设备和系统的信任，忽视加强内网安全措施。</p><p>不法分子一旦突破企业的边界安全防护进入内网，会像进入无人之境，将带来严重的后果。</p><p>传统的认证，即信任、边界防护、静态访问控制、以网络为中心。</p><p><img src=https://obsidian.codeplayer.org//../../assets/image_1667468838210_0.png width=auto alt=image.png></p><a href=#零信任架构zero-trust-architecture-zta><h2 id=零信任架构zero-trust-architecture-zta><span class=hanchor arialabel=Anchor># </span>零信任架构（Zero Trust Architecture， ZTA）</h2></a><p>随着云计算、大数据、物联网、移动办公等新技术与业务的深度融合，网络安全边界也逐渐变得更加模糊，传统边界安全防护理念面临巨大挑战。</p><p><strong>零信任核心原则：从不信任，始终验证</strong></p><p>动态安全架构：</p><ul><li>以身份为中心</li><li>以识别、持续认证、动态访问控制、授权、审计以及监测为链条</li><li>以最小化实时授权为核心</li><li>以多维信任算法为基础</li><li>认证达末端</li></ul><p><img src=https://obsidian.codeplayer.org//../../assets/image_1667468921971_0.png width=auto alt=image.png></p><hr><p>与边界模型的"信任但验证"不同，零信任的核心原则是"从不信任、始终验证"。</p><p>根据Evan Gilman《Zero Trust Networks》书中所述，零信任网络建立在五个假设前提之下∶</p><ul><li>外部和内部威胁每时每刻都充斥着网络;</li><li>不能仅仅依靠网络位置来确认信任关系;</li><li>所有设备、用户、网络流量都应该被认证和授权;</li><li>访问控制策略应该动态地基于尽量多的数据源进行计算和评估。</li></ul><a href=#zta-安全模型><h2 id=zta-安全模型><span class=hanchor arialabel=Anchor># </span>ZTA 安全模型</h2></a><ul><li>零信任数据</li><li>零信任人员</li><li>零信任网络</li><li>零信任工作负载</li><li>零信任设备</li><li>可视化和分析</li><li>自动化和编排</li></ul><p><img src=https://obsidian.codeplayer.org//../../assets/image_1667469502375_0.png width=auto alt=image.png></p><a href=#零信任架构的三大技术sim><h2 id=零信任架构的三大技术sim><span class=hanchor arialabel=Anchor># </span>零信任架构的三大技术"SIM"</h2></a><p>零信任架构的三大技术"SIM"，即</p><ul><li>软件定义边界（SDP，Software Defined Perimeter）</li><li>身份识别与访问管理（IAM， Identity and Access Management）</li><li>微隔离（MSG，Micro Segmentation）</li></ul><a href=#软件定义边界sdp><h2 id=软件定义边界sdp><span class=hanchor arialabel=Anchor># </span>软件定义边界（SDP）</h2></a><p>SDP旨在使应用程序所有者能在需要时部署安全边界，以便将服务与不安全的网络隔离开。</p><p>SDP将物理设备替换为在应用程序所有者控制下运行的逻辑组件，仅在设备验证和身份验证后才允许访问企业应用基础架构。</p><p>基于 SDP的系统通常会实施控制层与数据层的分离：</p><ul><li>控制流阶段，用户及其设备进行预认证来获取丰富的属性凭据作为身份主体，以此结合基于属性的预授权策略，映射得到仅供目标访问的特定设备和服务;</li><li>数据传输阶段直接建立相应安全连接并传输数据。</li></ul><a href=#身份识别与访问管理iam><h2 id=身份识别与访问管理iam><span class=hanchor arialabel=Anchor># </span>身份识别与访问管理（IAM）</h2></a><p>零信任强调基于身份的信任链条，即该身份在可信终端，该身份拥有权限才可对资源进行请求。</p><p>传统的 IAM系统可以协助解决身份唯一标识、身份属性、身份全生命周期管理的功能问题。</p><p>通过IAM 将身份信息（身份吊销离职、身份过期、身份异常等）传递给零信任系统后.零信任系统可以通过IAM系统的身份信息来分配相应权限。</p><p>通过 IAM系统对身份的唯一标识，可有利于零信任系统确认用户可信，通过唯一标识对用户身份建立起终端、资源的信任关系，并在发现风险时实施针对关键用户相关的访问连接进行阻断等控制。</p><a href=#微隔离msg><h2 id=微隔离msg><span class=hanchor arialabel=Anchor># </span>微隔离（MSG）</h2></a><p><strong>微隔离本质上是一种网络安全隔离技术</strong></p><ul><li>能够在逻辑上将数据中心划分为不同的安全段，一直到各个工作负载级别;</li><li>为每个独立的安全段定义访问控制策略。</li></ul><p><strong>它主要聚焦在云平台东西向流量的隔离</strong></p><ul><li>一是区别传统物理防火墙的隔离作用;</li><li>二是更加贴近云计算环境中的真实需求。</li></ul><p>微隔离将网络边界安全理念发挥到极致，将网络边界分割到尽可能的小.能够很好的缓解传统</p><p>边界安全理念下的边界过度信任带来的安全风险。</p><a href=#基于istio的安全保证><h1 id=基于istio的安全保证><span class=hanchor arialabel=Anchor># </span>基于Istio的安全保证</h1></a><a href=#微服务架构下的安全挑战><h2 id=微服务架构下的安全挑战><span class=hanchor arialabel=Anchor># </span>微服务架构下的安全挑战</h2></a><p>为了抵御中间人攻击，需要流量加密。</p><p>为了提供灵活的服务访问控制，需要双向TLS和细粒度的访问策略。</p><p>要确定谁在什么时候做了什么，需要审计工具。</p><a href=#istio的安全保证><h2 id=istio的安全保证><span class=hanchor arialabel=Anchor># </span>Istio的安全保证</h2></a><p><strong>Istio安全功能提供：</strong></p><ul><li>身份识别；</li><li>灵活策略；</li><li>透明的TLS加密；</li><li>认证，授权和审计（AAA）工具来保护你的服务和数据。</li></ul><p><strong>Istio安全的目标是：</strong></p><ul><li>默认安全：应用程序代码和基础设施无需更改。</li><li>深度防御：与现有安全系统集成以提供多层防御。</li><li>零信任网络：在不受信任的网络上构建安全解决方案。</li></ul><p><img src=https://obsidian.codeplayer.org//../../assets/image_1667470319529_0.png width=auto alt=image.png></p><a href=#高层架构><h2 id=高层架构><span class=hanchor arialabel=Anchor># </span>高层架构</h2></a><p>用于密钥和证书管理的证书颁发机构（CA）。</p><p>配置 API服务器分发给代理∶</p><ul><li>认证策略</li><li>授权策略</li></ul><p>安全命名信息</p><p>Sidecar和边缘代理作为 Policy Enforcement Points（PEPs）以保护客户端和服务器之间的通信安全。</p><p>一组 Envoy代理扩展，用于管理遥测和审计。</p><a href=#istio安全架构><h2 id=istio安全架构><span class=hanchor arialabel=Anchor># </span>Istio安全架构</h2></a><p><img src=https://obsidian.codeplayer.org//../../assets/image_1667470608630_0.png width=auto alt=image.png></p><a href=#istio身份><h2 id=istio身份><span class=hanchor arialabel=Anchor># </span>Istio身份</h2></a><p>身份是任何安全基础架构的基本概念。</p><p>在工作负载间通信开始时，双方必须交换包含身份信息的凭证以进行双向验证。</p><p>在客户端，根据安全命名信息检查服务器的标识，以查看它是否是该服务的授权运行程序。</p><p>在服务器端，服务器可以根据授权策略确定客户端可以访问哪些信息，审计谁在什么时间访问了什么，根据他们使用的工作负载向客户收费，并拒绝任何未能支付账单的客户访问工作负载。</p><p>Istio 身份模型使用 service identity（服务身份）来确定一个请求源端的身份。</p><hr><p><strong>Kubernetes：</strong> Kubernetes 服务帐户</p><p><strong>GKE/GCE：</strong> 可以使用GCP服务帐户</p><p><strong>GCP：</strong> GCP服务帐户</p><p><strong>AWS：</strong> AWSIAM用户/角色帐户</p><p><strong>On-premises（非Kubernetes）：</strong> 用户帐户、自定义服务帐户、服务名称、Istio 服务帐户或 GCP服务帐户。</p><p><strong>Istio安全与 SPIFFE：</strong></p><p>Istio 和 SPIFFE共享相同的身份文件∶SVID（SPIFFE 可验证身份证件）。例如∶ 在 Kubernetes 中，X.509证书的 URI学段格式为 <code>spiffe∶//&lt;domain>/ns/&lt;namespace>/sa/&lt;serviceaccount></code>。这使 Istio 服务能够建立和接受与其他 SPIFFE兼容系统的连接。</p><a href=#sds><h2 id=sds><span class=hanchor arialabel=Anchor># </span>SDS</h2></a><p><strong>Istio供应身份是通过secret discovery service（SDS）来实现的：</strong></p><ul><li>istiod提供 gRPC服务以接受证书签名请求（CSRS）。</li><li>当工作负载启动时，Envoy通过秘密发现服务（SDS）API向同容器内的istio-agent发送证书和密钥请求。</li><li>在收到SDS请求后，istio-agent创建私钥和CSR，然后将CSR及其凭据发送到 istiod CA进行签名。</li><li>istiod CA 验证CSR中携带的凭据，成功验证后签署CSR以生成证书。</li><li>istio-agent 通过Envoy SDS API将私钥和从Istio CA 收到的证书发送给Envoy。</li><li>istio-agent 会监工作负载证书的有效期。上述CSR 过程会周期性地重复，以处理证书和密钥轮换。</li></ul><p><img src=https://obsidian.codeplayer.org//../../assets/image_1667470838581_0.png width=auto alt=image.png></p><a href=#认证><h1 id=认证><span class=hanchor arialabel=Anchor># </span>认证</h1></a><a href=#基于istio的认证><h2 id=基于istio的认证><span class=hanchor arialabel=Anchor># </span>基于Istio的认证</h2></a><ul><li>Istio 通过客户端和服务器端 Policy Enforcement Points（PEPs）建立服务到服务的通信通道。</li><li>PEPS在 Istio 架构中的实现是 Envoy。</li><li><strong>Peer authentication：</strong><ul><li>用于服务到服务的认证，以验证进行连接的客户端。</li></ul></li><li><strong>Istio 提供双向 TLS作为传输认证的全栈解决方案，无需更改服务代码就可以启用它</strong>。这个解决方案为：<ul><li>为每个服务提供强大的身份，表示其角色，以实现跨群集和云的互操作性。</li><li>保护服务到服务的通信。</li><li>提供密钥管理系统，以自动进行密钥和证书的生成，分发和轮换。</li></ul></li><li><strong>Request authentication</strong><ul><li>用于最终用户认证，以验证附加到请求的凭据。</li><li>Istio 使用JSON Web Token（JWT）验证启用请求级认证，并使用自定义认证实现或任何OpenID Connect 的认证实现（例如下面列举的）来简化的开发人员体验。</li></ul></li></ul><a href=#istio认证架构><h2 id=istio认证架构><span class=hanchor arialabel=Anchor># </span>Istio认证架构</h2></a><ul><li>未设置模式的网格范围的peer认证策略默认使用PERMISSIVE模式。</li><li>发送请求的客户端服务负责遵循必要的认证机制。</li><li><strong>RequestAuthentication</strong><ul><li>应用程序负责获取JWT凭证并将其附加到请求。</li></ul></li><li><strong>PeerAuthentication</strong><ul><li>Istio会自动将两个PEPS之间的所有流量升级为双向TLS。</li><li>如果认证策略禁用了双向TLS模式，则Istio将继续在PEPS之间使用纯文本。</li><li>要覆盖此行为，destination rules 显式禁用双向TLS模式。</li></ul></li></ul><p><img src=https://obsidian.codeplayer.org//../../assets/image_1667471444924_0.png width=auto alt=image.png></p><a href=#双向tls认证><h2 id=双向tls认证><span class=hanchor arialabel=Anchor># </span>双向TLS认证</h2></a><p><strong>当一个工作负载使用双向TLS认证向另一个工作负载发送请求时，该请求的处理方式如下：</strong></p><ul><li>Istio 将出站流量从客户端重新路由到客户端的本地 sidecar Envoy。</li><li>客户端 Envoy与服务器端 Envoy 开始双向TLS握手。在握手期间，客户端 Envoy还做了安全命名检查，以验证服务器证书中显示的服务帐户是否被授权运行目标服务。</li><li>客户端 Envoy和服务器端 Envoy建立了一个双向的TLS连接，Istio 将流量从客户端 Envoy转发到服务器端 Envoy。</li><li>授权后，服务器端 Envoy 通过本地 TCP连接将流量转发到服务器服务。</li></ul><a href=#宽容模式permissive-mode><h2 id=宽容模式permissive-mode><span class=hanchor arialabel=Anchor># </span>宽容模式（permissive mode）</h2></a><p>允许服务同时接受纯文本流量和双向 TLS流量。</p><p>这个功能极大地提升了双向TLS的入门体验。</p><p>在运维人员希望将服务移植到启用了双向TLS 的Istio上时，许多非Istio客户端和非 Istio 服务端通信时会产生问题。</p><p>通常情况下，运维人员无法同时为所有客户端安装Istio sidecar，甚至没有这样做的权限。即使在服务端上安装了Istio sidecar，运维人员也无法在不中断现有连接的情况下启用双向TLS。</p><a href=#安全命名><h2 id=安全命名><span class=hanchor arialabel=Anchor># </span>安全命名</h2></a><p>服务器身份（server identities）被编码在证书里，但服务名称（service names）通过服务发现或 DNS被检索。</p><p>安全命名信息将服务器身份映射到服务名称。</p><p>身份A到服务名称B的映射表示"授权 A运行服务 B"。</p><p>控制平面监视 apiserver，生成安全命名映射，并将其安全地分发到PEPs。以下示例说明了为什么安全命名对身份验证至关重要。</p><a href=#认证策略><h2 id=认证策略><span class=hanchor arialabel=Anchor># </span>认证策略</h2></a><p>认证策略是对服务收到的请求生效的；</p><p>要在双向TLS中指定<strong>客户端</strong>认证策略，需要在 DetinationRule 中设置 TLSSettings。</p><p><img src=https://obsidian.codeplayer.org//../../assets/image_1667472040181_0.png width=auto alt=image.png></p><p>相应的需要通过PeerAuthentication配置服务端接受何种认证方式</p><p><img src=https://obsidian.codeplayer.org//../../assets/image_1667472078286_0.png width=auto alt=image.png></p><a href=#requestauthentication><h2 id=requestauthentication><span class=hanchor arialabel=Anchor># </span>RequestAuthentication</h2></a><p><strong>Request 认证策略指定验证 JSON Web Token（JWT）所需的值。</strong> 这些值包括：</p><ul><li>token 在请求中的位置</li><li>请求的 issuer</li><li>共 JSON Web Key Set（JWKS）</li></ul><p>Istio 会根据request 认证策略中的规则检查提供的令牌（如果已提供），并拒绝令牌无效的请求。</p><p>当请求不带有令牌时，默认情况下将接受它们。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>security.istio.io/v1beta1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>RequestAuthentication</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;default&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>namespace</span><span class=p>:</span><span class=w> </span><span class=l>istio-system</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>selector</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>matchLabels</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>istio</span><span class=p>:</span><span class=w> </span><span class=l>ingressgateway</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>jwtRules</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>issuer</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;testing@secure.istio.io&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>jwksUri</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;https://raw.githubusercontent.com/istio/istio/release-1.12/security/tools/jwt/samples/jwks.json&#34;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><a href=#鉴权><h1 id=鉴权><span class=hanchor arialabel=Anchor># </span>鉴权</h1></a><a href=#授权架构><h2 id=授权架构><span class=hanchor arialabel=Anchor># </span>授权架构</h2></a><p><strong>每个Envoy代理都运行一个授权引擎，该引擎在运行时授权请求。</strong></p><ul><li>当请求到达代理时，授权引擎根据当前授权策略评估请求上下文，并返回授权结果ALLOW或DENY。</li><li>授权策略支持ALLOW和DENY动作，拒绝策略优先于允许策略。</li><li>如果将任何允许策略应用于工作负载，则默认情况下，不符合该策略的访问都将被禁止。</li></ul><p><img src=https://obsidian.codeplayer.org//../../assets/image_1667474428578_0.png width=auto alt=image.png></p><a href=#授权策略authorizationpolicy><h2 id=授权策略authorizationpolicy><span class=hanchor arialabel=Anchor># </span>授权策略（AuthorizationPolicy）</h2></a><ul><li>selector字段指定策略的目标</li><li>action字段指定允许还是拒绝请求</li><li>rules 指定何时触发动作<ul><li>rules下的from字段指定请求的来源</li><li>rules下的to字段指定请求的操作</li><li>rules下的when字段指定应用规则所需的条件</li></ul></li></ul><p><img src=https://obsidian.codeplayer.org//../../assets/image_1667474516979_0.png width=auto alt=image.png></p><p><img src=https://obsidian.codeplayer.org//../../assets/image_1667474532819_0.png width=auto alt=image.png>{:height 465, :width 458}</p><a href=#策略目标><h2 id=策略目标><span class=hanchor arialabel=Anchor># </span>策略目标</h2></a><p>可以通过 metadata/namespace 字段和可选的selector字段来指定策略的范围或目标。</p><p>metadata/namespace告诉该策略适用于哪个命名空间。如果将其值设置为根名称空间，则该策略将应用于网格中的所有名称空间。</p><p>根命名空间的值是可配置的，默认值为 istio-system。</p><p>您可以使用selector字段来进一步限制策略以应用于特定工作负载。</p><p>如果未设置，则授权策略将应用于与授权策略相同的命名空间中的所有工作负载。</p><p><img src=https://obsidian.codeplayer.org//../../assets/image_1667474660706_0.png width=auto alt=image.png></p><a href=#值匹配><h2 id=值匹配><span class=hanchor arialabel=Anchor># </span>值匹配</h2></a><p>授权策略中的大多数字段都支持以下所有匹配模式：</p><ul><li>完全匹配即完整的字符串匹配。</li><li>前缀匹配："*&ldquo;结尾的字符串。例如，&ldquo;test.abc.*&ldquo;匹配"test.abc.com&rdquo;、&ldquo;test.abc.com.cn&rdquo;、&ldquo;test.abc.org"等等。后缀匹配&rdquo;<em>&ldquo;开头的字符串。例如，&rdquo;</em>.abc.com"匹配"eng.abc.com&rdquo;、&ldquo;test.eng.abc.com"等等。</li><li>存在匹配：*用于指定非空的任意内容。您可以使用格式fieldname∶[&rdquo;*"]指定必须存在的字段。这意味着该字段可以匹配任意内容，但是不能为空。</li></ul><p><img src=https://obsidian.codeplayer.org//../../assets/image_1667474807722_0.png width=auto alt=image.png></p><a href=#全部允许和默认全部拒绝授权策略><h2 id=全部允许和默认全部拒绝授权策略><span class=hanchor arialabel=Anchor># </span>全部允许和默认全部拒绝授权策略</h2></a><p><img src=https://obsidian.codeplayer.org//../../assets/image_1667474840372_0.png width=auto alt=image.png></p><a href=#自定义条件><h2 id=自定义条件><span class=hanchor arialabel=Anchor># </span>自定义条件</h2></a><p><img src=https://obsidian.codeplayer.org//../../assets/image_1667474870864_0.png width=auto alt=image.png></p><a href=#认证与未认证身份><h2 id=认证与未认证身份><span class=hanchor arialabel=Anchor># </span>认证与未认证身份</h2></a><p><img src=https://obsidian.codeplayer.org//../../assets/image_1667474896234_0.png width=auto alt=image.png></p><a href=#在普通-tcp协议上使用-istio-授权><h2 id=在普通-tcp协议上使用-istio-授权><span class=hanchor arialabel=Anchor># </span>在普通 TCP协议上使用 Istio 授权</h2></a><p>如果您授权策略中对TCP工作负载使用了任何只适用于HTTP 的字段，Istio 将会忽略它们。</p><p><img src=https://obsidian.codeplayer.org//../../assets/image_1667474928562_0.png width=auto alt=image.png></p></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li>No backlinks found</li></ul></div><div><script async src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://obsidian.codeplayer.org/js/graph.6579af7b10c818dbd2ca038702db0224.js></script></div></div><div id=contact_buttons><footer><p>Made by Patrick Zhao using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, © 2023</p><ul><li><a href=https://obsidian.codeplayer.org/>Home</a></li><li><a href=https://github.com/PetrusZ>GitHub</a></li><li><a href=https://t.me/Petrus_Z>Telegram</a></li><li><a href=mailto:silencly07@gmail.com>Email</a></li></ul></footer></div><hr><script src=https://giscus.app/client.js data-repo=PetrusZ/ObsidianPublish data-repo-id=R_kgDOJTGL0A data-category=Announcements data-category-id=DIC_kwDOJTGL0M4CVohQ data-mapping=title data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=preferred_color_scheme data-lang=zh-CN crossorigin=anonymous async></script></div></body></html>