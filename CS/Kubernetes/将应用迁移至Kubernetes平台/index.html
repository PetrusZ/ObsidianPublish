<!doctype html><html lang=en><head><script async defer data-website-id=de560d7e-374a-4694-943f-f3f01b8dba46 src=https://umami.codeplayer.org:1443/umami.js></script>
<script>function _howxm(){_howxmQueue.push(arguments)}window._howxmQueue=window._howxmQueue||[],_howxm("setAppID","21c1239b-b2d0-45c5-8eab-246d8b16a9d6"),function(){if(t="howxm_script",!document.getElementById(t)){var t,e=document.createElement("script"),n=document.getElementsByTagName("script")[0];e.setAttribute("id",t),e.type="text/javascript",e.async=!0,e.src="https://static.howxm.com/sdk.js",n.parentNode.insertBefore(e,n)}}()</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-PCXDEM5E1Q"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-PCXDEM5E1Q",{anonymize_ip:!1})}</script><meta charset=utf-8><meta name=description content="应用接入最佳实践 应用容器化 目标 稳定性、可用性、性能、安全
从多维度思考高可用的问题
 应用容器化的思考  容器额外开销和风险  Log driver  Blocking mode Non blocking mode   共用 kernel 所以  系统参数配置共享 进程数共享-Fork bomb fd 数共享 主机磁盘共享    容器化应用的资源监控 容器中看到的资源是主机资源"><meta property="og:title" content="将应用迁移至Kubernetes平台"><meta property="og:description" content="应用接入最佳实践 应用容器化 目标 稳定性、可用性、性能、安全
从多维度思考高可用的问题
 应用容器化的思考  容器额外开销和风险  Log driver  Blocking mode Non blocking mode   共用 kernel 所以  系统参数配置共享 进程数共享-Fork bomb fd 数共享 主机磁盘共享    容器化应用的资源监控 容器中看到的资源是主机资源"><meta property="og:type" content="website"><meta property="og:image" content="https://obsidian.codeplayer.org/icon.png"><meta property="og:url" content="https://obsidian.codeplayer.org/CS/Kubernetes/%E5%B0%86%E5%BA%94%E7%94%A8%E8%BF%81%E7%A7%BB%E8%87%B3Kubernetes%E5%B9%B3%E5%8F%B0/"><meta property="og:width" content="200"><meta property="og:height" content="200"><meta name=twitter:card content="summary"><meta name=twitter:title content="将应用迁移至Kubernetes平台"><meta name=twitter:description content="应用接入最佳实践 应用容器化 目标 稳定性、可用性、性能、安全
从多维度思考高可用的问题
 应用容器化的思考  容器额外开销和风险  Log driver  Blocking mode Non blocking mode   共用 kernel 所以  系统参数配置共享 进程数共享-Fork bomb fd 数共享 主机磁盘共享    容器化应用的资源监控 容器中看到的资源是主机资源"><meta name=twitter:image content="https://obsidian.codeplayer.org/icon.png"><title>将应用迁移至Kubernetes平台</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://obsidian.codeplayer.org//icon.png><link href=https://obsidian.codeplayer.org/styles.80333fa2099c0bee674efa435fde378c.min.css rel=stylesheet><link href=https://obsidian.codeplayer.org/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://obsidian.codeplayer.org/js/darkmode.245a0a31da505f6b327aec1fcae860c8.min.js></script>
<script src=https://obsidian.codeplayer.org/js/util.00639692264b21bc3ee219733d38a8be.min.js></script>
<link rel=preload href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css as=style onload='this.onload=null,this.rel="stylesheet"' integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/core@1.2.1></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/dom@1.2.1></script>
<script async src=https://obsidian.codeplayer.org/js/popover.aa9bc99c7c38d3ae9538f218f1416adb.min.js></script>
<script defer src=https://obsidian.codeplayer.org/js/code-title.ce4a43f09239a9efb48fee342e8ef2df.min.js></script>
<script defer src=https://obsidian.codeplayer.org/js/clipboard.2913da76d3cb21c5deaa4bae7da38c9f.min.js></script>
<script defer src=https://obsidian.codeplayer.org/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const SEARCH_ENABLED=!1,LATEX_ENABLED=!0,PRODUCTION=!0,BASE_URL="https://obsidian.codeplayer.org/",fetchData=Promise.all([fetch("https://obsidian.codeplayer.org/indices/linkIndex.468a09df9d716b174f70e573b5e9f060.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://obsidian.codeplayer.org/indices/contentIndex.093af3c5aa85039cbca649ac42b67eef.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://obsidian.codeplayer.org",!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!1;drawGraph("https://obsidian.codeplayer.org",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}var i=document.getElementsByClassName("mermaid");i.length>0&&import("https://unpkg.com/mermaid@9/dist/mermaid.esm.min.mjs").then(e=>{e.default.init()});function a(n){const e=n.target,t=e.className.split(" "),s=t.includes("broken"),o=t.includes("internal-link");plausible("Link Click",{props:{href:e.href,broken:s,internal:o,graph:!1}})}const r=document.querySelectorAll("a");for(link of r)link.className.includes("root-title")&&link.addEventListener("click",a,{once:!0})},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'’':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/obsidian.codeplayer.org\/js\/router.d6fe6bd821db9ea97f9aeefae814d8e7.min.js"
    attachSPARouting(init, render)
  </script><script defer data-domain=obsidian.codeplayer.org src=https://plausible.io/js/script.js></script>
<script>window.plausible=window.plausible||function(){(window.plausible.q=window.plausible.q||[]).push(arguments)}</script></head><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://obsidian.codeplayer.org/js/full-text-search.e6e2e0c213187ca0c703d6e2c7a77fcd.min.js></script><div class=singlePage><header><h1 id=page-title><a class=root-title href=https://obsidian.codeplayer.org/>Avalon Obsidian Vault</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>将应用迁移至Kubernetes平台</h1><p class=meta>Last updated
Apr 9, 2023
<a href=https://github.com/PetrusZ/avalon-obsidian-vault/tree/main/CS/Kubernetes/%e5%b0%86%e5%ba%94%e7%94%a8%e8%bf%81%e7%a7%bb%e8%87%b3Kubernetes%e5%b9%b3%e5%8f%b0.md rel=noopener>Edit Source</a></p><ul class=tags><li><a href=https://obsidian.codeplayer.org/tags/CS/Kubernetes/>Cs kubernetes</a></li></ul><aside class=mainTOC><details open><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#应用接入最佳实践>应用接入最佳实践</a><ol><li><a href=#应用容器化>应用容器化</a><ol><li><a href=#目标>目标</a></li><li><a href=#应用容器化的思考>应用容器化的思考</a></li><li><a href=#容器额外开销和风险>容器额外开销和风险</a></li><li><a href=#容器化应用的资源监控>容器化应用的资源监控</a></li><li><a href=#内存开销>内存开销</a></li><li><a href=#cpu>CPU</a></li><li><a href=#其他方案>其他方案</a></li></ol></li><li><a href=#将应用迁移至kubernetes>将应用迁移至Kubernetes</a><ol><li><a href=#pod-spec>Pod spec</a></li><li><a href=#probe-误用会造成严重后果>Probe 误用会造成严重后果</a></li><li><a href=#如何防止-pid泄露>如何防止 PID泄露</a></li><li><a href=#在-kubernetes-上部署应用的挑战>在 Kubernetes 上部署应用的挑战</a></li><li><a href=#pod-的数据管理>Pod 的数据管理</a></li><li><a href=#我的数据应该保存在哪里>我的数据应该保存在哪里</a></li><li><a href=#应用配置>应用配置</a></li><li><a href=#高可用部署>高可用部署</a></li><li><a href=#如何应对基础架构的影响>如何应对基础架构的影响</a></li><li><a href=#poddisruptionbudget>PodDisruptionBudget</a></li><li><a href=#基础架构与应用团队的约束>基础架构与应用团队的约束</a></li><li><a href=#部署方式>部署方式</a></li><li><a href=#服务发布>服务发布</a></li><li><a href=#服务发布的挑战>服务发布的挑战</a></li><li><a href=#无状态应用管理>无状态应用管理</a></li><li><a href=#有状态应用管理>有状态应用管理</a></li><li><a href=#有状态应用-operator>有状态应用-Operator</a></li><li><a href=#如何使用crd>如何使用CRD</a></li><li><a href=#基于crd的开发过程>基于CRD的开发过程</a></li><li><a href=#控制器模式>控制器模式</a></li></ol></li><li><a href=#有状态应用的复杂性讨论>有状态应用的复杂性讨论</a><ol><li><a href=#有状态应用部署示例-mysql>有状态应用部署示例-mysqL</a></li><li><a href=#启动顺序>启动顺序</a></li><li><a href=#健康检查>健康检查</a></li><li><a href=#数据备份>数据备份</a></li><li><a href=#版本发布和故障转移>版本发布和故障转移</a></li></ol></li></ol></li><li><a href=#spec管理神器-helm>Spec管理神器-Helm</a><ol><li><a href=#什么是helm>什么是Helm</a></li><li><a href=#helm-的组件>Helm 的组件</a></li></ol></li><li><a href=#metrics-server>metrics-server</a><ol><li><a href=#aggregated-apiserver>Aggregated APIServer</a></li><li><a href=#metrics-server-1>Metrics-Server</a></li></ol></li><li><a href=#自动扩容缩容-hpa>自动扩容缩容-HPA</a><ol><li><a href=#横向伸缩和纵向伸缩>横向伸缩和纵向伸缩</a></li><li><a href=#理解云原生的弹性能力>理解云原生的弹性能力</a></li><li><a href=#hpa>HPA</a></li><li><a href=#hpa-spec>HPA Spec</a></li><li><a href=#hpa-支持的指标类型>HPA 支持的指标类型</a></li><li><a href=#hpa指标>HPA指标</a></li><li><a href=#算法细节>算法细节</a></li><li><a href=#滚动升级时扩缩>滚动升级时扩缩</a></li><li><a href=#冷却延迟支持>冷却/延迟支持</a></li><li><a href=#扩缩策略>扩缩策略</a></li><li><a href=#hpa-存在的问题>HPA 存在的问题</a></li></ol></li><li><a href=#自动扩容缩容-vpa>自动扩容缩容-VPA</a><ol><li><a href=#vpa>VPA</a></li><li><a href=#vpa架构图>VPA架构图</a></li><li><a href=#vpa组件>VPA组件</a></li><li><a href=#vpa-工作原理>VPA 工作原理</a></li><li><a href=#recommender-设计理念>Recommender 设计理念</a></li><li><a href=#主要流程>主要流程</a></li><li><a href=#滑动窗口与半衰指数直方图>滑动窗口与半衰指数直方图</a></li><li><a href=#直方图统一对外提供的接口>直方图统一对外提供的接口</a></li><li><a href=#半衰期和权重系数>半衰期和权重系数</a></li><li><a href=#vpa-1>VPA</a></li></ol></li></ol></nav></details></aside><a href=#应用接入最佳实践><h1 id=应用接入最佳实践><span class=hanchor arialabel=Anchor># </span>应用接入最佳实践</h1></a><a href=#应用容器化><h2 id=应用容器化><span class=hanchor arialabel=Anchor># </span>应用容器化</h2></a><a href=#目标><h3 id=目标><span class=hanchor arialabel=Anchor># </span>目标</h3></a><p><strong>稳定性、可用性、性能、安全</strong></p><p>从多维度思考高可用的问题</p><p><img src=https://obsidian.codeplayer.org//Assets/image_1667144371254_0.png width=auto alt=image.png></p><a href=#应用容器化的思考><h3 id=应用容器化的思考><span class=hanchor arialabel=Anchor># </span>应用容器化的思考</h3></a><p><img src=https://obsidian.codeplayer.org//Assets/image_1667144500777_0.png width=auto alt=image.png></p><a href=#容器额外开销和风险><h3 id=容器额外开销和风险><span class=hanchor arialabel=Anchor># </span>容器额外开销和风险</h3></a><ul><li><strong>Log driver</strong><ul><li>Blocking mode</li><li>Non blocking mode</li></ul></li><li><strong>共用 kernel 所以</strong><ul><li>系统参数配置共享</li><li>进程数共享-Fork bomb</li><li>fd 数共享</li><li>主机磁盘共享</li></ul></li></ul><a href=#容器化应用的资源监控><h3 id=容器化应用的资源监控><span class=hanchor arialabel=Anchor># </span>容器化应用的资源监控</h3></a><p><strong>容器中看到的资源是主机资源</strong></p><ul><li>Top</li><li>Java runtime.GetAvailableProcesses()</li><li>cat /proc/cpuinfo</li><li>cat /proC/meminfo</li><li>df -k</li></ul><p><strong>解决方案</strong></p><ul><li>查询/proc/1/cgroup 是否包含kubepods关键字（docker关键字不可靠）。<ul><li>11:cpu,cpuacct:/kubepods.slice/kubepods-besteffort.slice/kubepods-besteffort-pod521722c3_85a8_11e9_87fc_3cfdfe57c998.slice/9568cc0d8ae182395e1ce172e2cac723c4781a999e89e0f9f10d33af079a56e9</li></ul></li><li>包含此关键字，则表明是运行在Kubernetes 之上。</li></ul><a href=#内存开销><h3 id=内存开销><span class=hanchor arialabel=Anchor># </span>内存开销</h3></a><p><strong>配额</strong></p><ul><li>cat /sys/fs/cgroup/memory/memory.limit_in_bytes<ul><li>36854771712</li></ul></li></ul><p><strong>用量</strong></p><ul><li>cat /sys/fs/cgroup/memory/memory.usage_in_bytes<ul><li>448450560</li></ul></li></ul><a href=#cpu><h3 id=cpu><span class=hanchor arialabel=Anchor># </span>CPU</h3></a><p><strong>配额，分配的 CPU个数=quota/ period，quota=-1代表 besteffort</strong></p><ul><li>cat /sys/fs/cgroup/cpu/cpu.cfs_quota_us<ul><li>-1</li></ul></li><li>cat /sys/fs/cgroup/cpu/cpu.cfs_period_us<ul><li>100000</li></ul></li></ul><p><strong>用量</strong></p><ul><li>cat /sys/fs/cgroup/cpuacct/cpuacct.usage_percpu（按CPU区分）<ul><li>140669504971 148500278385149957919463 152786448674</li></ul></li><li>cat /sys/fs/cgroup/cpuacct/cpuacct.usage<ul><li>12081100465458</li></ul></li></ul><a href=#其他方案><h3 id=其他方案><span class=hanchor arialabel=Anchor># </span>其他方案</h3></a><ul><li>xcfs<ul><li>通过 so 挂载的方式，使容器获得正确的资源信息</li></ul></li><li>Kata<ul><li>VM中跑container</li></ul></li><li>Virtlet<ul><li>直接启动 VM</li></ul></li></ul><a href=#将应用迁移至kubernetes><h2 id=将应用迁移至kubernetes><span class=hanchor arialabel=Anchor># </span>将应用迁移至Kubernetes</h2></a><a href=#pod-spec><h3 id=pod-spec><span class=hanchor arialabel=Anchor># </span>Pod spec</h3></a><ul><li>初始化需求（init container）</li><li><strong>需要几个主 container</strong></li><li>权限? Privilege 和 SecurityContext（PSP）</li><li><strong>共享哪些Namespace（PID，IPC，NET，UTS，MNT）</strong></li><li>配置管理</li><li>优雅终止</li><li>健康检查<ul><li>Liveness Probe</li><li>Readiness Probe</li></ul></li><li>DNS策略以及对 resolv.conf 的影响</li><li>imagePullPolicy Image 拉取策略</li></ul><a href=#probe-误用会造成严重后果><h3 id=probe-误用会造成严重后果><span class=hanchor arialabel=Anchor># </span>Probe 误用会造成严重后果</h3></a><p><img src=https://obsidian.codeplayer.org//Assets/image_1667146432259_0.png width=auto alt=image.png></p><a href=#如何防止-pid泄露><h3 id=如何防止-pid泄露><span class=hanchor arialabel=Anchor># </span>如何防止 PID泄露</h3></a><ul><li>单进程容器</li><li><strong>合理的处理多进程容器</strong><ul><li>容器的初始化进程必须负责清理 fork 出来的所有子进程</li><li>开源方案<ul><li>Tini
<a href=https://github.com/krallin/tini rel=noopener>https://github.com/krallin/tini</a></li><li>采用Tini作为容器的初始化进程（PID=1），容器中僵尸进程的父进程会被置为1</li></ul></li></ul></li><li><strong>如果不采用特殊初始化进程</strong><ul><li>建议采用HTTPCheck作为Probe</li><li>为exec Probe 设置合理的超时时间</li></ul></li></ul><p><img src=https://obsidian.codeplayer.org//Assets/image_1667146638863_0.png width=auto alt=image.png></p><a href=#在-kubernetes-上部署应用的挑战><h3 id=在-kubernetes-上部署应用的挑战><span class=hanchor arialabel=Anchor># </span>在 Kubernetes 上部署应用的挑战</h3></a><p><strong>资源规划</strong></p><ul><li>每个实例需要多少计算资源<ul><li>CPU/GPU?</li><li>Memory</li></ul></li><li>超售需求</li><li>每个实例需要多少存储资源<ul><li>大小</li><li>本地还是网盘</li><li>读写性能</li><li>DiskIO</li></ul></li><li>网络需求<ul><li>整个应用总体 QPS和带宽</li></ul></li></ul><a href=#pod-的数据管理><h3 id=pod-的数据管理><span class=hanchor arialabel=Anchor># </span>Pod 的数据管理</h3></a><p>local-ssd∶独占的本地磁盘，独占IO，固定大小，读写性能高。</p><p>Local-dynamic∶基于LVM，动态分配空间，效率低。</p><p><img src=https://obsidian.codeplayer.org//Assets/image_1667146864819_0.png width=auto alt=image.png></p><a href=#我的数据应该保存在哪里><h3 id=我的数据应该保存在哪里><span class=hanchor arialabel=Anchor># </span>我的数据应该保存在哪里</h3></a><p><img src=https://obsidian.codeplayer.org//Assets/image_1667147111012_0.png width=auto alt=image.png></p><a href=#应用配置><h3 id=应用配置><span class=hanchor arialabel=Anchor># </span>应用配置</h3></a><p><strong>传入方式</strong></p><ul><li>Environment Variables</li><li>Volume Mount</li></ul><p><strong>数据来源</strong></p><ul><li>Configmap</li><li>Secret</li><li>Downward API</li></ul><a href=#高可用部署><h3 id=高可用部署><span class=hanchor arialabel=Anchor># </span>高可用部署</h3></a><ul><li>需要多少实例?</li><li>如何控制失败域，部署在几个地区，AZ，集群?</li><li>如何进行精细的流量控制?</li><li>如何做按地域的顺序更新?</li><li>如何回滚?</li></ul><a href=#如何应对基础架构的影响><h3 id=如何应对基础架构的影响><span class=hanchor arialabel=Anchor># </span>如何应对基础架构的影响</h3></a><p><img src=https://obsidian.codeplayer.org//Assets/image_1667147403099_0.png width=auto alt=image.png></p><a href=#poddisruptionbudget><h3 id=poddisruptionbudget><span class=hanchor arialabel=Anchor># </span>PodDisruptionBudget</h3></a><p>PDB是为了自主中断时保障应用的高可用。</p><p>在使用 PDB 时，你需要弄清楚你的应用类型以及你想要的应对措施：</p><p><strong>无状态应用：</strong></p><ul><li>目标：至少有60%副本 Available。</li><li>方案：创建 PDB Object，指定 minAvailable为60%或者maxUnavailable为40%</li></ul><p><strong>单实例的有状态应用∶</strong></p><ul><li>目标：终止这个实例之前必须提前通知客户并取得同意。</li><li>方案：创建 PDB Object，并设置 maxUnavailable为0。</li></ul><p><strong>多实例的有状态应用：</strong></p><ul><li>目标最少可用的实例数不能少于某个数N，例如 etcd。</li><li>方案：设置 maxUnavailable=1或者minAvailable=N，分别允许每次只删除一个实例和每次删除 expected replicas-minAvailable个实例。</li></ul><a href=#基础架构与应用团队的约束><h3 id=基础架构与应用团队的约束><span class=hanchor arialabel=Anchor># </span>基础架构与应用团队的约束</h3></a><p><strong>基础架构团队</strong>在移除一个节点时，应遵循如下流程</p><p>将node置为不可调度</p><p><code>kubectl cordon &lt;node name></code></p><p>执行node drain排空节点，将其上运行的</p><p><code>Pod平滑迁移至其他节点kubectl drain &lt;node name></code></p><p><strong>应用开发人员</strong>针对敏感应用，可定义PDB来确保应用不会被意外中断</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>policy/v1betal</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>PodDisruptionBudget</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>zk-pdb</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>minAvailable</span><span class=p>:</span><span class=w> </span><span class=m>2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>selector</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>matchLabels</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>zookeeper</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><a href=#部署方式><h3 id=部署方式><span class=hanchor arialabel=Anchor># </span>部署方式</h3></a><ul><li>多少实例</li><li>更新策略<ul><li>MaxSurge</li><li>MaxUnavailable（需要考虑ResourceQuota 的限制）</li></ul></li><li>深入理解 PodTemplateHash 导致的应用的易变性</li></ul><a href=#服务发布><h3 id=服务发布><span class=hanchor arialabel=Anchor># </span>服务发布</h3></a><ul><li>需要把服务发布至集群内部或者外部，服务的不同类型：<ul><li>ClusterIP(Headless)</li><li>NodePort</li><li>LoadBalancer</li><li>ExternalName</li></ul></li><li>证书管理和七层负载均衡的需求</li><li>需要 gRPC负载均衡如何做?</li><li>DNS 需求</li><li>与上下游服务的关系</li></ul><a href=#服务发布的挑战><h3 id=服务发布的挑战><span class=hanchor arialabel=Anchor># </span>服务发布的挑战</h3></a><ul><li><strong>kube-dns</strong><ul><li>DNS TTL 问题</li></ul></li><li><strong>Service</strong><ul><li>ClusterIP 只能对内</li><li>Kube-proxy 支持的 iptables/ipvs规模有限</li><li>IPVS的性能和生产化问题</li><li>kube-proxy 的 drift 问题</li><li>频繁的 Pod变动（specchange，failover，crashLoop）导致LB频繁变更</li><li>对外发布的 Service需要与企业 ELB即成</li><li>不支持gRPC</li><li>不支持自定义 DNS和高级路由功能</li></ul></li><li><strong>Ingress</strong><ul><li>Spec要 deprecate</li></ul></li><li><strong>其他可选方案?</strong></li></ul><a href=#无状态应用管理><h3 id=无状态应用管理><span class=hanchor arialabel=Anchor># </span>无状态应用管理</h3></a><ul><li>Replicaset副本集<ul><li>用什么Pod模版创建多少个实例。</li><li>replicas: 2</li></ul></li><li>Deployment<ul><li>描述的是部署过程</li></ul></li></ul><p>版本管理</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>annotations</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>deployment.kubernetes.io/revision</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;1&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>revisionHistoryLimit</span><span class=p>:</span><span class=w> </span><span class=m>10</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>滚动升级策略</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>strategy</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>rollingUpdate</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  	</span><span class=nt>maxSurge</span><span class=p>:</span><span class=w> </span><span class=m>25</span><span class=l>%</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>maxUnavailable</span><span class=p>:</span><span class=w> </span><span class=m>1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>RollingUpdate</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><a href=#有状态应用管理><h3 id=有状态应用管理><span class=hanchor arialabel=Anchor># </span>有状态应用管理</h3></a><p><strong>Statefulset</strong></p><p>与 deployment相比，多了</p><p><code>serviceName: nginx-ss</code></p><p><strong>Volume claim template</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>volumeClaimTemplates</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>creationTimestamp</span><span class=p>:</span><span class=w> </span><span class=kc>null</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>www</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>accessModes</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=l>ReadWriteOnce</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>resources</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>requests</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>storage</span><span class=p>:</span><span class=w> </span><span class=l>1Gi</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>volumeMode</span><span class=p>:</span><span class=w> </span><span class=l>Filesystem</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><a href=#有状态应用-operator><h3 id=有状态应用-operator><span class=hanchor arialabel=Anchor># </span>有状态应用-Operator</h3></a><p><strong>创建 Operator 的关键是CRD（自定义资源）的设计。</strong></p><p>Kubernetes 对象是可扩展的，扩展的方式有</p><ul><li><strong>基于原生对象</strong><ul><li>生成 types 对象，并通过client-go生成相应的clientset， lister， informer。</li><li>实现对象的registerybackend，即定义对象任何存储进etcd。</li><li>注册对象的scheme至apiserver。</li><li>创建该对象的 apiservice 生命，注册该对象所对应的api handler。</li><li><strong>基于原生对象往往需要通过 aggregation apiserver 把不同对象组合起来。</strong></li></ul></li><li><strong>基于CRD</strong><ul><li>在不同应用业务环境下，对于平台可能有一些特殊的需求，这些需求可以抽象为Kubernetes的扩展资源，而Kubernetes的CRD（CustomResourceDefinition）为这样的需求提供了轻量级的机制，保证新的资源的快速注册和使用。</li><li>在更老的版本中，TPR（ThirdPartyResource）是与CRD类似的概念，但是在1.9以上的版本中被弃用，而CRD则进入的beta状态。</li></ul></li></ul><a href=#如何使用crd><h3 id=如何使用crd><span class=hanchor arialabel=Anchor># </span>如何使用CRD</h3></a><p>用户向Kubernetes API服务注册一个带特定 schema 的资源，并定义相关 API</p><ul><li>注册一系列该资源的实例</li><li>在 Kubernetes 的其它资源对象中引用这个新注册资源的对象实例</li><li>用户自定义的controller例程需要对这个引用进行释义和实施，让新的资源对象达到预期的状态</li></ul><a href=#基于crd的开发过程><h3 id=基于crd的开发过程><span class=hanchor arialabel=Anchor># </span>基于CRD的开发过程</h3></a><p><strong>借助Kubernetes RBAC和 authentication机制来保证该扩展资源的 security、access control、authentication 和 multitenancy。</strong></p><p>将扩展资源的数据存储到Kubernetes 的 etcd 集群。</p><p>借助Kubernetes提供的controller模式开发框架，实现新的 controller，并借助 APIServer 监听etcd 集群关于该资源的状态并定义状态变化的处理逻辑。</p><p>该功能可以让开发人员扩展添加新功能，更新现有的功能，并且可以自动执行一些管理任务，这些自定义的控制器就像Kubernetes原生的组件一样，Operator 直接使用Kubernetes API进行开发，也就是说<strong>他们可以根据这些控制器内部编写的自定义规则来监控集群、更改 Pods/Services、对正在运行的应用进行扩缩容。</strong></p><a href=#控制器模式><h3 id=控制器模式><span class=hanchor arialabel=Anchor># </span>控制器模式</h3></a><p><img src=https://obsidian.codeplayer.org//Assets/image_1667153037444_0.png width=auto alt=image.png></p><a href=#有状态应用的复杂性讨论><h2 id=有状态应用的复杂性讨论><span class=hanchor arialabel=Anchor># </span>有状态应用的复杂性讨论</h2></a><a href=#有状态应用部署示例-mysql><h3 id=有状态应用部署示例-mysql><span class=hanchor arialabel=Anchor># </span>有状态应用部署示例-mysqL</h3></a><p><strong>1. 高可用部署</strong></p><ul><li>构建 Galara cluster，提供多活高可用 mysql集群</li><li>多实例跨集群/跨机架/跨主机</li></ul><p><strong>2. 持久化存储</strong></p><ul><li>需要为每个Pod 创建 PVC并 mount</li><li>读写性能保证</li><li>local dynamic作为数据盘，cephfs 作为备份盘</li></ul><p><strong>3. 有状态应用的复杂配置</strong></p><ul><li>与无状态应用不一样，mysql 需要复杂配置以完成 galara集群的构建/etc/mysql/conf.d/galera.c</li></ul><a href=#启动顺序><h3 id=启动顺序><span class=hanchor arialabel=Anchor># </span>启动顺序</h3></a><ul><li><strong>在PrimaryComponent节点上运行</strong><ul><li>mysqld_bootstrap</li></ul></li><li><strong>在其他节点上运行</strong><ul><li>systemctl start mysql</li></ul></li><li><strong>发生了什么</strong><ul><li>当节点第一次启动时，会自动生成UUID以代表当前节点身份</li><li>启动后，garala会在数据目录生成gvwstate.dat文件，该文件内容记录Primary Component 的UUID以及连接到当前Primary Component的节点的UUID</li><li>如果Primary Component出现故障，则剩余节点会重新选择新的Primary Component</li><li>若该文件已经存在，则无需额外执行bootstrap命令启动PrimaryCompont，可依此规则编写Operator在多个节点构建此文件</li></ul></li></ul><a href=#健康检查><h3 id=健康检查><span class=hanchor arialabel=Anchor># </span>健康检查</h3></a><ul><li><strong>mysql 提供健康检查 API</strong><ul><li>检查集群成员是否能接受查询请求<ul><li>SHOW GLOBAL STATUS LIKE &lsquo;wsrep_ready&rsquo;;</li></ul></li><li>检查节点是否与其他节点网络互通<ul><li>SHOW GLOBAL STATUS LIKE &lsquo;wsrep connected&rsquo;;</li></ul></li><li>检查节点自场次查询结束后接收到的查询请求数量，如果结果为非0，意味着写请求不能立即处理<ul><li>SHOW STATUS LIKE &lsquo;wsrep_local_recv_queue_avg&rsquo;;</li></ul></li></ul></li><li><strong>健康检查应该影响 Pod 的readiness probe，在进行版本升级时，确保大多数集群节点状态一致。</strong></li></ul><a href=#数据备份><h3 id=数据备份><span class=hanchor arialabel=Anchor># </span>数据备份</h3></a><ul><li><strong>推荐为 mysql 创建不同类型的 volume</strong><ul><li>Local volume 用来做数据盘</li><li>Network volume 用来做数据备份</li></ul></li><li><strong>创建 cronjob，每天将数据备份至backup目录</strong><ul><li>备份文件为</li></ul></li><li><strong>一键恢复能力</strong><ul><li>导入备份目录的 sql file</li></ul></li></ul><a href=#版本发布和故障转移><h3 id=版本发布和故障转移><span class=hanchor arialabel=Anchor># </span>版本发布和故障转移</h3></a><p>针对配置了Local disk的 Pod，<strong>当发生因版本变更而引发的Pod 重建时</strong>，新Pod在进行调度时，调度器会查询 Pod 挂载的volume 所在节点，并将新 Pod 优先调度至该节点，此场景不涉及到数据恢复。</p><p>其开销与 mysql进程重启相差不大。</p><hr><p><strong>如果节点出现故障，如硬件故障，Kubernetes 的Evict Manager 会将该Pod从故障节点驱逐，Operator 应确保新 Pod 会被重新构建。</strong> 而新 Pod会被调度至新节点，此场景等价于替换mysql中的少数节点。</p><p>galara 集群中的少数 mysql节点替换，不涉及到数据迁移，galara 会确保新节点的数据同步</p><p><strong>若整个mysql 集群需要做数据恢复，则应该从backup 目录对应的网络 volume恢复数据。</strong> 此时</p><ul><li>可选择：<ul><li>只恢复单一节点数据：配置简单</li><li>恢复所有节点数据：恢复速度快</li></ul></li><li>与基础架构的Contract<ul><li>PodDisruptionBudget</li></ul></li></ul><a href=#spec管理神器-helm><h1 id=spec管理神器-helm><span class=hanchor arialabel=Anchor># </span>Spec管理神器-Helm</h1></a><a href=#什么是helm><h2 id=什么是helm><span class=hanchor arialabel=Anchor># </span>什么是Helm</h2></a><p><strong>Helm 特性</strong></p><ul><li>Helm chart是创建一个应用实例的必要的配置组，也就是一堆 Spec。</li><li>配置信息被归类为模版（Template）和值（Value），这些信息经过渲染生成最终的对象。</li><li>所有配置可以被打包进一个可以发布的对象中。</li><li>一个release 就是一个有特定配置的chart 的实例。</li></ul><a href=#helm-的组件><h2 id=helm-的组件><span class=hanchor arialabel=Anchor># </span>Helm 的组件</h2></a><p><strong>Helm client</strong></p><ul><li>本地chart开发</li><li>管理 repository</li><li>管理 release</li><li>与helm library交互</li><li>发送需要安装的chart</li><li>请求升级或着卸载存在的 release</li></ul><p><strong>Helm library</strong></p><ul><li>负责与 APIserver交互，并提供以下功能<ul><li>基于chart和 configuration 创建一个release</li><li>把 chart安装进kubernetes，并提供相应的 release 对象</li><li>升级和卸载</li><li>Helm 采用Kubernetes存储所有配置信息，无需自己的数据库</li></ul></li></ul><a href=#metrics-server><h1 id=metrics-server><span class=hanchor arialabel=Anchor># </span>metrics-server</h1></a><a href=#aggregated-apiserver><h2 id=aggregated-apiserver><span class=hanchor arialabel=Anchor># </span>Aggregated APIServer</h2></a><p><img src=https://obsidian.codeplayer.org//Assets/image_1667209374158_0.png width=auto alt=image.png></p><a href=#metrics-server-1><h2 id=metrics-server-1><span class=hanchor arialabel=Anchor># </span>Metrics-Server</h2></a><p><strong>metrics-server 是Kubernetes 监控体系中的核心组件之一</strong>，它负责从kubelet 收集资源指标，然后对这些指标监控数据进行聚合（依赖kube-aggregator），并在Kubernetes Apiserver中通过 MetricS API/apis/metrics.k8s.io/）公开暴露它们，但是 <strong>metrics-server只存储最新的指标数据（CPU/Memory）</strong>。</p><p>你的 kube-apiserver要能访问到metrics-server;</p><p>需要kube-apiserver启用聚合层;</p><p>组件要有认证配置并且绑定到 metrics-server;</p><p>Pod / Node 指标需要由 Summary API通过 kubelet公开。</p><p><img src=https://obsidian.codeplayer.org//Assets/image_1667212041763_0.png width=auto alt=image.png></p><a href=#自动扩容缩容-hpa><h1 id=自动扩容缩容-hpa><span class=hanchor arialabel=Anchor># </span>自动扩容缩容-HPA</h1></a><a href=#横向伸缩和纵向伸缩><h2 id=横向伸缩和纵向伸缩><span class=hanchor arialabel=Anchor># </span>横向伸缩和纵向伸缩</h2></a><ul><li><strong>应用扩容是指在应用接收到的并发请求已经处于其处理请求极限边界的情形下，扩展处理能力而确保应用高可用的技术手段</strong></li><li>Horizontal Scaling<ul><li>所谓横向伸缩是指通过增加应用实例数量分担负载的方式来提升应用整体处理能力的方式</li></ul></li><li>Vertical Scaling<ul><li>所谓纵向伸缩是指通过增加单个应用实例资源以提升单个实例处理能力，进而提升应用整体处理能力的方式</li></ul></li></ul><p><img src=https://obsidian.codeplayer.org//Assets/image_1667212325432_0.png width=auto alt=image.png></p><a href=#理解云原生的弹性能力><h2 id=理解云原生的弹性能力><span class=hanchor arialabel=Anchor># </span>理解云原生的弹性能力</h2></a><p><img src=https://obsidian.codeplayer.org//Assets/image_1667212517047_0.png width=auto alt=image.png></p><a href=#hpa><h2 id=hpa><span class=hanchor arialabel=Anchor># </span>HPA</h2></a><p><strong>HPA（Horizontal Pod Autoscaler）是Kubernetes 的一种资源对象</strong>，能够根据某些指标对在 statefulSet、replicaSet、deployment 等集合中的 Pod 数量进行横向动态伸缩，使运行在上面的服务对指标的变化有一定的自适应能力。</p><p>因节点计算资源固定，当 Pod 调度完成并运行以后，动态调整计算资源变得较为困难，因为横向扩展具有更大优势，HPA是扩展应用能力的第一选择。规则。</p><p>HPA依赖于Metrics-Server。</p><a href=#hpa-spec><h2 id=hpa-spec><span class=hanchor arialabel=Anchor># </span>HPA Spec</h2></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>autoscaling/v2beta2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>HorizontalPodAutoscaler</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>mynginx</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c>#HPA的伸缩对象描述，HPA会动态修改该对象的Pod数量</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>scaleTargetRef</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>apps/v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Deployment</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>mynginx</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c># HPA 的最小 Pod 数量和最大 Pod数量</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>minReplicas</span><span class=p>:</span><span class=w> </span><span class=m>1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>maxReplicas</span><span class=p>:</span><span class=w> </span><span class=m>3</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c>#监控的指标数组，支持多种类型的指标共存</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metric</span><span class=p>:</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><a href=#hpa-支持的指标类型><h2 id=hpa-支持的指标类型><span class=hanchor arialabel=Anchor># </span>HPA 支持的指标类型</h2></a><p>对于按 Pod统计的资源指标（如 CPU），控制器从资源指标 API中获取每一个<strong>HorizontalPodAutoscaler指定的 Pod 的度量值</strong>，如果设置了目标使用率，控制器获取每个Pod 中的容器资源使用情况，并计算资源使用率。 如果设置了target 值，将直接使用原始数据（不再计算百分比）。</p><p>如果 Pod使用自定义指示，控制器机制与资源指标类似，区别在于自定义指标只使用原始值，而不是使用率。</p><p>如果 Pod使用对象指标和外部指标（每个指标描述一个对象信息）。 这个指标将直接根据目标设定值相比较，并生成一个上面提到的扩缩比例。<strong>在 autoscaling/v2beta2版本 API中，这个指标也可以根据 Pod数量平分后再计算。</strong></p><a href=#hpa指标><h2 id=hpa指标><span class=hanchor arialabel=Anchor># </span>HPA指标</h2></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=c>#Resource类型的指标</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- <span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>Resource</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>resource</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>cpu</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c>#Utilization类型的目标值，Resource类型的指标只支持Utilization和AverageValue类型的目标值</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>target</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>Utilization</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>averageUtilization</span><span class=p>:</span><span class=w> </span><span class=m>50</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c>#Pods类型的指标</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- <span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>Pods</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>pods</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>metric</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>packets-per-second</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=c>#AverageValue类型的目标值，Pods指标类型下只支持AverageValue类型的目标值</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>target</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>AverageValue</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>averageValue</span><span class=p>:</span><span class=w> </span><span class=l>1k</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><a href=#算法细节><h2 id=算法细节><span class=hanchor arialabel=Anchor># </span>算法细节</h2></a><p>HPA算法非常简单</p><p><em><em>期望副本数=ceil[当前副本数</em>(当前指标/期望指标)]</em>*</p><p>当前度量值为 200m，目标设定值为100m，那么由于200.0/100.0 <mark>2.0，副本数量将会翻倍。如果当前指标为50m，副本数量将会洞半，因为 50.0/100.0</mark> 0.5。如果计算出的扩缩上例接近 1.0（根据&ndash;horizontal-pod-autoscaler-tolerance参数全局配置的容忍值，默认为 0.1），将会放弃本次扩缩。</p><a href=#滚动升级时扩缩><h2 id=滚动升级时扩缩><span class=hanchor arialabel=Anchor># </span>滚动升级时扩缩</h2></a><ul><li>当你为一个Deployment 配置自动扩缩时，你要为每个 Deployment 绑定一个HorizontalPodAutoscaler。</li><li>HorizontalPodAutoscaler 管理 Deployment 的 replicas字段。</li><li>Deployment Controller 负责设置下层ReplicaSet 的 replicas字段，以便确保在上线及后续过程副本个数合适。</li><li><strong>想一想：为什么 deploymentSpec中的 replicas字段的类型为*int，而不是int?</strong></li></ul><a href=#冷却延迟支持><h2 id=冷却延迟支持><span class=hanchor arialabel=Anchor># </span>冷却/延迟支持</h2></a><p>当使用Horizontal Pod AutosCaler 管理一组副本扩缩时，有可能因为指标动态的变化造成副本数量频繁的变化，有时这被称为 <strong>抖动（Thrashing）</strong>。</p><p>&ndash;horizontal-pod-autoscaler-downscale-stabilization∶设置缩容冷却时间窗口长度。水平 Pod扩缩器能够记住过去建议的负载规模，并仅对此时间窗口内的最大规模执行操作。<strong>默认值是5分钟（5m0s）。</strong></p><a href=#扩缩策略><h2 id=扩缩策略><span class=hanchor arialabel=Anchor># </span>扩缩策略</h2></a><p>在 Spec字段的 behavior 部分可以指定一个或多个扩缩策略。 当指定多个策略时，默认选择允许更改最多的策略。下面的例子展示了缩容时的行为：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>behavior</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>scaleDOown</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>policies</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>Pods</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>value</span><span class=p>:</span><span class=w> </span><span class=m>4</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>periodSeconds</span><span class=p>:</span><span class=w> </span><span class=m>60</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>Percent</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>value</span><span class=p>:</span><span class=w> </span><span class=m>10</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>periodSeconds</span><span class=p>:</span><span class=w> </span><span class=m>60</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><a href=#hpa-存在的问题><h2 id=hpa-存在的问题><span class=hanchor arialabel=Anchor># </span>HPA 存在的问题</h2></a><ul><li>基于指标的弹性有滞后效应，因为弹性控制器操作的链路过长。</li><li>从应用负载超出阈值到HPA完成扩容之间的时间差包括∶<ul><li>应用指标数据已经超出阈值；</li><li>HPA定期执行指标收集滞后效应；</li><li>HPA控制 Deployment 进行扩容的时间；</li><li>Pod调度，运行时启动挂载存储和网络的时间；</li><li>应用启动到服务就绪的时间。</li></ul></li><li><strong>很可能在突发流量出现时，还没完成弹性扩容，既有的服务实例已经被流量击垮。</strong></li></ul><a href=#自动扩容缩容-vpa><h1 id=自动扩容缩容-vpa><span class=hanchor arialabel=Anchor># </span>自动扩容缩容-VPA</h1></a><a href=#vpa><h2 id=vpa><span class=hanchor arialabel=Anchor># </span>VPA</h2></a><p><strong>VPA全称Vertical Pod Autoscaler，即垂直 Pod 自动扩缩容</strong>，它根据容器资源使用率自动设置CPU 和 内存的 requests，从而允许在节点上进行适当的调度，以便为每个 Pod提供适当的资源。它既可以缩小过度请求资源的容器，也可以根据其使用情况随时提升资源不足的容量。</p><p>使用VPA 的意义：</p><ul><li>Pod 资源用其所需，提升集群节点使用效率；</li><li>不必运行基准测试任务来确定CPU 和内存请求的合适值；</li><li>VPA 可以随时调整CPU和内存请求，无需人为操作，因此可以减少维护时间。</li></ul><p><strong>注意：VPA 目前还没有生产就绪，在使用之前需要了解资源调节对应用的影响。</strong></p><a href=#vpa架构图><h2 id=vpa架构图><span class=hanchor arialabel=Anchor># </span>VPA架构图</h2></a><p><img src=https://obsidian.codeplayer.org//Assets/image_1667218774861_0.png width=auto alt=image.png></p><a href=#vpa组件><h2 id=vpa组件><span class=hanchor arialabel=Anchor># </span>VPA组件</h2></a><p>VPA 引入了一种新型的 API资源：<strong>VerticalPodAutoscaler</strong>。</p><p><strong>VPA Recommender</strong>监视所有 Pod，不断为它们计算新的推荐资源，并将推荐值存储在VPA对象中。它使用来自Metrics-Server 的集群中所有 Pod 的利用率和 OOM事件。</p><p>所有 Pod 创建请求都通过 <strong>VPA Admission Controller</strong>。</p><p><strong>VPAUpdater</strong> 是负责 Pod 实时更新的组件。如果 Pod在"Auto"模式下使用VPA，则Updater 可以决定使用推荐器资源对其进行更新。</p><p><strong>History Storage</strong>是一个存储组件（如Prometheus），它使用来自 API Server 的利用率信息和 OOM（与推荐器相同的数据）并将其持久存储。</p><p>VPA 更新模式：</p><ul><li>Off</li><li>Auto</li></ul><a href=#vpa-工作原理><h2 id=vpa-工作原理><span class=hanchor arialabel=Anchor># </span>VPA 工作原理</h2></a><p><img src=https://obsidian.codeplayer.org//Assets/image_1667218863362_0.png width=auto alt=image.png></p><a href=#recommender-设计理念><h2 id=recommender-设计理念><span class=hanchor arialabel=Anchor># </span>Recommender 设计理念</h2></a><p><strong>推荐模型（MVP）假设内存和 CPU利用率是独立的随机变量，其分布等于过夫 N 天观察到的变量（推荐值为N=8以捕获每周峰值）。</strong></p><p>对于 CPU，目标是将容器使用率超过请求的高百分比（例如 95%）的时间部分保持存某个阈值（例如1%的时间）以下。在此模型中，<strong>&ldquo;CPU使用率&rdquo;</strong> 被定义为在短时间间隔内测量的平均使用率。测量间隔越短，针对尖峰、延迟敏感的工作负载的建议质量就越高。<strong>最小合理分辨率为1/min，推荐为1/sec。</strong></p><p>对于<strong>内存</strong>，目标是将特定时间窗口内容器使用率超过请求的概率保持在某个阈值以下（例如，<strong>24小时内低于1%</strong>）。<strong>窗口必须很长（≥24 小时）</strong> 以确保由OOM 引起的驱逐不会明显影响（a）服务应用程序的可用性（b）批处理计算的进度（更高级的模型可以允许用户指定 SLO来控制它）。</p><a href=#主要流程><h2 id=主要流程><span class=hanchor arialabel=Anchor># </span>主要流程</h2></a><p><img src=https://obsidian.codeplayer.org//Assets/image_1667219529173_0.png width=auto alt=image.png></p><a href=#滑动窗口与半衰指数直方图><h2 id=滑动窗口与半衰指数直方图><span class=hanchor arialabel=Anchor># </span>滑动窗口与半衰指数直方图</h2></a><p>Recommender的资源推荐算法主要受Google AutoPilot moving window 推荐器的启发，<strong>假设CPU和Memory消耗是独立的随机变量，其分布等于过去N天观察到的变量分布（推荐值为N=8以捕获每周业务容器峰值）。</strong></p><p>Recommender组件获取资源消耗实时数据，存到相应资源对象CheckPoint中。CheckPoint CRD 资源本质上是一个直方图。</p><p><img src=https://obsidian.codeplayer.org//Assets/image_1667219600773_0.png width=auto alt=image.png></p><a href=#直方图统一对外提供的接口><h2 id=直方图统一对外提供的接口><span class=hanchor arialabel=Anchor># </span>直方图统一对外提供的接口</h2></a><p><img src=https://obsidian.codeplayer.org//Assets/image_1667219640780_0.png width=auto alt=image.png></p><a href=#半衰期和权重系数><h2 id=半衰期和权重系数><span class=hanchor arialabel=Anchor># </span>半衰期和权重系数</h2></a><p>为每个样本数据权重乘上<strong>指数2^（（sampleTime-referenceTimestamp）/ halfLife）</strong>，以保证较新的样本被赋予更高的权重，而较老的样本随时间推移权重逐步衰减。</p><p>默认情况下，<strong>每24h 为一个半衰期</strong>，即每经过 24h，直方图中所有样本的权重（重要性）衰减为原来的一半。</p><p><strong>当指数过大时，referenceTimestamp 就需要向前调整，以避免浮点乘法计算时向上溢出。</strong></p><ul><li>CPU使用量样本对应的权重是基于容器 CPU request值确定的。当 CPUrequest 增加时，对应的权重也随之增加。</li><li>而Memory 使用量样本对应的权重固定为1.0。</li></ul><a href=#vpa-1><h2 id=vpa-1><span class=hanchor arialabel=Anchor># </span>VPA</h2></a><p><strong>VPA 的成熟度还不足</strong></p><p>更新正在运行的 Pod 资源配置是VPA的一项试验性功能，会导致 Pod 的重建和重启，而且有可能被调度到其他的节点上。</p><p>VPA不会驱逐没有在副本控制器管理下的 Pod。<strong>目前对于这类 Pod，Auto 模式等同于Initial 模式。</strong></p><p>目前VPA不能和监控CPU和内存度量的 **Horizontal Pod Autoscaler（HPA）**同时运行，除非 HPA 只监控其他定制化的或者外部的资源度量。</p><p>VPA使用 admission webhook 作为其准入控制器。如果集群中有其他的 admission webhook，需要确保它们不会与VPA发生冲突。准入控制器的执行顺序定义在 APIServer的配置参数中。</p><p>VPA会处理出现的绝大多数 <strong>OOM（Out Of Memory）</strong> 的事件，但不保证所有的场景下都有效。</p><p>VPA的性能还没有在大型集群中测试过。</p><p>VPA 对 Pod 资源 requests 的修改值可能超过实际的资源上限，例如节点资源上限、空闲资源或资源配额，从而造成， Pod 处于 Pending状态无法被调度。同时使用集群自动伸缩（ClusterAutoScaler）可以一定程度上解决这个问题。</p><p>多个VPA同时匹配同一个 Pod 会造成未定义的行为。</p></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li>No backlinks found</li></ul></div><div><script async src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://obsidian.codeplayer.org/js/graph.6579af7b10c818dbd2ca038702db0224.js></script></div></div><div id=contact_buttons><footer><p>Made by Patrick Zhao using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, © 2023</p><ul><li><a href=https://obsidian.codeplayer.org/>Home</a></li><li><a href=https://github.com/PetrusZ>GitHub</a></li><li><a href=https://t.me/Petrus_Z>Telegram</a></li><li><a href=mailto:silencly07@gmail.com>Email</a></li></ul></footer></div><hr><script src=https://giscus.app/client.js data-repo=PetrusZ/ObsidianPublish data-repo-id=R_kgDOJTGL0A data-category=Announcements data-category-id=DIC_kwDOJTGL0M4CVohQ data-mapping=title data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=preferred_color_scheme data-lang=zh-CN crossorigin=anonymous async></script></div></body></html>