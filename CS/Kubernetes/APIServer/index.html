<!doctype html><html lang=en><head><script async defer data-website-id=de560d7e-374a-4694-943f-f3f01b8dba46 src=https://umami.codeplayer.org:1443/umami.js></script>
<script>function _howxm(){_howxmQueue.push(arguments)}window._howxmQueue=window._howxmQueue||[],_howxm("setAppID","21c1239b-b2d0-45c5-8eab-246d8b16a9d6"),function(){if(t="howxm_script",!document.getElementById(t)){var t,e=document.createElement("script"),n=document.getElementsByTagName("script")[0];e.setAttribute("id",t),e.type="text/javascript",e.async=!0,e.src="https://static.howxm.com/sdk.js",n.parentNode.insertBefore(e,n)}}()</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-PCXDEM5E1Q"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-PCXDEM5E1Q",{anonymize_ip:!1})}</script><meta charset=utf-8><meta name=description content="API Server kube-apiserver是Kubernetes最重要的核心组件之一，主要提供以下的功能
提供集群管理的REST API接口，包括认证授权、数据校验以及集群状态变更等
提供其他模块之间的数据交互和通信的枢纽（其他模块通过API Server查询或修改数据，只有API Server才直接操作etcd）
访问控制概览 Kubernetes API的每个请求都会经过多阶段的访问控制之后才会被接受，这包括认证、授权以及准入控制（Admission Control）等。
 访问控制细节  认证 开启TLS时，所有的请求都需要首先认证。Kubernetes支持多种认证机制，并支持同时开启多个认证插件（只要有一个认证通过即可）。如果认证成功，则用户的username会传入授权模块做进一步授权验证；而对于认证失败的请求则返回HTTP 401。
认证插件  X509证书  使用X509客户端证书只需要API Server启动时配置&ndash;client-ca-file=SOMEFILE。在证书认证时，其CN域用作用户名，而组织机构域则用作group名。   静态Token文件  使用静态Token文件认证只需要API Server启动时配置&ndash;token-auth-file=SOMEFILE。 该文件为csv格式，每行至少包括三列token,username,user id，  token,user,uid,&#34;group1,group2,group3”     引导Token  为了支持平滑地启动引导新的集群，Kubernetes 包含了一种动态管理的持有者令牌类型， 称作 启动引导令牌（BootstrapToken）。 这些令牌以 Secret 的形式保存在 kube-system 名字空间中，可以被动态管理和创建。 控制器管理器包含的 TokenCleaner 控制器能够在启动引导令牌过期时将其删除。 在使用kubeadm部署Kubernetes时，可通过kubeadm token list命令查询。   静态密码文件  需要API Server启动时配置&ndash;basic-auth-file=SOMEFILE，文件格式为csv，每行至少三列password, user, uid，后面是可选的group名  password,user,uid,&#34;group1,group2,group3”     ServiceAccount  ServiceAccount是Kubernetes自动生成的，并会自动挂载到容器的/run/secrets/kubernetes."><meta property="og:title" content="APIServer"><meta property="og:description" content="API Server kube-apiserver是Kubernetes最重要的核心组件之一，主要提供以下的功能
提供集群管理的REST API接口，包括认证授权、数据校验以及集群状态变更等
提供其他模块之间的数据交互和通信的枢纽（其他模块通过API Server查询或修改数据，只有API Server才直接操作etcd）
访问控制概览 Kubernetes API的每个请求都会经过多阶段的访问控制之后才会被接受，这包括认证、授权以及准入控制（Admission Control）等。
 访问控制细节  认证 开启TLS时，所有的请求都需要首先认证。Kubernetes支持多种认证机制，并支持同时开启多个认证插件（只要有一个认证通过即可）。如果认证成功，则用户的username会传入授权模块做进一步授权验证；而对于认证失败的请求则返回HTTP 401。
认证插件  X509证书  使用X509客户端证书只需要API Server启动时配置&ndash;client-ca-file=SOMEFILE。在证书认证时，其CN域用作用户名，而组织机构域则用作group名。   静态Token文件  使用静态Token文件认证只需要API Server启动时配置&ndash;token-auth-file=SOMEFILE。 该文件为csv格式，每行至少包括三列token,username,user id，  token,user,uid,&#34;group1,group2,group3”     引导Token  为了支持平滑地启动引导新的集群，Kubernetes 包含了一种动态管理的持有者令牌类型， 称作 启动引导令牌（BootstrapToken）。 这些令牌以 Secret 的形式保存在 kube-system 名字空间中，可以被动态管理和创建。 控制器管理器包含的 TokenCleaner 控制器能够在启动引导令牌过期时将其删除。 在使用kubeadm部署Kubernetes时，可通过kubeadm token list命令查询。   静态密码文件  需要API Server启动时配置&ndash;basic-auth-file=SOMEFILE，文件格式为csv，每行至少三列password, user, uid，后面是可选的group名  password,user,uid,&#34;group1,group2,group3”     ServiceAccount  ServiceAccount是Kubernetes自动生成的，并会自动挂载到容器的/run/secrets/kubernetes."><meta property="og:type" content="website"><meta property="og:image" content="https://obsidian.codeplayer.org/icon.png"><meta property="og:url" content="https://obsidian.codeplayer.org/CS/Kubernetes/APIServer/"><meta property="og:width" content="200"><meta property="og:height" content="200"><meta name=twitter:card content="summary"><meta name=twitter:title content="APIServer"><meta name=twitter:description content="API Server kube-apiserver是Kubernetes最重要的核心组件之一，主要提供以下的功能
提供集群管理的REST API接口，包括认证授权、数据校验以及集群状态变更等
提供其他模块之间的数据交互和通信的枢纽（其他模块通过API Server查询或修改数据，只有API Server才直接操作etcd）
访问控制概览 Kubernetes API的每个请求都会经过多阶段的访问控制之后才会被接受，这包括认证、授权以及准入控制（Admission Control）等。
 访问控制细节  认证 开启TLS时，所有的请求都需要首先认证。Kubernetes支持多种认证机制，并支持同时开启多个认证插件（只要有一个认证通过即可）。如果认证成功，则用户的username会传入授权模块做进一步授权验证；而对于认证失败的请求则返回HTTP 401。
认证插件  X509证书  使用X509客户端证书只需要API Server启动时配置&ndash;client-ca-file=SOMEFILE。在证书认证时，其CN域用作用户名，而组织机构域则用作group名。   静态Token文件  使用静态Token文件认证只需要API Server启动时配置&ndash;token-auth-file=SOMEFILE。 该文件为csv格式，每行至少包括三列token,username,user id，  token,user,uid,&#34;group1,group2,group3”     引导Token  为了支持平滑地启动引导新的集群，Kubernetes 包含了一种动态管理的持有者令牌类型， 称作 启动引导令牌（BootstrapToken）。 这些令牌以 Secret 的形式保存在 kube-system 名字空间中，可以被动态管理和创建。 控制器管理器包含的 TokenCleaner 控制器能够在启动引导令牌过期时将其删除。 在使用kubeadm部署Kubernetes时，可通过kubeadm token list命令查询。   静态密码文件  需要API Server启动时配置&ndash;basic-auth-file=SOMEFILE，文件格式为csv，每行至少三列password, user, uid，后面是可选的group名  password,user,uid,&#34;group1,group2,group3”     ServiceAccount  ServiceAccount是Kubernetes自动生成的，并会自动挂载到容器的/run/secrets/kubernetes."><meta name=twitter:image content="https://obsidian.codeplayer.org/icon.png"><title>APIServer</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://obsidian.codeplayer.org//icon.png><link href=https://obsidian.codeplayer.org/styles.80333fa2099c0bee674efa435fde378c.min.css rel=stylesheet><link href=https://obsidian.codeplayer.org/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://obsidian.codeplayer.org/js/darkmode.245a0a31da505f6b327aec1fcae860c8.min.js></script>
<script src=https://obsidian.codeplayer.org/js/util.00639692264b21bc3ee219733d38a8be.min.js></script>
<link rel=preload href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css as=style onload='this.onload=null,this.rel="stylesheet"' integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/core@1.2.1></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/dom@1.2.1></script>
<script async src=https://obsidian.codeplayer.org/js/popover.aa9bc99c7c38d3ae9538f218f1416adb.min.js></script>
<script defer src=https://obsidian.codeplayer.org/js/code-title.ce4a43f09239a9efb48fee342e8ef2df.min.js></script>
<script defer src=https://obsidian.codeplayer.org/js/clipboard.2913da76d3cb21c5deaa4bae7da38c9f.min.js></script>
<script defer src=https://obsidian.codeplayer.org/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const SEARCH_ENABLED=!1,LATEX_ENABLED=!0,PRODUCTION=!0,BASE_URL="https://obsidian.codeplayer.org/",fetchData=Promise.all([fetch("https://obsidian.codeplayer.org/indices/linkIndex.c4c4c4c7a7ef56e411497c00ff176ea1.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://obsidian.codeplayer.org/indices/contentIndex.440c61b9edcf4aaeef5377c46e8799ee.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://obsidian.codeplayer.org",!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!1;drawGraph("https://obsidian.codeplayer.org",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}var i=document.getElementsByClassName("mermaid");i.length>0&&import("https://unpkg.com/mermaid@9/dist/mermaid.esm.min.mjs").then(e=>{e.default.init()});function a(n){const e=n.target,t=e.className.split(" "),s=t.includes("broken"),o=t.includes("internal-link");plausible("Link Click",{props:{href:e.href,broken:s,internal:o,graph:!1}})}const r=document.querySelectorAll("a");for(link of r)link.className.includes("root-title")&&link.addEventListener("click",a,{once:!0})},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'’':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/obsidian.codeplayer.org\/js\/router.d6fe6bd821db9ea97f9aeefae814d8e7.min.js"
    attachSPARouting(init, render)
  </script><script defer data-domain=obsidian.codeplayer.org src=https://plausible.io/js/script.js></script>
<script>window.plausible=window.plausible||function(){(window.plausible.q=window.plausible.q||[]).push(arguments)}</script></head><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://obsidian.codeplayer.org/js/full-text-search.e6e2e0c213187ca0c703d6e2c7a77fcd.min.js></script><div class=singlePage><header><h1 id=page-title><a class=root-title href=https://obsidian.codeplayer.org/>Avalon Obsidian Vault</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>APIServer</h1><p class=meta>Last updated
Apr 9, 2023
<a href=https://github.com/PetrusZ/avalon-obsidian-vault/tree/main/CS/Kubernetes/APIServer.md rel=noopener>Edit Source</a></p><ul class=tags><li><a href=https://obsidian.codeplayer.org/tags/CS/Kubernetes/>Cs kubernetes</a></li></ul><aside class=mainTOC><details open><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#api-server>API Server</a><ol><li><a href=#访问控制概览>访问控制概览</a></li><li><a href=#访问控制细节>访问控制细节</a></li></ol></li><li><a href=#认证>认证</a><ol><li><a href=#认证插件>认证插件</a></li><li><a href=#基于webhook的认证服务集成>基于webhook的认证服务集成</a><ol><li><a href=#构建符合kubernetes规范的认证服务>构建符合Kubernetes规范的认证服务</a></li><li><a href=#开发认证服务>开发认证服务</a></li><li><a href=#配置apiserver>配置apiserver</a></li></ol></li></ol></li><li><a href=#鉴权>鉴权</a><ol><li><a href=#授权>授权</a></li><li><a href=#rbac-vs-abac>RBAC vs ABAC</a></li><li><a href=#rbac老图>RBAC老图</a></li><li><a href=#rbac新解>RBAC新解</a></li><li><a href=#role与clusterrole>Role与ClusterRole</a></li><li><a href=#binding>binding</a></li><li><a href=#账户组的管理>账户／组的管理</a></li><li><a href=#规划系统角色>规划系统角色</a></li><li><a href=#实现方案>实现方案</a></li><li><a href=#与权限相关的其他最佳实践>与权限相关的其他最佳实践</a></li></ol></li><li><a href=#准入>准入</a><ol><li><a href=#准入控制>准入控制</a></li><li><a href=#准入控制插件>准入控制插件</a></li><li><a href=#准入控制插件的开发>准入控制插件的开发</a></li></ol></li><li><a href=#限流>限流</a><ol><li><a href=#计数器固定窗口算法>计数器固定窗口算法</a></li><li><a href=#计数器滑动窗口算法>计数器滑动窗口算法</a></li><li><a href=#漏斗算法>漏斗算法</a></li><li><a href=#令牌桶算法>令牌桶算法</a></li><li><a href=#传统限流方法的局限性>传统限流方法的局限性</a></li><li><a href=#apiserver中的限流>APIServer中的限流</a></li><li><a href=#api-priority-and-fairness>API Priority and Fairness</a><ol><li><a href=#概念>概念</a></li><li><a href=#优先级>优先级</a></li><li><a href=#排队>排队</a></li><li><a href=#豁免请求>豁免请求</a></li><li><a href=#默认配置>默认配置</a></li><li><a href=#prioritylevelconfiguration>PriorityLevelConfiguration</a></li><li><a href=#flowschema>FlowSchema</a></li><li><a href=#调试>调试</a></li></ol></li></ol></li><li><a href=#apiserver对象的实现>APIServer对象的实现</a><ol><li><a href=#构建高可用的多副本apiserver>构建高可用的多副本apiserver</a></li><li><a href=#预留充足的cpu内存资源>预留充足的CPU、内存资源</a></li><li><a href=#善用速率限制ratelimit>善用速率限制（RateLimit）</a></li><li><a href=#设置合适的缓存大小>设置合适的缓存大小</a></li><li><a href=#客户端尽量使用长连接>客户端尽量使用长连接</a></li><li><a href=#搭建多租户的kubernetes集群>搭建多租户的Kubernetes集群</a></li></ol></li></ol></nav></details></aside><a href=#api-server><h1 id=api-server><span class=hanchor arialabel=Anchor># </span>API Server</h1></a><p>kube-apiserver是Kubernetes最重要的核心组件之一，主要提供以下的功能</p><p>提供集群管理的REST API接口，包括认证授权、数据校验以及集群状态变更等</p><p>提供其他模块之间的数据交互和通信的枢纽（其他模块通过API Server查询或修改数据，只有API Server才直接操作etcd）</p><a href=#访问控制概览><h2 id=访问控制概览><span class=hanchor arialabel=Anchor># </span>访问控制概览</h2></a><p>Kubernetes API的每个请求都会经过多阶段的访问控制之后才会被接受，这包括认证、授权以及准入控制（Admission Control）等。</p><p><img src=https://obsidian.codeplayer.org//../../assets/image_1665936179908_0.png width=auto alt=image.png></p><a href=#访问控制细节><h2 id=访问控制细节><span class=hanchor arialabel=Anchor># </span>访问控制细节</h2></a><p><img src=https://obsidian.codeplayer.org//../../assets/image_1665936203999_0.png width=auto alt=image.png></p><a href=#认证><h1 id=认证><span class=hanchor arialabel=Anchor># </span>认证</h1></a><p>开启TLS时，所有的请求都需要首先认证。Kubernetes支持多种认证机制，并支持同时开启多个认证插件（只要有一个认证通过即可）。如果认证成功，则用户的username会传入授权模块做进一步授权验证；而对于认证失败的请求则返回HTTP 401。</p><a href=#认证插件><h2 id=认证插件><span class=hanchor arialabel=Anchor># </span>认证插件</h2></a><ul><li>X509证书<ul><li>使用X509客户端证书只需要API Server启动时配置&ndash;client-ca-file=SOMEFILE。在证书认证时，其CN域用作用户名，而组织机构域则用作group名。</li></ul></li><li>静态Token文件<ul><li>使用静态Token文件认证只需要API Server启动时配置&ndash;token-auth-file=SOMEFILE。</li><li>该文件为csv格式，每行至少包括三列token,username,user id，<ul><li><code>token,user,uid,"group1,group2,group3”</code></li></ul></li></ul></li><li>引导Token<ul><li>为了支持平滑地启动引导新的集群，Kubernetes 包含了一种动态管理的持有者令牌类型， 称作 启动引导令牌（BootstrapToken）。</li><li>这些令牌以 Secret 的形式保存在 kube-system 名字空间中，可以被动态管理和创建。</li><li>控制器管理器包含的 TokenCleaner 控制器能够在启动引导令牌过期时将其删除。</li><li>在使用kubeadm部署Kubernetes时，可通过kubeadm token list命令查询。</li></ul></li><li>静态密码文件<ul><li>需要API Server启动时配置&ndash;basic-auth-file=SOMEFILE，文件格式为csv，每行至少三列password, user, uid，后面是可选的group名<ul><li><code>password,user,uid,"group1,group2,group3”</code></li></ul></li></ul></li><li>ServiceAccount<ul><li>ServiceAccount是Kubernetes自动生成的，并会自动挂载到容器的/run/secrets/kubernetes.io/serviceaccount目录中。</li></ul></li><li>OpenID<ul><li>OAuth 2.0的认证机制</li></ul></li><li>Webhook 令牌身份认证<ul><li>&ndash;authentication-token-webhook-config-file 指向一个配置文件，其中描述 如何访问远程的 Webhook 服务。</li><li>&ndash;authentication-token-webhook-cache-ttl 用来设定身份认证决定的缓存时间。 默认时长为 2 分钟。</li></ul></li><li>匿名请求<ul><li>如果使用AlwaysAllow以外的认证模式，则匿名请求默认开启，但可用&ndash;anonymous-auth=false禁止匿名请求。</li></ul></li></ul><a href=#基于webhook的认证服务集成><h2 id=基于webhook的认证服务集成><span class=hanchor arialabel=Anchor># </span>基于webhook的认证服务集成</h2></a><a href=#构建符合kubernetes规范的认证服务><h3 id=构建符合kubernetes规范的认证服务><span class=hanchor arialabel=Anchor># </span>构建符合Kubernetes规范的认证服务</h3></a><p>需要依照Kubernetes规范，构建认证服务，用来认证tokenreview request构建认证服务</p><ul><li>认证服务需要满足如下Kubernetes的规范</li><li>URL：
<a href=https://authn.example.com/authenticate rel=noopener>https://authn.example.com/authenticate</a></li><li>Method： POST</li><li>Input:</li><li>Output:</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=line><span class=cl><span class=p>{</span> <span class=nt>&#34;apiVersion&#34;</span><span class=p>:</span> <span class=s2>&#34;authentication.k8s.io/v1beta1&#34;</span><span class=p>,</span> <span class=nt>&#34;kind&#34;</span><span class=p>:</span> <span class=s2>&#34;TokenReview&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=nt>&#34;spec&#34;</span><span class=p>:</span> <span class=p>{</span> <span class=nt>&#34;token&#34;</span><span class=p>:</span> <span class=s2>&#34;(BEARERTOKEN)&#34;</span> <span class=p>}</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;apiVersion&#34;</span><span class=p>:</span> <span class=s2>&#34;authentication.k8s.io/v1beta1&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;kind&#34;</span><span class=p>:</span> <span class=s2>&#34;TokenReview&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>   <span class=nt>&#34;status&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;authenticated&#34;</span><span class=p>:</span> <span class=kc>true</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;user&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nt>&#34;username&#34;</span><span class=p>:</span> <span class=s2>&#34;janedoe@example.com&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nt>&#34;uid&#34;</span><span class=p>:</span> <span class=s2>&#34;42&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nt>&#34;groups&#34;</span><span class=p>:</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;developers&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;qa&#34;</span>
</span></span><span class=line><span class=cl>      <span class=p>]}}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><a href=#开发认证服务><h3 id=开发认证服务><span class=hanchor arialabel=Anchor># </span>开发认证服务</h3></a><p>解码认证请求</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>decoder</span> <span class=o>:=</span> <span class=nx>json</span><span class=p>.</span><span class=nf>NewDecoder</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nx>Body</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>tr</span> <span class=nx>authentication</span><span class=p>.</span><span class=nx>TokenReview</span>
</span></span><span class=line><span class=cl><span class=nx>err</span> <span class=o>:=</span> <span class=nx>decoder</span><span class=p>.</span><span class=nf>Decode</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>tr</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>log</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;[Error]&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>.</span><span class=nf>Error</span><span class=p>())</span>
</span></span><span class=line><span class=cl>	<span class=nx>w</span><span class=p>.</span><span class=nf>WriteHeader</span><span class=p>(</span><span class=nx>http</span><span class=p>.</span><span class=nx>StatusBadRequest</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>json</span><span class=p>.</span><span class=nf>NewEncoder</span><span class=p>(</span><span class=nx>w</span><span class=p>).</span><span class=nf>Encode</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kd>interface</span><span class=p>{}{</span>
</span></span><span class=line><span class=cl>		<span class=s>&#34;apiVersion&#34;</span><span class=p>:</span> <span class=s>&#34;authentication.k8s.io/v1beta1&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=s>&#34;kind&#34;</span><span class=p>:</span> <span class=s>&#34;TokenReview&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=s>&#34;status&#34;</span><span class=p>:</span> <span class=nx>authentication</span><span class=p>.</span><span class=nx>TokenReviewStatus</span><span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>Authenticated</span><span class=p>:</span> <span class=kc>false</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=p>},</span>
</span></span><span class=line><span class=cl>	<span class=p>})</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>转发认证请求至认证服务器</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Check User
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>ts</span> <span class=o>:=</span> <span class=nx>oauth2</span><span class=p>.</span><span class=nf>StaticTokenSource</span><span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=o>&amp;</span><span class=nx>oauth2</span><span class=p>.</span><span class=nx>Token</span><span class=p>{</span><span class=nx>AccessToken</span><span class=p>:</span> <span class=nx>tr</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Token</span><span class=p>},</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>tc</span> <span class=o>:=</span> <span class=nx>oauth2</span><span class=p>.</span><span class=nf>NewClient</span><span class=p>(</span><span class=nx>oauth2</span><span class=p>.</span><span class=nx>NoContext</span><span class=p>,</span> <span class=nx>ts</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>client</span> <span class=o>:=</span> <span class=nx>github</span><span class=p>.</span><span class=nf>NewClient</span><span class=p>(</span><span class=nx>tc</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>user</span><span class=p>,</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>client</span><span class=p>.</span><span class=nx>Users</span><span class=p>.</span><span class=nf>Get</span><span class=p>(</span><span class=nx>context</span><span class=p>.</span><span class=nf>Background</span><span class=p>(),</span> <span class=s>&#34;&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>log</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;[Error]&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>.</span><span class=nf>Error</span><span class=p>())</span>
</span></span><span class=line><span class=cl>	<span class=nx>w</span><span class=p>.</span><span class=nf>WriteHeader</span><span class=p>(</span><span class=nx>http</span><span class=p>.</span><span class=nx>StatusUnauthorized</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>json</span><span class=p>.</span><span class=nf>NewEncoder</span><span class=p>(</span><span class=nx>w</span><span class=p>).</span><span class=nf>Encode</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kd>interface</span><span class=p>{}{</span>
</span></span><span class=line><span class=cl>		<span class=s>&#34;apiVersion&#34;</span><span class=p>:</span> <span class=s>&#34;authentication.k8s.io/v1beta1&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=s>&#34;kind&#34;</span><span class=p>:</span> <span class=s>&#34;TokenReview&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=s>&#34;status&#34;</span><span class=p>:</span> <span class=nx>authentication</span><span class=p>.</span><span class=nx>TokenReviewStatus</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>Authenticated</span><span class=p>:</span> <span class=kc>false</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=p>},</span>
</span></span><span class=line><span class=cl>	<span class=p>})</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>认证结果返回给APIServer</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>w</span><span class=p>.</span><span class=nf>WriteHeader</span><span class=p>(</span><span class=nx>http</span><span class=p>.</span><span class=nx>StatusOK</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>trs</span> <span class=o>:=</span> <span class=nx>authentication</span><span class=p>.</span><span class=nx>TokenReviewStatus</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>Authenticated</span><span class=p>:</span> <span class=kc>true</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=nx>User</span><span class=p>:</span> <span class=nx>authentication</span><span class=p>.</span><span class=nx>UserInfo</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>Username</span><span class=p>:</span> <span class=o>*</span><span class=nx>user</span><span class=p>.</span><span class=nx>Login</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=nx>UID</span><span class=p>:</span> <span class=o>*</span><span class=nx>user</span><span class=p>.</span><span class=nx>Login</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=p>},</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>json</span><span class=p>.</span><span class=nf>NewEncoder</span><span class=p>(</span><span class=nx>w</span><span class=p>).</span><span class=nf>Encode</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kd>interface</span><span class=p>{}{</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;apiVersion&#34;</span><span class=p>:</span> <span class=s>&#34;authentication.k8s.io/v1beta1&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;kind&#34;</span><span class=p>:</span> <span class=s>&#34;TokenReview&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;status&#34;</span><span class=p>:</span> <span class=nx>trs</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>})</span>
</span></span></code></pre></td></tr></table></div></div><a href=#配置apiserver><h3 id=配置apiserver><span class=hanchor arialabel=Anchor># </span>配置apiserver</h3></a><ul><li>可以是任何认证系统<ul><li>但在用户认证完成后，生成代表用户身份的token</li><li>该token通常是有失效时间的</li><li>用户获取该token以后以后，将token配置进kubeconfig</li></ul></li><li>修改apiserver设置，开启认证服务，apiserver保证将所有收到的</li><li>请求中的token信息，发给认证服务进行验证<ul><li>&ndash;authentication-token-webhook-config-file，该文件描述如何访问认证服务</li><li>&ndash;authentication-token-webhook-cache-ttl，默认2分钟</li></ul></li><li>配置文件需要mount进Pod</li><li>配置文件中的服务器地址需要指向authService</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;kind&#34;</span><span class=p>:</span> <span class=s2>&#34;Config&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;apiVersion&#34;</span><span class=p>:</span> <span class=s2>&#34;v1&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;preferences&#34;</span><span class=p>:</span> <span class=p>{},</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;clusters&#34;</span><span class=p>:</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;name&#34;</span><span class=p>:</span> <span class=s2>&#34;github-authn&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;cluster&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nt>&#34;server&#34;</span><span class=p>:</span> <span class=s2>&#34;http://localhost:3000/authenticate&#34;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;users&#34;</span><span class=p>:</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;name&#34;</span><span class=p>:</span> <span class=s2>&#34;authn-apiserver&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;user&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nt>&#34;token&#34;</span><span class=p>:</span> <span class=s2>&#34;secret&#34;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;contexts&#34;</span><span class=p>:</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;name&#34;</span><span class=p>:</span> <span class=s2>&#34;webhook&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;context&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nt>&#34;cluster&#34;</span><span class=p>:</span> <span class=s2>&#34;github-authn&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=nt>&#34;user&#34;</span><span class=p>:</span> <span class=s2>&#34;authn-apiserver&#34;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;current-context&#34;</span><span class=p>:</span> <span class=s2>&#34;webhook&#34;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><a href=#鉴权><h1 id=鉴权><span class=hanchor arialabel=Anchor># </span>鉴权</h1></a><a href=#授权><h2 id=授权><span class=hanchor arialabel=Anchor># </span>授权</h2></a><p>授权主要是用于对集群资源的访问控制，通过检查请求包含的相关属性值，与相对应的访问策略相比较，API请求必须满足某些策略才能被处理。跟认证类似，Kubernetes也支持多种授权机制，并支持同时开启多个授权插件（只要有一个验证通过即可）。如果授权成功，则用户的请求会发送到准入控制模块做进一步的请求验证；对于授权失败的请求则返回HTTP 403。</p><p>Kubernetes授权仅处理以下的请求属性：</p><ul><li>user, group, extra</li><li>API、请求方法（如get、post、update、patch和delete）和请求路径（如/api）</li><li>请求资源和子资源</li><li>Namespace</li><li>API Group</li></ul><p>目前，Kubernetes支持以下授权插件：</p><ul><li>ABAC</li><li>RBAC</li><li>Webhook</li><li>Node</li></ul><a href=#rbac-vs-abac><h2 id=rbac-vs-abac><span class=hanchor arialabel=Anchor># </span>RBAC vs ABAC</h2></a><p>ABAC（Attribute Based Access Control）本来是不错的概念，但是在 Kubernetes 中的实现比较难于管理和理解，而且需要对 Master 所在节点的 SSH 和文件系统权限，要使得对授权的变更成功生效，还需要重新启动 API Server。</p><p>而 RBAC 的授权策略可以利用 kubectl 或者 Kubernetes API 直接进行配置。RBAC 可以授权给用户，让用户有权进行授权管理，这样就可以无需接触节点，直接进行授权管理。RBAC 在 Kubernetes中被映射为 API 资源和操作。</p><a href=#rbac老图><h2 id=rbac老图><span class=hanchor arialabel=Anchor># </span>RBAC老图</h2></a><p><img src=https://obsidian.codeplayer.org//../../assets/image_1665943450461_0.png width=auto alt=image.png></p><a href=#rbac新解><h2 id=rbac新解><span class=hanchor arialabel=Anchor># </span>RBAC新解</h2></a><p><img src=https://obsidian.codeplayer.org//../../assets/image_1665943481332_0.png width=auto alt=image.png></p><a href=#role与clusterrole><h2 id=role与clusterrole><span class=hanchor arialabel=Anchor># </span>Role与ClusterRole</h2></a><p>Role（角色）是一系列权限的集合，例如一个角色可以包含读取 Pod 的权限和列出 Pod 的权限。Role只能用来给某个特定namespace中的资源作鉴权，对多namespace和集群级的资源或者是非资源类的API（如/healthz）使用ClusterRole。</p><p><img src=https://obsidian.codeplayer.org//../../assets/image_1665943682167_0.png width=auto alt=image.png></p><a href=#binding><h2 id=binding><span class=hanchor arialabel=Anchor># </span>binding</h2></a><p><img src=https://obsidian.codeplayer.org//../../assets/image_1665943725607_0.png width=auto alt=image.png></p><a href=#账户组的管理><h2 id=账户组的管理><span class=hanchor arialabel=Anchor># </span>账户／组的管理</h2></a><p>角色绑定（Role Binding）是将角色中定义的权限赋予一个或者一组用户。它包含若干 <strong>主体</strong>（用户、组或服务账户）的列表和对这些主体所获得的角色的引用。</p><p>组的概念：</p><ul><li>当与外部认证系统对接时，用户信息（UserInfo）可包含Group信息，授权可针对用户群组</li><li>当对ServiceAccount授权时，Group代表某个Namespace下的所有ServiceAccount</li></ul><p><img src=https://obsidian.codeplayer.org//../../assets/image_1665943926495_0.png width=auto alt=image.png></p><a href=#规划系统角色><h2 id=规划系统角色><span class=hanchor arialabel=Anchor># </span>规划系统角色</h2></a><ul><li>User<ul><li>管理员<ul><li>所有资源的所有权限？？（不给普通用的secret的读取权限）</li></ul></li><li>普通用户<ul><li>是否有该用户创建的namespace下的所有object的操作权限？</li><li>对其他用户的namespace资源是否可读，是否可写？</li></ul></li></ul></li><li>ServiceAccount<ul><li>ServiceAccount是开发者（kubernetes developer或者domain developer）创建应用后，应用于apiserver通讯需要的身份</li><li>用户可以创建自定的ServiceAccount，kubernetes也为每个namespace创建default ServiceAccount</li><li>Default ServiceAccount通常需要给定权限以后才能对apiserver做写操作</li></ul></li></ul><a href=#实现方案><h2 id=实现方案><span class=hanchor arialabel=Anchor># </span>实现方案</h2></a><ul><li>在cluster创建时，创建自定义的clusterRole，比如namespace-creator</li><li>Namespace-creator role定义用户可操作的对象和对应的读写操作。</li><li>创建自定义的namespace admission control webhook<ul><li>当namespace创建请求被处理时，获取当前用户信息并annotate到namespace</li></ul></li><li>创建RBAC controller<ul><li>Watch namespace的创建事件</li><li>获取当前namespace的创建者信息</li><li>在当前namespace创建rolebinding对象，并将namespace-creator 角色和用户绑定</li></ul></li></ul><a href=#与权限相关的其他最佳实践><h2 id=与权限相关的其他最佳实践><span class=hanchor arialabel=Anchor># </span>与权限相关的其他最佳实践</h2></a><ul><li>ClusterRole是非namespace绑定的，针对整个集群生效</li><li>通常需要创建一个管理员角色，并且绑定给开发运营团队成员</li><li>CustomResourceDefinition是全局资源，普通用户创建CustomResourceDefinition以后，需要管理员授予相应权限后才能真正操作该对象</li><li>针对所有的角色管理，建议创建spec，用源代码驱动<ul><li>虽然可以通过edit操作来修改权限，但后期会导致权限管理混乱，可能会有很多临时创建出来的角色和角色绑定对象，重复绑定某一个资源权限</li></ul></li><li>权限是可以传递的，用户A可以将其对某对象的某操作，抽取成一个权限，并赋给用户B</li><li>防止海量的角色和角色绑定对象，因为大量的对象会导致鉴权效率低，同时给apiserver增加负担</li><li>ServiceAccount也需要授权的，否则你的component可能无法操作某对象</li><li>Tips：SSH到master节点通过insecure port访问apiserver可绕过鉴权，当需要做管理操作又没有权限时可以使用（不推荐）</li></ul><a href=#准入><h1 id=准入><span class=hanchor arialabel=Anchor># </span>准入</h1></a><a href=#准入控制><h2 id=准入控制><span class=hanchor arialabel=Anchor># </span>准入控制</h2></a><ul><li>为资源增加自定义属性</li><li>作为多租户集群方案中的一环，我们需要在namespace的准入控制中，获取用户信息，并将用户信息更新的namespace的annotation</li><li>有当namespace中有有效用户信息时，我们才可以在namespace创建时，自动绑定用户权限，namespace才可用。</li></ul><hr><ul><li>配额管理<ul><li>原因：资源有限，如何限定某个用户有多少资源？</li></ul></li><li>方案：<ul><li>预定义每个Namespace的ResourceQuota，并把spec保存为configmap<ul><li>用户可以创建多少个Pod<ul><li>BestEffortPod</li><li>QoSPod</li></ul></li><li>用户可以创建多少个service</li><li>用户可以创建多少个ingress</li><li>用户可以创建多少个service VIP</li></ul></li><li>创建ResourceQuota Controller<ul><li>监控namespace创建事件，当namespace创建时，在该namespace创建对应的ResourceQuota 对象</li></ul></li><li>apiserver中开启ResourceQuota的admission plugin</li></ul></li></ul><hr><p>准入控制（Admission Control）在授权后对请求做进一步的验证或添加默认参数。不同于授权和认证只关心请求的用户和操作，准入控制还处理请求的内容，并且仅对创建、更新、删除或连接（如代理）等有效，而对读操作无效。</p><p>准入控制支持同时开启多个插件，它们依次调用，只有全部插件都通过的请求才可以放过进入系统。</p><a href=#准入控制插件><h2 id=准入控制插件><span class=hanchor arialabel=Anchor># </span>准入控制插件</h2></a><ul><li>AlwaysAdmit: 接受所有请求。</li><li>AlwaysPullImages: 总是拉取最新镜像。在多租户场景下非常有用。</li><li>DenyEscalatingExec: 禁止特权容器的exec和attach操作。</li><li>ImagePolicyWebhook: 通过webhook决定image策略，需要同时配置&ndash;admission-control-config-file</li><li>ServiceAccount：自动创建默认ServiceAccount，并确保Pod引用的ServiceAccount已经存在</li><li>SecurityContextDeny：拒绝包含非法SecurityContext配置的容器</li><li>ResourceQuota：限制Pod的请求不会超过配额，需要在namespace中创建一个ResourceQuota对象</li><li>LimitRanger：为Pod设置默认资源请求和限制，需要在namespace中创建一个LimitRange对象</li><li>InitialResources：根据镜像的历史使用记录，为容器设置默认资源请求和限制</li><li>NamespaceLifecycle：确保处于termination状态的namespace不再接收新的对象创建请求，并拒绝请求不存在的namespace</li><li>DefaultStorageClass：为PVC设置默认StorageClass</li><li>DefaultTolerationSeconds：设置Pod的默认forgiveness toleration为5分钟</li><li>PodSecurityPolicy：使用Pod Security Policies时必须开启</li><li>NodeRestriction：限制kubelet仅可访问node、endpoint、pod、service以及secret、configmap、PV和PVC等相关的资源</li></ul><a href=#准入控制插件的开发><h2 id=准入控制插件的开发><span class=hanchor arialabel=Anchor># </span>准入控制插件的开发</h2></a><p>除默认的准入控制插件以外，Kubernetes预留了准入控制插件的扩展点，用户可自定义准入控制插件实现自定义准入功能</p><p>MutatingWebhookConfiguration：变形插件，支持对准入对象的修改</p><p>ValidatingWebhookConfiguration：校验插件，只能对准入对象合法性进行校验，不能修改</p><p><img src=https://obsidian.codeplayer.org//../../assets/image_1665998764708_0.png width=auto alt=image.png></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=c># {{if eq .k8snode_validating &#34;enabled&#34;}}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>admissionregistration.k8s.io/v1beta1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>MutatingWebhookConfiguration</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>ns-mutating.webhook.k8s.io</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>webhooks</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- <span class=nt>clientConfig</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>caBundle</span><span class=p>:</span><span class=w> </span>{{<span class=l>.serverca_base64}}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>url</span><span class=p>:</span><span class=w> </span><span class=l>https://admission.local.tess.io/apis/admission.k8s.io/v1alpha1/ ns-mutating</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>failurePolicy</span><span class=p>:</span><span class=w> </span><span class=l>Fail</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>ns-mutating.webhook.k8s.io</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>namespaceSelector</span><span class=p>:</span><span class=w> </span>{}<span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>rules</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>apiGroups</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=s2>&#34;&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>apiVersions</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=s1>&#39;*&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>operations</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>CREATE</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>resources</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>nodes</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>sideEffects</span><span class=p>:</span><span class=w> </span><span class=l>Unknown</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c># {{end}}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><a href=#限流><h1 id=限流><span class=hanchor arialabel=Anchor># </span>限流</h1></a><a href=#计数器固定窗口算法><h2 id=计数器固定窗口算法><span class=hanchor arialabel=Anchor># </span>计数器固定窗口算法</h2></a><p>原理就是对一段固定时间窗口内的请求进行计数，如果请求数超过了阈值，则舍弃该请求；
如果没有达到设定的阈值，则接受该请求，且计数加1。</p><p>当时间窗口结束时，重置计数器为0。</p><p><img src=https://obsidian.codeplayer.org//../../assets/image_1666013649334_0.png width=auto alt=image.png></p><a href=#计数器滑动窗口算法><h2 id=计数器滑动窗口算法><span class=hanchor arialabel=Anchor># </span>计数器滑动窗口算法</h2></a><p>在固定窗口的基础上，将一个计时窗口分成了若干个小窗口，然后每个小窗口维护一个独立的计数器。</p><p>当请求的时间大于当前窗口的最大时间时，则将计时窗口向前平移一个小窗口。</p><p>平移时，将第一个小窗口的数据丢弃，然后将第二个小窗口设置为第一个小窗口，同时在最后面新增一个小窗口，将新的请求放在新增的小窗口中。</p><p>同时要保证整个窗口中所有小窗口的请求数目之后不能超过设定的阈值。</p><p><img src=https://obsidian.codeplayer.org//../../assets/image_1666013698808_0.png width=auto alt=image.png></p><a href=#漏斗算法><h2 id=漏斗算法><span class=hanchor arialabel=Anchor># </span>漏斗算法</h2></a><p>漏斗算法的原理也很容易理解。请求来了之后会首先进到漏斗里，然后漏斗以恒定的速率将请求流出进行处理，从而起到平滑流量的作用。</p><p>当请求的流量过大时，漏斗达到最大容量时会溢出，此时请求被丢弃。</p><p>在系统看来，请求永远是以平滑的传输速率过来，从而起到了保护系统的作用。</p><p><img src=https://obsidian.codeplayer.org//../../assets/image_1666013753347_0.png width=auto alt=image.png></p><a href=#令牌桶算法><h2 id=令牌桶算法><span class=hanchor arialabel=Anchor># </span>令牌桶算法</h2></a><p>令牌桶算法是对漏斗算法的一种改进，除了能够起到限流的作用外，还允许一定程度的流量突发。</p><p>在令牌桶算法中，存在一个令牌桶，算法中存在一种机制以恒定的速率向令牌桶中放入令牌。令牌桶也有一定的容量，如果满了令牌就无法放进去了。</p><p>当请求来时，会首先到令牌桶中去拿令牌，如果拿到了令牌，则该请求会被处理，并消耗掉拿到的令牌；</p><p>如果令牌桶为空，则该请求会被丢弃。</p><p><img src=https://obsidian.codeplayer.org//../../assets/image_1666013871935_0.png width=auto alt=image.png></p><a href=#传统限流方法的局限性><h2 id=传统限流方法的局限性><span class=hanchor arialabel=Anchor># </span>传统限流方法的局限性</h2></a><ul><li>粒度粗<ul><li>无法为不同用户，不同场景设置不通的限流</li></ul></li><li>单队列<ul><li>共享限流窗口/桶，一个坏用户可能会将整个系统堵塞，其他正常用户的请求无法被及时处理</li></ul></li><li>不公平<ul><li>正常用户的请求会被排到队尾，无法及时处理而饿死</li></ul></li><li>无优先级<ul><li>重要的系统指令一并被限流，系统故障难以恢复</li></ul></li></ul><a href=#apiserver中的限流><h2 id=apiserver中的限流><span class=hanchor arialabel=Anchor># </span>APIServer中的限流</h2></a><ul><li>max-requests-inflight： 在给定时间内的最大 non-mutating 请求数</li><li>max-mutating-requests-inflight： 在给定时间内的最大 mutating 请求数，调整 apiserver 的流控 qos</li><li>代码<ul><li>staging/src/k8s.io/apiserver/pkg/server/filters/maxinflight.go:WithMaxInFlightLimit()</li></ul></li></ul><p><img src=https://obsidian.codeplayer.org//../../assets/image_1666014967707_0.png width=auto alt=image.png></p><a href=#api-priority-and-fairness><h2 id=api-priority-and-fairness><span class=hanchor arialabel=Anchor># </span>API Priority and Fairness</h2></a><ul><li>APF 以更细粒度的方式对请求进行分类和隔离。</li><li>它还引入了空间有限的排队机制，因此在非常短暂的突发情况下，API 服务器不会拒绝任何请求。</li><li>通过使用公平排队技术从队列中分发请求，这样， 一个行为不佳的控制器就不会饿死其他控制器（即使优先级相同）。</li><li>APF的核心<ul><li>多等级</li><li>多队列</li></ul></li></ul><p><img src=https://obsidian.codeplayer.org//../../assets/image_1666015880281_0.png width=auto alt=image.png></p><hr><p>APF 的实现依赖两个非常重要的资源 FlowSchema, PriorityLevelConfiguration</p><p>APF 对请求进行更细粒度的分类，每一个请求分类对应一个 FlowSchema (FS)</p><p>FS 内的请求又会根据 distinguisher 进一步划分为不同的 Flow.</p><p>FS 会设置一个优先级 (Priority Level, PL)，不同优先级的并发资源是隔离的。所以不同优先级的资源不会相互排挤。特定</p><p>优先级的请求可以被高优处理。</p><p>一个 PL 可以对应多个 FS，PL 中维护了一个 QueueSet，用于缓存不能及时处理的请求，请求不会因为超出 PL 的并发限制而被丢弃。</p><p>FS 中的每个 Flow 通过 shuffle sharding 算法从 QueueSet 选取特定的 queues 缓存请求。</p><p>每次从 QueueSet 中取请求执行时，会先应用 fair queuing 算法从 QueueSet 中选中一个 queue，然后从这个 queue中取出 oldest 请求执行。所以即使是同一个 PL 内的请求，也不会出现一个 Flow 内的请求一直占用资源的不公平现象。</p><a href=#概念><h3 id=概念><span class=hanchor arialabel=Anchor># </span>概念</h3></a><p>传入的请求通过 <em>FlowSchema</em> 按照其属性分类，并分配优先级。</p><p>每个优先级维护自定义的并发限制，加强了隔离度，这样不同优先级的请求，就不会相互饿死。</p><p>在同一个优先级内，公平排队算法可以防止来自不同 <em>flow</em> 的请求相互饿死。</p><p>该算法将请求排队，通过排队机制，防止在平均负载较低时，通信量突增而导致请求失败。</p><a href=#优先级><h3 id=优先级><span class=hanchor arialabel=Anchor># </span>优先级</h3></a><p>如果未启用 APF，API 服务器中的整体并发量将受到 kube-apiserver 的参数 &ndash;maxrequests-inflight 和 &ndash;max-mutating-requests-inflight 的限制。</p><p>启用 APF 后，将对这些参数定义的并发限制进行求和，然后将总和分配到一组可配置的 <em>优先级</em> 中。 每个传入的请求都会分配一个优先级；</p><p>每个优先级都有各自的配置，设定允许分发的并发请求数。</p><p>例如，默认配置包括针对领导者选举请求、内置控制器请求和 Pod 请求都单独设置优先级。这表示即使异常的 Pod 向 API 服务器发送大量请求，也无法阻止领导者选举或内置控制器的操作执行成功。</p><a href=#排队><h3 id=排队><span class=hanchor arialabel=Anchor># </span>排队</h3></a><p>即使在同一优先级内，也可能存在大量不同的流量源。</p><p>在过载情况下，防止一个请求流饿死其他流是非常有价值的 （尤其是在一个较为常见的场景中，一个有故障的客户端会疯狂地向 kube-apiserver 发送请求， 理想情况下，这个有故障的客户端不应对其他客户端产生太大的影响）。</p><p>公平排队算法在处理具有相同优先级的请求时，实现了上述场景。</p><p>每个请求都被分配到某个 流 中，该流由对应的 FlowSchema 的名字加上一个 流区分项（FlowDistinguisher） 来标识。</p><p>这里的流区分项可以是发出请求的用户、目标资源的名称空间或什么都不是。</p><p>系统尝试为不同流中具有相同优先级的请求赋予近似相等的权重。</p><p>将请求划分到流中之后，APF 功能将请求分配到队列中。</p><p>分配时使用一种称为 混洗分片（Shuffle-Sharding） 的技术。 该技术可以相对有效地利用队列隔离低强度流与高强度流。</p><p>排队算法的细节可针对每个优先等级进行调整，并允许管理员在内存占用、 公平性（当总流量超标时，各个独立的流将都会取得进展）、 突发流量的容忍度以及排队引发的额外延迟之间进行权衡。</p><a href=#豁免请求><h3 id=豁免请求><span class=hanchor arialabel=Anchor># </span>豁免请求</h3></a><p>某些特别重要的请求不受制于此特性施加的任何限制。这些豁免可防止不当的流控配置完全禁用
API 服务器。</p><a href=#默认配置><h3 id=默认配置><span class=hanchor arialabel=Anchor># </span>默认配置</h3></a><p>system</p><p>用于 system:nodes 组（即 kubelets）的请求； kubelets 必须能连上 API 服务器，以便工作负载能够调度到其上。</p><p>leader-election</p><p>用于内置控制器的领导选举的请求 （特别是来自 kube-system 名称空间中 system:kube-controller-manager 和 system:kube-scheduler 用户和服务账号，针对 endpoints、configmaps 或 leases 的请求）。</p><p>将这些请求与其他流量相隔离非常重要，因为领导者选举失败会导致控制器发生故障并重新启动，这反过来会导致新启动的控制器在同步信息时，流量开销更大。</p><p>workload-high</p><p>优先级用于内置控制器的请求。</p><p>workload-low</p><p>优先级适用于来自任何服务帐户的请求，通常包括来自 Pods 中运行的控制器的所有请求。</p><p>global-default</p><p>优先级可处理所有其他流量，例如：非特权用户运行的交互式 kubectl 命令。</p><p>exempt</p><p>优先级的请求完全不受流控限制：它们总是立刻被分发。 特殊的 exempt FlowSchema把 system:masters 组的所有请求都归入该优先级组。</p><p>catch-all</p><p>优先级与特殊的 catch-all FlowSchema 结合使用，以确保每个请求都分类。</p><p>一般不应该依赖于 catch-all 的配置，而应适当地创建自己的 catch-all FlowSchema 和PriorityLevelConfigurations（或使用默认安装的 global-default 配置）。</p><p>为了帮助捕获部分请求未分类的配置错误，强制要求 catch-all 优先级仅允许5个并发份额，并且不对请求进行排队，使得仅与 catch-all FlowSchema 匹配的流量被拒绝的可能性更高，并显示 HTTP 429 错误。</p><a href=#prioritylevelconfiguration><h3 id=prioritylevelconfiguration><span class=hanchor arialabel=Anchor># </span>PriorityLevelConfiguration</h3></a><p>一个 PriorityLevelConfiguration 表示单个隔离类型。</p><p>每个 PriorityLevelConfigurations 对未完成的请求数有各自的限制，对排队中的请求数也有限制。</p><p><img src=https://obsidian.codeplayer.org//../../assets/image_1666017137479_0.png width=auto alt=image.png></p><a href=#flowschema><h3 id=flowschema><span class=hanchor arialabel=Anchor># </span>FlowSchema</h3></a><p>FlowSchema 匹配一些入站请求，并将它们分配给优先级。</p><p>每个入站请求都会对所有 FlowSchema 测试是否匹配， 首先从 matchingPrecedence 数值最低的匹配开始（我们认为这是逻辑上匹配度最高）， 然后依次进行，直到首个匹配出现</p><p><img src=https://obsidian.codeplayer.org//../../assets/image_1666017081344_0.png width=auto alt=image.png></p><a href=#调试><h3 id=调试><span class=hanchor arialabel=Anchor># </span>调试</h3></a><ul><li>/debug/api_priority_and_fairness/dump_priority_levels —— 所有优先级及其当前状态的列表<ul><li>kubectl get &ndash;raw /debug/api_priority_and_fairness/dump_priority_levels</li></ul></li><li>/debug/api_priority_and_fairness/dump_queues —— 所有队列及其当前状态的列表<ul><li>kubectl get &ndash;raw /debug/api_priority_and_fairness/dump_queues</li></ul></li><li>/debug/api_priority_and_fairness/dump_requests ——当前正在队列中等待的所有请求的列表<ul><li>kubectl get &ndash;raw /debug/api_priority_and_fairness/dump_requests</li></ul></li></ul><a href=#apiserver对象的实现><h1 id=apiserver对象的实现><span class=hanchor arialabel=Anchor># </span>APIServer对象的实现</h1></a><a href=#构建高可用的多副本apiserver><h2 id=构建高可用的多副本apiserver><span class=hanchor arialabel=Anchor># </span>构建高可用的多副本apiserver</h2></a><ul><li>apiserver是无状态的Rest Server</li><li>无状态所以方便Scale Up／down</li><li>负载均衡<ul><li>在多个apiserver实例之上，配置负载均衡</li><li>证书可能需要加上Loadbalancer VIP重新生成</li></ul></li></ul><a href=#预留充足的cpu内存资源><h2 id=预留充足的cpu内存资源><span class=hanchor arialabel=Anchor># </span>预留充足的CPU、内存资源</h2></a><p>随着集群中节点数量不断增多，APIServer对CPU和内存的开销也不断增大。过少的CPU资源会降低其处理效率，过少的内存资源会导致Pod被OOMKilled，直接导致服务不可用。在规划APIServer资源时，不能仅看当下需求，也要为未来预留充分。</p><a href=#善用速率限制ratelimit><h2 id=善用速率限制ratelimit><span class=hanchor arialabel=Anchor># </span>善用速率限制（RateLimit）</h2></a><p>APIServer的参数“&ndash;max-requests-inflight”和“&ndash;max-mutating-requests-inflight”支持在给定时间内限制并行处理读请求（包括Get、List和Watch操作）和写请求（包括Create、Delete、Update和Patch操作）的最大数量。当APIServer接收到的请求超过这两个参数设定的值时，再接收到的请求将会被直接拒绝。通过速率限制机制，可以有效地控制APIServer内存的使用。如果该值配置过低，会经常出现请求超过限制的错误，如果配置过高，则APIServer可能会因为占用过多内存而被强制终止，因此需要根据实际的运行环境，结合实时用户请求数量和APIServer的资源配置进行调优。</p><p>客户端在接收到拒绝请求的返回值后，应等待一段时间再发起重试，无间隔的重试会加重APIServer的压力，导致性能进一步降低。针对并行处理请求数的过滤颗粒度太大，在请求数量比较多的场景，重要的消息可能会被拒绝掉，自1.18版本开始，社区引入了优先级和公平保证（Priority and Fairness）功能，以提供更细粒度地客户端请求控制。该功能支持将不同用户或不同类型的请求进行优先级归类，保证高优先级的请求总是能够更快得到处理，从而不受低优先级请求的影响。</p><a href=#设置合适的缓存大小><h2 id=设置合适的缓存大小><span class=hanchor arialabel=Anchor># </span>设置合适的缓存大小</h2></a><p>APIServer与etcd之间基于gRPC协议进行通信，gRPC协议保证了二者在大规模集群中的数据高速传输。gRPC基于连接复用的HTTP/2协议，即针对相同分组的对象，APIServer和etcd之间共享相同的TCP连接，不同请求由不同的stream传输。</p><p>一个HTTP/2连接有其stream配额 ，配额的大小限制了能支持的并发请求。APIServer提供了集群对象的缓存机制，当客户端发起查询请求时，APIServer默认会将其缓存直接返回给客户端。缓存区大小可以通过参数“&ndash;watch-cache-sizes”设置。针对访问请求比较多的对象，适当设置缓存的大小，极大降低对etcd的访问频率，节省了网络调用，降低了对etcd集群的读写压力，从而提高对象访问的性能。</p><p>但是APIServer也是允许客户端忽略缓存的，例如客户端请求中ListOption中没有设置resourceVersion，这时APIServer直接从etcd拉取最新数据返回给客户端。客户端应尽量避免此操作，应在ListOption中设置resourceVersion为0，APIServer则将从缓存里面读取数据，而不会直接访问etcd。</p><a href=#客户端尽量使用长连接><h2 id=客户端尽量使用长连接><span class=hanchor arialabel=Anchor># </span>客户端尽量使用长连接</h2></a><p>当查询请求的返回数据较大且此类请求并发量较大时，容易引发TCP链路的阻塞，导致其他查询操作超时。因此基于Kubernetes开发组件时，例如某些DaemonSet和Controller，如果要查询某类对象，应尽量通过长连接ListWatch监听对象变更，避免全量从APIServer获取资源。如果在同一应用程序中，如果有多个Informer监听APIServer资源变化，可以将这些Informer合并，减少和APIServer的长连接数，从而降低对APIServer的压力。</p><a href=#搭建多租户的kubernetes集群><h2 id=搭建多租户的kubernetes集群><span class=hanchor arialabel=Anchor># </span>搭建多租户的Kubernetes集群</h2></a><ul><li>授信<ul><li>认证：<ul><li>禁止匿名访问，只允许可信用户做操作。</li></ul></li><li>授权：<ul><li>基于授信的操作，防止多用户之间互相影响，比如普通用户删除Kubernetes核心服务，或者A用户删除或修改B用户的应用。</li></ul></li></ul></li><li>隔离<ul><li>可见行隔离：<ul><li>用户只关心自己的应用，无需看到其他用户的服务和部署。</li></ul></li><li>资源隔离：<ul><li>有些关键项目对资源需求较高，需要专有设备，不与其他人共享。</li></ul></li><li>应用访问隔离：<ul><li>用户创建的服务，按既定规则允许其他用户访问。</li></ul></li></ul></li><li>资源管理<ul><li>Quota管理<ul><li>谁能用多少资源？</li></ul></li></ul></li></ul></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li>No backlinks found</li></ul></div><div><script async src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://obsidian.codeplayer.org/js/graph.6579af7b10c818dbd2ca038702db0224.js></script></div></div><div id=contact_buttons><footer><p>Made by Patrick Zhao using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, © 2023</p><ul><li><a href=https://obsidian.codeplayer.org/>Home</a></li><li><a href=https://github.com/PetrusZ>GitHub</a></li><li><a href=https://t.me/Petrus_Z>Telegram</a></li><li><a href=mailto:silencly07@gmail.com>Email</a></li></ul></footer></div><hr><script src=https://giscus.app/client.js data-repo=PetrusZ/ObsidianPublish data-repo-id=R_kgDOJTGL0A data-category=Announcements data-category-id=DIC_kwDOJTGL0M4CVohQ data-mapping=title data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=preferred_color_scheme data-lang=zh-CN crossorigin=anonymous async></script></div></body></html>