<!doctype html><html lang=en><head><script async defer data-website-id=de560d7e-374a-4694-943f-f3f01b8dba46 src=https://umami.codeplayer.org:1443/umami.js></script>
<script>function _howxm(){_howxmQueue.push(arguments)}window._howxmQueue=window._howxmQueue||[],_howxm("setAppID","21c1239b-b2d0-45c5-8eab-246d8b16a9d6"),function(){if(t="howxm_script",!document.getElementById(t)){var t,e=document.createElement("script"),n=document.getElementsByTagName("script")[0];e.setAttribute("id",t),e.type="text/javascript",e.async=!0,e.src="https://static.howxm.com/sdk.js",n.parentNode.insertBefore(e,n)}}()</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-PCXDEM5E1Q"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-PCXDEM5E1Q",{anonymize_ip:!1})}</script><meta charset=utf-8><meta name=description content="镜像仓库 镜像仓库  镜像仓库（Docker Registry）负责存储、管理和分发镜像。 镜像仓库管理多个Repository，Repository通过命名来区分。每个Repository包含一个或多个镜像，镜像通过镜像名称和标签（Tag）来区分。 客户端拉取镜像时，要指定三要素：  镜像仓库：要从哪一个镜像仓库拉取镜像，通常通过DNS或IP地址来确定一个镜像仓库，如hub.docker.com Repository：组织名，如cncamp 镜像名称+标签：如nginx∶latest      公有镜像仓库优势
开放：任何开发者都可以上传、分享镜像到公有镜像仓库中。
便捷：开发者可以非常方便地搜索、拉取其他开发者的镜像，避免重复造轮子。
免运维：开发者只需要关注应用开发，不必关心镜像仓库的更新、升级、维护等。"><meta property="og:title" content="生产化运维"><meta property="og:description" content="镜像仓库 镜像仓库  镜像仓库（Docker Registry）负责存储、管理和分发镜像。 镜像仓库管理多个Repository，Repository通过命名来区分。每个Repository包含一个或多个镜像，镜像通过镜像名称和标签（Tag）来区分。 客户端拉取镜像时，要指定三要素：  镜像仓库：要从哪一个镜像仓库拉取镜像，通常通过DNS或IP地址来确定一个镜像仓库，如hub.docker.com Repository：组织名，如cncamp 镜像名称+标签：如nginx∶latest      公有镜像仓库优势
开放：任何开发者都可以上传、分享镜像到公有镜像仓库中。
便捷：开发者可以非常方便地搜索、拉取其他开发者的镜像，避免重复造轮子。
免运维：开发者只需要关注应用开发，不必关心镜像仓库的更新、升级、维护等。"><meta property="og:type" content="website"><meta property="og:image" content="https://obsidian.codeplayer.org/icon.png"><meta property="og:url" content="https://obsidian.codeplayer.org/CS/Kubernetes/%E7%94%9F%E4%BA%A7%E5%8C%96%E8%BF%90%E7%BB%B4/"><meta property="og:width" content="200"><meta property="og:height" content="200"><meta name=twitter:card content="summary"><meta name=twitter:title content="生产化运维"><meta name=twitter:description content="镜像仓库 镜像仓库  镜像仓库（Docker Registry）负责存储、管理和分发镜像。 镜像仓库管理多个Repository，Repository通过命名来区分。每个Repository包含一个或多个镜像，镜像通过镜像名称和标签（Tag）来区分。 客户端拉取镜像时，要指定三要素：  镜像仓库：要从哪一个镜像仓库拉取镜像，通常通过DNS或IP地址来确定一个镜像仓库，如hub.docker.com Repository：组织名，如cncamp 镜像名称+标签：如nginx∶latest      公有镜像仓库优势
开放：任何开发者都可以上传、分享镜像到公有镜像仓库中。
便捷：开发者可以非常方便地搜索、拉取其他开发者的镜像，避免重复造轮子。
免运维：开发者只需要关注应用开发，不必关心镜像仓库的更新、升级、维护等。"><meta name=twitter:image content="https://obsidian.codeplayer.org/icon.png"><title>生产化运维</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://obsidian.codeplayer.org//icon.png><link href=https://obsidian.codeplayer.org/styles.80333fa2099c0bee674efa435fde378c.min.css rel=stylesheet><link href=https://obsidian.codeplayer.org/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://obsidian.codeplayer.org/js/darkmode.245a0a31da505f6b327aec1fcae860c8.min.js></script>
<script src=https://obsidian.codeplayer.org/js/util.00639692264b21bc3ee219733d38a8be.min.js></script>
<link rel=preload href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css as=style onload='this.onload=null,this.rel="stylesheet"' integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/core@1.2.1></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/dom@1.2.1></script>
<script async src=https://obsidian.codeplayer.org/js/popover.aa9bc99c7c38d3ae9538f218f1416adb.min.js></script>
<script defer src=https://obsidian.codeplayer.org/js/code-title.ce4a43f09239a9efb48fee342e8ef2df.min.js></script>
<script defer src=https://obsidian.codeplayer.org/js/clipboard.2913da76d3cb21c5deaa4bae7da38c9f.min.js></script>
<script defer src=https://obsidian.codeplayer.org/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const SEARCH_ENABLED=!1,LATEX_ENABLED=!0,PRODUCTION=!0,BASE_URL="https://obsidian.codeplayer.org/",fetchData=Promise.all([fetch("https://obsidian.codeplayer.org/indices/linkIndex.426cb72d3900699f4a741b24fa87136d.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://obsidian.codeplayer.org/indices/contentIndex.c3f112ca03a075e01d74d358984d0d37.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://obsidian.codeplayer.org",!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!1;drawGraph("https://obsidian.codeplayer.org",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}var i=document.getElementsByClassName("mermaid");i.length>0&&import("https://unpkg.com/mermaid@9/dist/mermaid.esm.min.mjs").then(e=>{e.default.init()});function a(n){const e=n.target,t=e.className.split(" "),s=t.includes("broken"),o=t.includes("internal-link");plausible("Link Click",{props:{href:e.href,broken:s,internal:o,graph:!1}})}const r=document.querySelectorAll("a");for(link of r)link.className.includes("root-title")&&link.addEventListener("click",a,{once:!0})},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'’':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/obsidian.codeplayer.org\/js\/router.d6fe6bd821db9ea97f9aeefae814d8e7.min.js"
    attachSPARouting(init, render)
  </script><script defer data-domain=obsidian.codeplayer.org src=https://plausible.io/js/script.js></script>
<script>window.plausible=window.plausible||function(){(window.plausible.q=window.plausible.q||[]).push(arguments)}</script></head><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://obsidian.codeplayer.org/js/full-text-search.e6e2e0c213187ca0c703d6e2c7a77fcd.min.js></script><div class=singlePage><header><h1 id=page-title><a class=root-title href=https://obsidian.codeplayer.org/>Avalon Obsidian Vault</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>生产化运维</h1><p class=meta>Last updated
Apr 9, 2023
<a href=https://github.com/PetrusZ/avalon-obsidian-vault/tree/main/CS/Kubernetes/%e7%94%9f%e4%ba%a7%e5%8c%96%e8%bf%90%e7%bb%b4.md rel=noopener>Edit Source</a></p><ul class=tags><li><a href=https://obsidian.codeplayer.org/tags/CS/Kubernetes/>Cs kubernetes</a></li></ul><aside class=mainTOC><details open><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#镜像仓库>镜像仓库</a><ol><li><a href=#镜像仓库-1>镜像仓库</a></li><li><a href=#镜像仓库遵循oci的distribution-spec>镜像仓库遵循OCI的Distribution Spec</a></li><li><a href=#数据和块文件>数据和块文件</a></li><li><a href=#harbor>Harbor</a><ol><li><a href=#harbor提供的服务>Harbor提供的服务</a></li><li><a href=#harbor架构>Harbor架构</a></li><li><a href=#harbor高可用架构>Harbor高可用架构</a></li></ol></li><li><a href=#本地镜像加速dragonfly>本地镜像加速Dragonfly</a><ol><li><a href=#优势>优势</a></li><li><a href=#镜像下载流程>镜像下载流程</a></li></ol></li></ol></li><li><a href=#镜像安全>镜像安全</a><ol><li><a href=#镜像安全的最佳实践>镜像安全的最佳实践</a></li><li><a href=#镜像扫描vulnerability-scanning>镜像扫描（Vulnerability Scanning）</a></li><li><a href=#镜像策略准入控制>镜像策略准入控制</a></li><li><a href=#扫描镜像>扫描镜像</a></li><li><a href=#镜像扫描服务>镜像扫描服务</a></li></ol></li><li><a href=#基于kubernetes的devops>基于Kubernetes的DevOps</a><ol><li><a href=#传统运维模式>传统运维模式</a></li><li><a href=#建立持续交付的服务体系>建立持续交付的服务体系</a></li><li><a href=#基于docker的开发模式驱动持续集成>基于Docker的开发模式驱动持续集成</a></li><li><a href=#devops流程定义>DevOps流程定义</a></li><li><a href=#dev和ops的边界定义>Dev和Ops的边界定义</a></li><li><a href=#定义production-readiness>定义production readiness</a></li><li><a href=#单体架构下的人员配置>单体架构下的人员配置</a></li><li><a href=#微服务架构下的人员配置>微服务架构下的人员配置</a></li><li><a href=#devops下的人员划分>DevOps下的人员划分</a></li><li><a href=#此组织结构的优缺点>此组织结构的优缺点</a><ol><li><a href=#优势-1>优势</a></li><li><a href=#问题>问题</a></li></ol></li><li><a href=#我眼中理想的devops>我眼中理想的DevOps</a></li><li><a href=#devops流程概览>DevOps流程概览</a></li><li><a href=#代码分支管理>代码分支管理</a></li><li><a href=#持续集成>持续集成</a></li><li><a href=#持续部署>持续部署</a></li><li><a href=#gitops>Gitops</a></li></ol></li><li><a href=#基于jenkins的自动化流水线>基于Jenkins的自动化流水线</a><ol><li><a href=#kubernetes-cicd完整流程>Kubernetes CI&CD完整流程</a></li></ol></li><li><a href=#tekton>Tekton</a><ol><li><a href=#jenkins的不足>Jenkins的不足</a></li><li><a href=#基于声明式api的流水线-tekton>基于声明式API的流水线-Tekton</a></li><li><a href=#tekton核心组件>Tekton核心组件</a></li><li><a href=#输入输出资源>输入输出资源</a></li><li><a href=#事件触发的自动化流水线>事件触发的自动化流水线</a></li><li><a href=#eventlistener>EventListener</a></li></ol></li><li><a href=#argocd>Argocd</a><ol><li><a href=#argocd-1>Argocd</a></li><li><a href=#argo-cd-架构>argo cd 架构</a></li><li><a href=#argocd的适用场景>argocd的适用场景</a></li></ol></li><li><a href=#监控和日志>监控和日志</a><ol><li><a href=#数据系统构建>数据系统构建</a></li><li><a href=#日志系统的价值>日志系统的价值</a></li><li><a href=#常用数据系统构建模式>常用数据系统构建模式</a></li><li><a href=#日志收集系统loki>日志收集系统Loki</a></li><li><a href=#基于loki的日志收集系统>基于Loki的日志收集系统</a></li><li><a href=#loki-stack子系统>Loki-stack子系统</a></li><li><a href=#loki架构>Loki架构</a></li><li><a href=#loki组件>Loki组件</a></li><li><a href=#在生产中的问题>在生产中的问题</a></li><li><a href=#监控系统>监控系统</a></li><li><a href=#在kubernetes集群中的监控系统>在Kubernetes集群中的监控系统</a></li><li><a href=#prometheus中的指标类型>Prometheus中的指标类型</a></li><li><a href=#prometheus-query-language>Prometheus Query Language</a></li><li><a href=#构建支撑生产的监控系统>构建支撑生产的监控系统</a></li><li><a href=#来自生产系统的经验分享>来自生产系统的经验分享</a></li></ol></li></ol></nav></details></aside><a href=#镜像仓库><h1 id=镜像仓库><span class=hanchor arialabel=Anchor># </span>镜像仓库</h1></a><a href=#镜像仓库-1><h2 id=镜像仓库-1><span class=hanchor arialabel=Anchor># </span>镜像仓库</h2></a><ul><li>镜像仓库（Docker Registry）负责存储、管理和分发镜像。</li><li>镜像仓库管理多个Repository，Repository通过命名来区分。每个Repository包含一个或多个镜像，镜像通过镜像名称和标签（Tag）来区分。</li><li>客户端拉取镜像时，要指定三要素：<ul><li>镜像仓库：要从哪一个镜像仓库拉取镜像，通常通过DNS或IP地址来确定一个镜像仓库，如hub.docker.com</li><li>Repository：组织名，如cncamp</li><li>镜像名称+标签：如nginx∶latest</li></ul></li></ul><p><img src=https://obsidian.codeplayer.org//Assets/image_1667053630959_0.png width=auto alt=image.png></p><hr><p><strong>公有镜像仓库优势</strong></p><p>开放：任何开发者都可以上传、分享镜像到公有镜像仓库中。</p><p>便捷：开发者可以非常方便地搜索、拉取其他开发者的镜像，避免重复造轮子。</p><p>免运维：开发者只需要关注应用开发，不必关心镜像仓库的更新、升级、维护等。</p><p>成本低：企业或开发者不需要购买硬件、解决方案来搭建镜像仓库，也不需要团队来维护。</p><p><strong>私有镜像仓库优势</strong></p><p>隐私性：企业的代码和数据是企业的私有资产，不允许随意共享到公共平台。</p><p>敏感性：企业的镜像会包含一些敏感信息，如密钥信息、令牌信息等。这些敏感信息严禁暴露到企业外部。</p><p>网络连通性：企业的网络结构多种多样，并非所有环境都可以访问互联网。</p><p>安全性：而在企业环境中，若使用一些含有漏洞的依赖包，则会引入安全隐患。</p><a href=#镜像仓库遵循oci的distribution-spec><h2 id=镜像仓库遵循oci的distribution-spec><span class=hanchor arialabel=Anchor># </span>镜像仓库遵循OCI的Distribution Spec</h2></a><p><img src=https://obsidian.codeplayer.org//Assets/image_1667053850649_0.png width=auto alt=image.png></p><a href=#数据和块文件><h2 id=数据和块文件><span class=hanchor arialabel=Anchor># </span>数据和块文件</h2></a><p>镜像由元数据和块文件两部分组成，镜像仓库的核心职能就是管理这两项数据。</p><ul><li>元数据<ul><li>元数据用于描述一个镜像的核心信息，包含镜像的镜像仓库、仓库、标签、校验码、文件层，镜像构建描述等信息。</li><li>通过这些信息，可以从抽象层面完整地描述一个镜像∶它是如何构建出来的、运行过什么构建命令、构建的每一个文件层的校验码、打的标签、镜像的校验码等。</li></ul></li><li>块文件（blob）<ul><li>块文件是组成镜像的联合文件层的实体，每一个块文件是一个文件层，内部包含对应文件层的变更。</li></ul></li></ul><p><img src=https://obsidian.codeplayer.org//Assets/image_1667053866547_0.png width=auto alt=image.png></p><a href=#harbor><h2 id=harbor><span class=hanchor arialabel=Anchor># </span>Harbor</h2></a><p>Harbor是VMware开源的企业级镜像仓库，目前已是CNCF的毕业项目。它拥有完整的仓库管理、镜像管理、基于角色的权限控制、镜像安全扫描集成、镜像签名等。</p><p><img src=https://obsidian.codeplayer.org//Assets/image_1667054088588_0.png width=auto alt=image.png></p><a href=#harbor提供的服务><h3 id=harbor提供的服务><span class=hanchor arialabel=Anchor># </span>Harbor提供的服务</h3></a><p>Harbor核心服务：提供Harbor的核心管理服务API，包括仓库管理，认证管理，授权管理，配置管理、项目管理、配额管理、签名管理、副本管理等。</p><p>Harbor Portal：Harbor的Web界面。</p><p>Registry：Registry负责接收客户端的pull/push请求，其核心为docker/Distribution。</p><p>副本控制器：Harbor可以以主从模式来部署镜像仓库，副本控制器将镜像从主镜像服务分发到从镜像服务。</p><p>日志收集器：收集各模块的日志。</p><p>垃圾回收控制器：回收日常操作中删除镜像记录后遗留在块存储中的孤立块文件。</p><a href=#harbor架构><h3 id=harbor架构><span class=hanchor arialabel=Anchor># </span>Harbor架构</h3></a><p><img src=https://obsidian.codeplayer.org//Assets/image_1667054290568_0.png width=auto alt=image.png></p><a href=#harbor高可用架构><h3 id=harbor高可用架构><span class=hanchor arialabel=Anchor># </span>Harbor高可用架构</h3></a><p><img src=https://obsidian.codeplayer.org//Assets/image_1667054764792_0.png width=auto alt=image.png></p><a href=#本地镜像加速dragonfly><h2 id=本地镜像加速dragonfly><span class=hanchor arialabel=Anchor># </span>本地镜像加速Dragonfly</h2></a><ul><li>Dragonfly是一款基于P2P的智能镜像和文件分发工具</li><li>它旨在提高文件传输的效率和速率，最大限度地利用网络带宽，尤其是在分发大量数据时<ul><li>应用分发</li><li>缓存分发</li><li>日志分发</li><li>镜像分发</li></ul></li></ul><a href=#优势><h3 id=优势><span class=hanchor arialabel=Anchor># </span>优势</h3></a><ul><li>基于P2P的文件分发</li><li>非侵入式支持所有类型的容器技术</li><li>机器级别的限速</li><li>被动式CDN</li><li>高度一致性</li><li>磁盘保护和高效 IO</li><li>高性能</li><li>自动隔离异常</li><li>对文件源无压力</li><li>支持标准 HTTP 头文件</li><li>有效的 Registry鉴权并发控制</li><li>简单易用</li></ul><a href=#镜像下载流程><h3 id=镜像下载流程><span class=hanchor arialabel=Anchor># </span>镜像下载流程</h3></a><p>dfget proxy也称为 dfdaemon，会拦截来自 docker pull或docker push的HTTP请求，然后使用 dfget 来处理那些跟镜像分层相关的请求</p><p><img src=https://obsidian.codeplayer.org//Assets/image_1667055180018_0.png width=auto alt=image.png></p><p>每个文件会被分成多个分块，并在对等节点之间传输</p><p><img src=https://obsidian.codeplayer.org//Assets/image_1667055195716_0.png width=auto alt=image.png></p><a href=#镜像安全><h1 id=镜像安全><span class=hanchor arialabel=Anchor># </span>镜像安全</h1></a><a href=#镜像安全的最佳实践><h2 id=镜像安全的最佳实践><span class=hanchor arialabel=Anchor># </span>镜像安全的最佳实践</h2></a><ul><li>构建指令问题<ul><li>避免在构建竟像时，添加密钥，Token等敏感信息（配置与代码应分离）</li></ul></li><li>应用依赖问题<ul><li>应尽量避免安装不必要的依赖</li><li>确保依赖无安全风险，一些长时间不更新的基础镜像的可能面临安全风险，比如基于openssl1.0，只支持tls1.0等</li></ul></li><li>文件问题<ul><li>在构建镜像时，除应用本身外，还会添加应用需要的配置文件、模板等，在添加这些文件时，会无意间添加一些包含敏感信息或不符合安全策略的文件到镜像中。</li><li>当镜像中存在文件问题时，需要通过引入该文件的构建指令行进行修复，而不是通过追加一条删除指令来修复。</li></ul></li></ul><p><img src=https://obsidian.codeplayer.org//Assets/image_1667055854221_0.png width=auto alt=image.png></p><a href=#镜像扫描vulnerability-scanning><h2 id=镜像扫描vulnerability-scanning><span class=hanchor arialabel=Anchor># </span>镜像扫描（Vulnerability Scanning）</h2></a><p>镜像扫描通过扫描工具或扫描服务对镜像进行扫描，来确定镜像是否安全</p><ul><li>分析构建指令、应用、文件、依赖包</li><li>查询CVE库、安全策略</li><li>检测镜像是否安全，是否符合企业的安全标准。</li></ul><a href=#镜像策略准入控制><h2 id=镜像策略准入控制><span class=hanchor arialabel=Anchor># </span>镜像策略准入控制</h2></a><p>镜像准入控制是在部署Pod、更新Pod时，对Pod 中的所有镜像进行安全验证以放行或拦截对Pod的操作：</p><ul><li>放行：Pod中所有的镜像都安全，允许此次的操作，Pod成功被创建或更新。</li><li>拦截：Pod中的镜像未扫描，或已经扫描但存在安全漏洞，或不符合安全策略，Pod无法被创建或更新。</li></ul><p><img src=https://obsidian.codeplayer.org//Assets/image_1667056069430_0.png width=auto alt=image.png></p><a href=#扫描镜像><h2 id=扫描镜像><span class=hanchor arialabel=Anchor># </span>扫描镜像</h2></a><ol><li>镜像扫描服务从镜像仓库拉取镜像。</li><li>解析镜像的元数据。</li><li>解压镜像的每一个文件层。</li><li>提取每一层所包含的依赖包、可运行程序、文件列表、文件内容扫描。</li><li>将扫描结果与CVE字典、安全策略字典进行匹配，以确认最终镜像是否安全。</li></ol><a href=#镜像扫描服务><h2 id=镜像扫描服务><span class=hanchor arialabel=Anchor># </span>镜像扫描服务</h2></a><p><img src=https://obsidian.codeplayer.org//Assets/image_1667056153240_0.png width=auto alt=image.png></p><a href=#基于kubernetes的devops><h1 id=基于kubernetes的devops><span class=hanchor arialabel=Anchor># </span>基于Kubernetes的DevOps</h1></a><a href=#传统运维模式><h2 id=传统运维模式><span class=hanchor arialabel=Anchor># </span>传统运维模式</h2></a><ul><li>缺乏一致性环境</li><li>平台与应用部署相互割裂</li><li>缺乏工具链支持</li><li>缺乏统一的灰度发布管理</li><li>缺乏统一监控能力和持续运维能力</li></ul><p><img src=https://obsidian.codeplayer.org//Assets/image_1667058218102_0.png width=auto alt=image.png></p><a href=#建立持续交付的服务体系><h2 id=建立持续交付的服务体系><span class=hanchor arialabel=Anchor># </span>建立持续交付的服务体系</h2></a><p>传统的开发运维模式下，存在的问题：</p><ul><li>从需求到版本上线中间是个黑箱子，风险不可控；</li><li>开发设计时未过多考虑运维，导致后续部署及维护的困难；</li><li>开发各自为政，烟囱式开发，未考虑共享重用、联调，开发的资产积累不能快速交移到运维手中；</li></ul><p>应对这样的问题，我们通常倡导的解决之道是：运维前移，统一运维，建立持续交付服务体系。</p><a href=#基于docker的开发模式驱动持续集成><h2 id=基于docker的开发模式驱动持续集成><span class=hanchor arialabel=Anchor># </span>基于Docker的开发模式驱动持续集成</h2></a><p><img src=https://obsidian.codeplayer.org//Assets/image_1667058564537_0.png width=auto alt=image.png></p><a href=#devops流程定义><h2 id=devops流程定义><span class=hanchor arialabel=Anchor># </span>DevOps流程定义</h2></a><p><img src=https://obsidian.codeplayer.org//Assets/image_1667058593881_0.png width=auto alt=image.png></p><a href=#dev和ops的边界定义><h2 id=dev和ops的边界定义><span class=hanchor arialabel=Anchor># </span>Dev和Ops的边界定义</h2></a><p>Programming vs. Engineering</p><p>Programming更多的是系统设计和编码实现</p><p>Engineering包含更大范围概念，除了功能层面的实现，还需为运维服务</p><a href=#定义production-readiness><h2 id=定义production-readiness><span class=hanchor arialabel=Anchor># </span>定义production readiness</h2></a><p>Function ready vs. production ready</p><ul><li>Function Ready只是交付的软件产品从功能层面满足需求定义</li><li>Production Ready除了功能就绪还包含<ul><li>LnP测试通过，满足性能需求</li><li>用户手册完成，用户可按照用户手册使用既定功能</li><li>管理手册完成，运维人员可以依照管理手册部署，升级产品并解决现网问题</li><li>监控，包括<ul><li>组件健康状态检查（UP）</li><li>性能指标（Metrics）</li><li>基于性能指标，定义alert rule，在系统故障或缓慢时，发送告警信息给运维人员</li><li>Assertion，定期测试某功能并检查结果，比如每小时创建service，测试vip连通性</li></ul></li></ul></li></ul><a href=#单体架构下的人员配置><h2 id=单体架构下的人员配置><span class=hanchor arialabel=Anchor># </span>单体架构下的人员配置</h2></a><p><img src=https://obsidian.codeplayer.org//Assets/image_1667059342424_0.png width=auto alt=image.png></p><a href=#微服务架构下的人员配置><h2 id=微服务架构下的人员配置><span class=hanchor arialabel=Anchor># </span>微服务架构下的人员配置</h2></a><p><img src=https://obsidian.codeplayer.org//Assets/image_1667059375806_0.png width=auto alt=image.png></p><a href=#devops下的人员划分><h2 id=devops下的人员划分><span class=hanchor arialabel=Anchor># </span>DevOps下的人员划分</h2></a><p><img src=https://obsidian.codeplayer.org//Assets/image_1667059434125_0.png width=auto alt=image.png></p><a href=#此组织结构的优缺点><h2 id=此组织结构的优缺点><span class=hanchor arialabel=Anchor># </span>此组织结构的优缺点</h2></a><a href=#优势-1><h3 id=优势-1><span class=hanchor arialabel=Anchor># </span>优势</h3></a><ul><li>一个架构师负责整个产品的规划，使得产品更规范，产品进化不同的Program由不同PO负责端到端，从需求到生产系统部署，保证solution质量</li><li>研发和运营统一，一个最大的作用是研发可以深刻理解现网痛苦，对功能需求的设计，和优先级定义有极大帮助。</li><li>Function ready vs. production ready</li><li>Programming vs. Engineering</li><li>更具连续性</li></ul><a href=#问题><h3 id=问题><span class=hanchor arialabel=Anchor># </span>问题</h3></a><ul><li>传统运营和开发的冲突并非消失，而是转变为了运营经理和架构以及PO之间的冲突。</li><li>运营轮值导致生产系统权责不明确</li><li>轮值期间期待不出故障</li><li>对于出现的故障缺少端对端的跟踪，可能问题还没处理结束，已经要交接给下一个人了</li><li>对于生产系统的积累问题，如故障节点，无人专职处理，导致比较多的故障节点堆积</li><li>对于生产系统的配置，无统一规划，每个人可能用不同的配置达到相同的目的</li><li>Dev自主权过高导致Dev可以偷偷加功能并部署到生产</li></ul><a href=#我眼中理想的devops><h2 id=我眼中理想的devops><span class=hanchor arialabel=Anchor># </span>我眼中理想的DevOps</h2></a><p>Dev和Ops需要责权划分，可以有overlap，同时做部署，同时做计划，但Dev应侧重功能开发，Ops偏重生产系统运维</p><p>Ops参与到版本规划流程中，并为一个功能能不能release和deploy把关</p><ul><li>Dev<ul><li>Plan</li><li>Code</li><li>Build</li><li>Test</li><li>Release</li><li>Deploy</li></ul></li><li>Ops<ul><li>Deploy</li><li>Operate</li><li>Monitor</li><li>Plan</li></ul></li></ul><p><img src=https://obsidian.codeplayer.org//Assets/image_1667060313830_0.png width=auto alt=image.png></p><a href=#devops流程概览><h2 id=devops流程概览><span class=hanchor arialabel=Anchor># </span>DevOps流程概览</h2></a><p><img src=https://obsidian.codeplayer.org//Assets/image_1667060846273_0.png width=auto alt=image.png></p><a href=#代码分支管理><h2 id=代码分支管理><span class=hanchor arialabel=Anchor># </span>代码分支管理</h2></a><p><img src=https://obsidian.codeplayer.org//Assets/image_1667060900749_0.png width=auto alt=image.png></p><a href=#持续集成><h2 id=持续集成><span class=hanchor arialabel=Anchor># </span>持续集成</h2></a><p><img src=https://obsidian.codeplayer.org//Assets/image_1667061198936_0.png width=auto alt=image.png></p><a href=#持续部署><h2 id=持续部署><span class=hanchor arialabel=Anchor># </span>持续部署</h2></a><p><img src=https://obsidian.codeplayer.org//Assets/image_1667061220025_0.png width=auto alt=image.png></p><a href=#gitops><h2 id=gitops><span class=hanchor arialabel=Anchor># </span>Gitops</h2></a><p><img src=https://obsidian.codeplayer.org//Assets/image_1667061243780_0.png width=auto alt=image.png></p><a href=#基于jenkins的自动化流水线><h1 id=基于jenkins的自动化流水线><span class=hanchor arialabel=Anchor># </span>基于Jenkins的自动化流水线</h1></a><a href=#kubernetes-cicd完整流程><h2 id=kubernetes-cicd完整流程><span class=hanchor arialabel=Anchor># </span>Kubernetes CI&CD完整流程</h2></a><p><img src=https://obsidian.codeplayer.org//Assets/image_1667115885998_0.png width=auto alt=image.png></p><a href=#tekton><h1 id=tekton><span class=hanchor arialabel=Anchor># </span>Tekton</h1></a><a href=#jenkins的不足><h2 id=jenkins的不足><span class=hanchor arialabel=Anchor># </span>Jenkins的不足</h2></a><ul><li>基于脚本的Job配置复用率不足<ul><li>Jenkins等工具的流水线作业通常基于大量不可复用的脚本语言，如何提高代码复用率</li></ul></li><li>代码调试困难<ul><li>如何让流水线作业的配置更好地适应云原生场景的需求越来越急迫</li></ul></li></ul><a href=#基于声明式api的流水线-tekton><h2 id=基于声明式api的流水线-tekton><span class=hanchor arialabel=Anchor># </span>基于声明式API的流水线-Tekton</h2></a><p>自定义：Tekton对象是高度自定义的，可扩展性极强。平台工程师可预定义可重用模块以详细的模块目录提供，开发人员可在其他项目中直接引用。</p><p>可重用：Tekton对象的可重用性强，组件只需—次定义，即可被组织内的任何人在任何流水线都可重用。使得开发人员无需重复造轮子即可构建复杂流水线。</p><p>可扩展性：Tekton组件目录（Tekton Catalog）是一个社区驱动的Tekton组件的存储仓库。任何用户可以直接从社区获取成熟的组件并在此之上构建复杂流水线，也就是当你要构建一个流水线时，很可能你需要的所有代码和配置都可以从Tekton Catalog直接拿下来复用，而无需重复开发。</p><p>标准化：Tekton作为Kubernetes集群的扩展安装和运行，并使用业界公认的Kubernetes资源模型；Tekton作业以Kubernetes容器形态执行。</p><p>规模化支持：只需增加Kubernetes节点，即可增加作业处理能力。Tekton的能力可依照集群规模随意扩充，无需重新定义资源分配需求或者重新定义流水线。</p><a href=#tekton核心组件><h2 id=tekton核心组件><span class=hanchor arialabel=Anchor># </span>Tekton核心组件</h2></a><p>Pipeline：对象定义了一个流水线作业，一个Pipeline对象由一个或数个Task对象组成。</p><p>Task：一个可独立运行的任务，如获取代码，编译，或者推送镜像等等，当流水线被运行时，Kubernetes会为每个Task创建一个Pod。一个Task由多个Step组成，每个Step体现为这个Pod中的一个容器。</p><p><img src=https://obsidian.codeplayer.org//Assets/image_1667119295352_0.png width=auto alt=image.png></p><a href=#输入输出资源><h2 id=输入输出资源><span class=hanchor arialabel=Anchor># </span>输入输出资源</h2></a><p>Pipeline和Task对象可以接收git reposity，pull request等资源作为输入，可以将Image，Kubernetes Cluster，Storage，CloudEvent等对象作为输出</p><p><img src=https://obsidian.codeplayer.org//Assets/image_1667119345327_0.png width=auto alt=image.png></p><a href=#事件触发的自动化流水线><h2 id=事件触发的自动化流水线><span class=hanchor arialabel=Anchor># </span>事件触发的自动化流水线</h2></a><p><img src=https://obsidian.codeplayer.org//Assets/image_1667120405330_0.png width=auto alt=image.png></p><a href=#eventlistener><h2 id=eventlistener><span class=hanchor arialabel=Anchor># </span>EventListener</h2></a><p>EventListener:</p><p>事件监听器，该对象核心属性是interceptors拦截器，该拦截器可监听多种类型的事件，比如监听来自GitLab的Push事件。</p><p>当该EventListener对象被创建以后，Tekton 控制器会为该EventListener创建Kubernetes Pod和Service，并启动一个HTTP服务以监听Push事件。</p><p>当用户在GitLab项目中设置webhook并填写该EventListener的服务地址以后，任何人针对被管理项目发起的Push操作，都会被EventListener捕获。</p><a href=#argocd><h1 id=argocd><span class=hanchor arialabel=Anchor># </span>Argocd</h1></a><a href=#argocd-1><h2 id=argocd-1><span class=hanchor arialabel=Anchor># </span>Argocd</h2></a><p>Argo CD是用于Kubernetes的声明性GitOps连续交付工具。</p><p><strong>为什么选择Argo CD?</strong></p><p>应用程序定义，配置和环境应为声明性的，并受版本控制。</p><p>应用程序部署和生命周期管理应该是自动化的，可审核的且易于理解的。</p><a href=#argo-cd-架构><h2 id=argo-cd-架构><span class=hanchor arialabel=Anchor># </span>argo cd 架构</h2></a><p>Argo CD被实现为kubernetes控制器，该控制器连续监视正在运行的应用程序，并将当前的活动状态与所需的目标状态（在Git存储库中指定）进行比较。</p><p>其活动状态偏离目标状态的已部署应用程序被标记为Outofsync。</p><p>Argo CD报告并可视化差异，同时提供了自动或手动将实时状态同步回所需目标状态的功能。</p><p>在Git存储库中对所需目标状态所做的任何修改都可以自动应用并反映在指定的目标环境中。</p><p><img src=https://obsidian.codeplayer.org//Assets/image_1667121172178_0.png width=auto alt=image.png></p><a href=#argocd的适用场景><h2 id=argocd的适用场景><span class=hanchor arialabel=Anchor># </span>argocd的适用场景</h2></a><ol><li>低成本的Gitops利器</li><li>多集群管理<ol><li>不同目的集群∶测试，集成，预生产，生产</li><li>多生产集群管理</li></ol></li></ol><a href=#监控和日志><h1 id=监控和日志><span class=hanchor arialabel=Anchor># </span>监控和日志</h1></a><a href=#数据系统构建><h2 id=数据系统构建><span class=hanchor arialabel=Anchor># </span>数据系统构建</h2></a><p>日志收集与分析</p><p>监控系统构建</p><a href=#日志系统的价值><h2 id=日志系统的价值><span class=hanchor arialabel=Anchor># </span>日志系统的价值</h2></a><p>分布式系统的日志查看比较复杂，因为多对节点的系统，要先找到正确的节点，才能看到想看的日志。日志系统把整个集群的日志汇总在一起，方便查看</p><p>因为节点上的日志滚动机制，如果有应用打印太多日志，如果没有日志系统，会导致关键日志 •丢失。</p><p>日志系统的重要意义在于解决，节点出错导致不可访问，进而丢失日志的情况。</p><a href=#常用数据系统构建模式><h2 id=常用数据系统构建模式><span class=hanchor arialabel=Anchor># </span>常用数据系统构建模式</h2></a><p><img src=https://obsidian.codeplayer.org//Assets/image_1667134573485_0.png width=auto alt=image.png></p><a href=#日志收集系统loki><h2 id=日志收集系统loki><span class=hanchor arialabel=Anchor># </span>日志收集系统Loki</h2></a><p>Grafana Loki是可以组成功能齐全的日志记录堆栈的一组组件。</p><ul><li>与其他日志记录系统不同，Loki是基于仅索引有关日志的元数据的想法而构建的：标签。</li><li>日志数据本身被压缩并存储在对象存储（例如S3或GCS）中的块中，甚至存储在文件系统本地。</li><li>小索引和高度压缩的块简化了操作，并大大降低了Loki的成本。</li></ul><a href=#基于loki的日志收集系统><h2 id=基于loki的日志收集系统><span class=hanchor arialabel=Anchor># </span>基于Loki的日志收集系统</h2></a><p><img src=https://obsidian.codeplayer.org//Assets/image_1667135054996_0.png width=auto alt=image.png></p><a href=#loki-stack子系统><h2 id=loki-stack子系统><span class=hanchor arialabel=Anchor># </span>Loki-stack子系统</h2></a><ul><li>Promtail<ul><li>将容器日志发送到 Loki或者Grafana 服务上的日志收集工具</li><li>发现采集目标以及给日志流添加上Label，然后发送给Loki</li><li>Promtail 的服务发现是基于Prometheus 的服务发现机制实现的，可以查看configmap loki-promtail了解细节</li></ul></li><li>Loki<ul><li>Loki是可以水平扩展、高可用以及支持多租户的日志聚合系统</li><li>使用和 Prometheus 相同的服务发现机制，将标签添加到日志流中而不是构建全文索引</li><li>Promtail 接收到的日志和应用的 metrics指标就具有相同的标签集</li></ul></li><li>Grafana<ul><li>Grafana 是一个用于监控和可视化观测的开源平台，支持非常丰富的数据源</li><li>在 Loki技术栈中它专门用来展示来自 Prometheus和 Loki 等数据源的时间序列数据</li><li>允许进行查询、可视化、报警等操作，可以用于创建、探索和共享数据 Dashboard</li></ul></li></ul><a href=#loki架构><h2 id=loki架构><span class=hanchor arialabel=Anchor># </span>Loki架构</h2></a><p><img src=https://obsidian.codeplayer.org//Assets/image_1667135213971_0.png width=auto alt=image.png></p><a href=#loki组件><h2 id=loki组件><span class=hanchor arialabel=Anchor># </span>Loki组件</h2></a><ul><li>Distributor（分配器）<ul><li>分配器服务负责处理客户端写入的日志。</li><li>一旦分配器接收到日志数据，它就会把它们分成若干批次，并将它们并行地发送到多个采集器去。</li><li>分配器通过 gRPC和采集器进行通信。</li><li>它们是无状态的， 基于一致性哈希，我们可以根据实际需要对他们进行扩缩容。</li></ul></li><li>Ingester（采集器）<ul><li>采集器服务负责将日志数据写入长期存储的后端（DynamoDB、S3、Cassandra 等等）。</li><li>采集器会校验采集的日志是否乱序。</li><li>采集器验证接收到的日志行是按照时间戳递增的顺序接收的，否则日志行将被拒绝并返回错误。</li></ul></li><li>Querier（查询器）<ul><li>查询器服务负责处理 LogQL 查询语句来评估存储在长期存储中的日志数据。</li></ul></li></ul><a href=#在生产中的问题><h2 id=在生产中的问题><span class=hanchor arialabel=Anchor># </span>在生产中的问题</h2></a><p>存在的问题</p><ul><li>利用率低<ul><li>日志大多数目的是给管理员做问题分析用的，但管理员更多的是登陆到节点或者pod里做分析，因为日志分析只是整个分析过程中的一部分，所以很多时候顺手就把日志看了</li></ul></li><li>Beats出现过锁住文件系统，docker container无法删除的情况</li><li>与监控系统相比，日志系统的重要度稍低</li><li>出现过多次因为日志滚动太快而使得日志收集占用太大网络带宽的情况</li></ul><a href=#监控系统><h2 id=监控系统><span class=hanchor arialabel=Anchor># </span>监控系统</h2></a><ul><li>为什么监控，监控什么内容<ul><li>对自己系统的运行状态了如指掌，有问题及时发现，而不让用户先发现我们系统不能使用。</li><li>我们也需要知道我们的服务运行情况。例如，slowsql处于什么水平，平均响应时间超过200ms的占比有百分之多少</li></ul></li><li>我们为什么需要监控我们的服务<ul><li>需要监控工具来提醒我服务出现了故障，比如通过监控服务的负载来决定扩容或缩容。如果机器普遍负载不高，则可以考虑是否缩减一下机器规模，如果数据库连接经常维持在一个高位水平，则可以考虑一下是否可以进行拆库处理，优化一下架构。</li><li>监控还可以帮助进行内部统制，尤其是对安全比较敏感的行业，比如证券银行等。比如服务器受到攻击时，我们需要分析事件，找到根本原因，识别类似攻击，发现没有发现的被攻击的系统，甚至完成取证等工作。</li></ul></li><li>监控目的<ul><li>减少宕机时间</li><li>扩展和性能管理</li><li>资源计划</li><li>识别异常事件</li><li>故障排除、分析</li></ul></li></ul><a href=#在kubernetes集群中的监控系统><h2 id=在kubernetes集群中的监控系统><span class=hanchor arialabel=Anchor># </span>在Kubernetes集群中的监控系统</h2></a><p><img src=https://obsidian.codeplayer.org//Assets/image_1667136576658_0.png width=auto alt=image.png></p><a href=#prometheus中的指标类型><h2 id=prometheus中的指标类型><span class=hanchor arialabel=Anchor># </span>Prometheus中的指标类型</h2></a><ul><li>Counter （计数器器）<ul><li>Counter 类型代表一种样本数据单调递增的指标，即只增不减，除非监控系统发生了重置。</li></ul></li><li>Gauge（仪表盘）<ul><li>Guage 类型代表一种样本数据可以任意变化的指标，即可增可减。</li></ul></li><li>Histogram（直方图）<ul><li>Histogram 在一段时间范围内对数据进行采样（通常是请求持续时间或响应大小等），并将其计入可配置的存储桶（bucket）中，后续可通过指定区间筛选样本，也可以统计样本总数，最后一般将数据展示为直方图</li><li>样本的值分布在 bucket 中的数量，命名为 <code>&lt;basename>_bucket{le="&lt;上边界>"}</code></li><li>所有样本值的大小总和，命名为 <code>&lt;basename>_sum</code></li><li>样本总数，命名为 <code>&lt;basename>_count</code>。值和 <code>&lt;basename>_bucket{le="+Inf"}</code> 相同</li></ul></li><li>Summary（摘要）<ul><li>与 Histogram 类型类似，用于表示一段时间内的数据采样结果（通常是请求持续时间或响应大小等），但它直接存储了分位数（通过客户端计算，然后展示出来），而不是通过区间来计算</li><li>它们都包含了 <code>&lt;basename>_sum</code> 和 <code>&lt;basename>_count</code> 指标</li><li>Histogram 需要通过 <code>&lt;basename>_bucket</code> 来计算分位数，而 Summary 则直接存储了分位数的值。</li></ul></li></ul><a href=#prometheus-query-language><h2 id=prometheus-query-language><span class=hanchor arialabel=Anchor># </span>Prometheus Query Language</h2></a><ul><li>histogram_quantile(0.95, sum(rate(httpserver_execution_latency_seconds_bucket[5m])) by (le))</li><li>Histogram是直方图， httpserver_execution_latency_seconds_bucke是直方图指标，是将httpserver处理请求的时间放入不同的桶内，其表达的是落在不同时长区间的响应次数</li><li>by (le)，是将采集的数据按桶的上边界分组</li><li>rate(httpserver_execution_latency_seconds_bucket[5m])，计算的是五分钟内的变化率</li><li>Sum()，是将所有指标的变化率总计</li><li>0.95，是取95分位</li><li>综上：<ul><li>上述表达式计算的是httpserver处理请求时，95%的请求在五分钟内，在不同响应时间区间的处理的数量的变化情况</li></ul></li></ul><a href=#构建支撑生产的监控系统><h2 id=构建支撑生产的监控系统><span class=hanchor arialabel=Anchor># </span>构建支撑生产的监控系统</h2></a><ul><li>Metrics<ul><li>收集数据</li></ul></li><li>Alert<ul><li>创建告警规则，如果告警规则被触发，则按不同眼中程度来告警</li></ul></li><li>Assertion<ul><li>以一定时间间隔，模拟客户行为，操作kubernetes对象，并断言成功，如果不成功则按眼中程度告警</li></ul></li></ul><a href=#来自生产系统的经验分享><h2 id=来自生产系统的经验分享><span class=hanchor arialabel=Anchor># </span>来自生产系统的经验分享</h2></a><ul><li>Prometheus需要大内存和存储<ul><li>最初prometheus经常发生OOM kill</li><li>在提高指定的资源以后，如果发生crash或者重启，prometheus需要30分钟以上的时间来读取数据进行初始化</li></ul></li><li>Prometheus是运营生产系统过程中最重要的模块<ul><li>如果prometheus down机，则没有任何数据和告警，管理员两眼一黑，什么都不知道了</li></ul></li></ul></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li>No backlinks found</li></ul></div><div><script async src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://obsidian.codeplayer.org/js/graph.6579af7b10c818dbd2ca038702db0224.js></script></div></div><div id=contact_buttons><footer><p>Made by Patrick Zhao using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, © 2023</p><ul><li><a href=https://obsidian.codeplayer.org/>Home</a></li><li><a href=https://github.com/PetrusZ>GitHub</a></li><li><a href=https://t.me/Petrus_Z>Telegram</a></li><li><a href=mailto:silencly07@gmail.com>Email</a></li></ul></footer></div><hr><script src=https://giscus.app/client.js data-repo=PetrusZ/ObsidianPublish data-repo-id=R_kgDOJTGL0A data-category=Announcements data-category-id=DIC_kwDOJTGL0M4CVohQ data-mapping=title data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=preferred_color_scheme data-lang=zh-CN crossorigin=anonymous async></script></div></body></html>