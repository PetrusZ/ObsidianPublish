<!doctype html><html lang=en><head><script async defer data-website-id=de560d7e-374a-4694-943f-f3f01b8dba46 src=https://umami.codeplayer.org:1443/umami.js></script>
<script>function _howxm(){_howxmQueue.push(arguments)}window._howxmQueue=window._howxmQueue||[],_howxm("setAppID","21c1239b-b2d0-45c5-8eab-246d8b16a9d6"),function(){if(t="howxm_script",!document.getElementById(t)){var t,e=document.createElement("script"),n=document.getElementsByTagName("script")[0];e.setAttribute("id",t),e.type="text/javascript",e.async=!0,e.src="https://static.howxm.com/sdk.js",n.parentNode.insertBefore(e,n)}}()</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-PCXDEM5E1Q"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-PCXDEM5E1Q",{anonymize_ip:!1})}</script><meta charset=utf-8><meta name=description content="Docker 基于 Linux 内核的 Cgroup，Namespace，以及 Union FS 等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术，由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。
最初实现是基于 LXC，从 0.7 以后开始去除 LXC，转而使用自行开发的 Libcontainer，从 1.11 开始，则进一步演进为使用 runC 和 Containerd。
Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护，使得 Docker 技术比虚拟机技术更为轻便、快捷。"><meta property="og:title" content="核心技术"><meta property="og:description" content="Docker 基于 Linux 内核的 Cgroup，Namespace，以及 Union FS 等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术，由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。
最初实现是基于 LXC，从 0.7 以后开始去除 LXC，转而使用自行开发的 Libcontainer，从 1.11 开始，则进一步演进为使用 runC 和 Containerd。
Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护，使得 Docker 技术比虚拟机技术更为轻便、快捷。"><meta property="og:type" content="website"><meta property="og:image" content="https://obsidian.codeplayer.org/icon.png"><meta property="og:url" content="https://obsidian.codeplayer.org/CS/Docker/%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"><meta property="og:width" content="200"><meta property="og:height" content="200"><meta name=twitter:card content="summary"><meta name=twitter:title content="核心技术"><meta name=twitter:description content="Docker 基于 Linux 内核的 Cgroup，Namespace，以及 Union FS 等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术，由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。
最初实现是基于 LXC，从 0.7 以后开始去除 LXC，转而使用自行开发的 Libcontainer，从 1.11 开始，则进一步演进为使用 runC 和 Containerd。
Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护，使得 Docker 技术比虚拟机技术更为轻便、快捷。"><meta name=twitter:image content="https://obsidian.codeplayer.org/icon.png"><title>核心技术</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://obsidian.codeplayer.org//icon.png><link href=https://obsidian.codeplayer.org/styles.80333fa2099c0bee674efa435fde378c.min.css rel=stylesheet><link href=https://obsidian.codeplayer.org/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://obsidian.codeplayer.org/js/darkmode.245a0a31da505f6b327aec1fcae860c8.min.js></script>
<script src=https://obsidian.codeplayer.org/js/util.00639692264b21bc3ee219733d38a8be.min.js></script>
<link rel=preload href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css as=style onload='this.onload=null,this.rel="stylesheet"' integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/core@1.2.1></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/dom@1.2.1></script>
<script async src=https://obsidian.codeplayer.org/js/popover.aa9bc99c7c38d3ae9538f218f1416adb.min.js></script>
<script defer src=https://obsidian.codeplayer.org/js/code-title.ce4a43f09239a9efb48fee342e8ef2df.min.js></script>
<script defer src=https://obsidian.codeplayer.org/js/clipboard.2913da76d3cb21c5deaa4bae7da38c9f.min.js></script>
<script defer src=https://obsidian.codeplayer.org/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const SEARCH_ENABLED=!1,LATEX_ENABLED=!0,PRODUCTION=!0,BASE_URL="https://obsidian.codeplayer.org/",fetchData=Promise.all([fetch("https://obsidian.codeplayer.org/indices/linkIndex.beae18c0a7355f78b9b2bda39e0b109b.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://obsidian.codeplayer.org/indices/contentIndex.b4d828d0b712007c8ddb2f7c263d68e4.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://obsidian.codeplayer.org",!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!1;drawGraph("https://obsidian.codeplayer.org",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}var i=document.getElementsByClassName("mermaid");i.length>0&&import("https://unpkg.com/mermaid@9/dist/mermaid.esm.min.mjs").then(e=>{e.default.init()});function a(n){const e=n.target,t=e.className.split(" "),s=t.includes("broken"),o=t.includes("internal-link");plausible("Link Click",{props:{href:e.href,broken:s,internal:o,graph:!1}})}const r=document.querySelectorAll("a");for(link of r)link.className.includes("root-title")&&link.addEventListener("click",a,{once:!0})},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'’':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/obsidian.codeplayer.org\/js\/router.d6fe6bd821db9ea97f9aeefae814d8e7.min.js"
    attachSPARouting(init, render)
  </script><script defer data-domain=obsidian.codeplayer.org src=https://plausible.io/js/script.js></script>
<script>window.plausible=window.plausible||function(){(window.plausible.q=window.plausible.q||[]).push(arguments)}</script></head><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://obsidian.codeplayer.org/js/full-text-search.e6e2e0c213187ca0c703d6e2c7a77fcd.min.js></script><div class=singlePage><header><h1 id=page-title><a class=root-title href=https://obsidian.codeplayer.org/>Avalon Obsidian Vault</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>核心技术</h1><p class=meta>Last updated
Apr 9, 2023
<a href=https://github.com/PetrusZ/avalon-obsidian-vault/tree/main/CS/Docker/%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af.md rel=noopener>Edit Source</a></p><ul class=tags><li><a href=https://obsidian.codeplayer.org/tags/CS/Docker/>Cs docker</a></li></ul><aside class=mainTOC><details open><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#docker>Docker</a></li><li><a href=#oci-容器标准>OCI 容器标准</a></li><li><a href=#docker-引擎架构>Docker 引擎架构</a></li><li><a href=#namespace>Namespace</a><ol><li><a href=#pid-namespace>pid namespace</a></li><li><a href=#net-namespace>net namespace</a></li><li><a href=#ipc-namespace>ipc namespace</a></li><li><a href=#mnt-namespace>mnt namespace</a></li><li><a href=#uts-namespace>uts namespace</a></li><li><a href=#user-namespace>user namespace</a></li><li><a href=#关于-namespace-的常用操作>关于 namespace 的常用操作</a></li></ol></li><li><a href=#cgroups>Cgroups</a><ol><li><a href=#可配额可度量>可配额/可度量</a></li><li><a href=#cpu子系统>CPU子系统</a><ol><li><a href=#linux-调度器>Linux 调度器</a></li><li><a href=#cfs-调度器>CFS 调度器</a></li><li><a href=#vruntime-红黑树>vruntime 红黑树</a></li></ol></li><li><a href=#cpuacct-子系统>cpuacct 子系统</a></li><li><a href=#memory-子系统>Memory 子系统</a></li><li><a href=#cgroup-driver>Cgroup driver</a></li></ol></li><li><a href=#文件系统>文件系统</a><ol><li><a href=#union-fs>Union FS</a></li><li><a href=#容器镜像>容器镜像</a></li><li><a href=#overlay-fs>Overlay FS</a></li></ol></li><li><a href=#网络>网络</a><ol><li><a href=#docker的网络模式>Docker的网络模式</a></li><li><a href=#默认模式-网桥和-nat>默认模式– 网桥和 NAT</a></li><li><a href=#underlay>Underlay</a></li><li><a href=#docker-libnetwork-overlay>Docker Libnetwork Overlay</a></li><li><a href=#vxlan>VXLAN</a></li><li><a href=#overlay-network-sample--flannel>Overlay network sample – Flannel</a></li></ol></li></ol></nav></details></aside><a href=#docker><h1 id=docker><span class=hanchor arialabel=Anchor># </span>Docker</h1></a><p>基于 Linux 内核的 Cgroup，Namespace，以及 Union FS 等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术，由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。</p><p>最初实现是基于 LXC，从 0.7 以后开始去除 LXC，转而使用自行开发的 Libcontainer，从 1.11 开始，则进一步演进为使用 runC 和 Containerd。</p><p>Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护，使得 Docker 技术比虚拟机技术更为轻便、快捷。</p><a href=#oci-容器标准><h1 id=oci-容器标准><span class=hanchor arialabel=Anchor># </span>OCI 容器标准</h1></a><ul><li>Open Container Initiative<ul><li>OCI 组织于 2015 年创建，是一个致力于定义容器镜像标准和运行时标准的开放式组织。</li><li>OCI 定义了镜像标准（Runtime Specification）、运行时标准（Image Specification）和分发标准（Distribution Specification）<ul><li>镜像标准定义应用如何打包</li><li>运行时标准定义如何解压应用包并运行</li><li>分发标准定义如何分发容器镜像</li></ul></li></ul></li></ul><a href=#docker-引擎架构><h1 id=docker-引擎架构><span class=hanchor arialabel=Anchor># </span>Docker 引擎架构</h1></a><p><img src=https://obsidian.codeplayer.org//Assets/image_1665734926295_0.png width=auto alt=image.png></p><a href=#namespace><h1 id=namespace><span class=hanchor arialabel=Anchor># </span>Namespace</h1></a><ul><li>Linux Namespace 是一种 Linux Kernel 提供的资源隔离方案：<ul><li>系统可以为进程分配不同的 Namespace；</li><li>并保证不同的 Namespace 资源独立分配、进程彼此隔离，即不同的 Namespace 下的进程互不干扰。</li></ul></li></ul><a href=#pid-namespace><h2 id=pid-namespace><span class=hanchor arialabel=Anchor># </span>pid namespace</h2></a><p>不同用户的进程就是通过 Pid namespace 隔离开的，且不同 namespace 中可以有相同 Pid。</p><p>有了 Pid namespace, 每个 namespace 中的 Pid 能够相互隔离。</p><a href=#net-namespace><h2 id=net-namespace><span class=hanchor arialabel=Anchor># </span>net namespace</h2></a><p>网络隔离是通过 net namespace 实现的， 每个 net namespace 有独立的 network devices, IP addresses, IP routing tables, /proc/net 目录。</p><p>Docker 默认采用 veth 的方式将 container 中的虚拟网卡同 host 上的一个 docker bridge: docker0 连接在一起。</p><a href=#ipc-namespace><h2 id=ipc-namespace><span class=hanchor arialabel=Anchor># </span>ipc namespace</h2></a><p>Container 中进程交互还是采用 linux 常见的进程间交互方法 （interprocess communication – IPC）, 包括常见的信号量、消息队列和共享内存。</p><p>Container 的进程间交互实际上还是 host上 具有相同 Pid namespace 中的进程间交互，因此需要在 IPC资源申请时加入 namespace 信息 - 每个 IPC 资源有一个唯一的 32 位 ID。</p><a href=#mnt-namespace><h2 id=mnt-namespace><span class=hanchor arialabel=Anchor># </span>mnt namespace</h2></a><p>mnt namespace 允许不同 namespace 的进程看到的文件结构不同，这样每个 namespace 中的进程所看到的文件目录就被隔离开了。</p><a href=#uts-namespace><h2 id=uts-namespace><span class=hanchor arialabel=Anchor># </span>uts namespace</h2></a><p>UTS(“UNIX Time-sharing System”) namespace允许每个 container 拥有独立的 hostname 和domain name, 使其在网络上可以被视作一个独立的节点而非 Host 上的一个进程。</p><a href=#user-namespace><h2 id=user-namespace><span class=hanchor arialabel=Anchor># </span>user namespace</h2></a><p>每个 container 可以有不同的 user 和 group id, 也就是说可以在 container 内部用 container 内部的用户执行程序而非 Host 上的用户。</p><a href=#关于-namespace-的常用操作><h2 id=关于-namespace-的常用操作><span class=hanchor arialabel=Anchor># </span>关于 namespace 的常用操作</h2></a><ul><li>查看当前系统的 namespace：<ul><li><code>lsns –t &lt;type></code></li></ul></li><li>查看某进程的 namespace：<ul><li><code>ls -la /proc/&lt;pid>/ns/</code></li></ul></li><li>进入某 namespace 运行命令：<ul><li><code>nsenter -t &lt;pid> -n ip addr</code></li></ul></li></ul><a href=#cgroups><h1 id=cgroups><span class=hanchor arialabel=Anchor># </span>Cgroups</h1></a><p>Cgroups （Control Groups）是 Linux 下用于对一个或一组进程进行资源控制和监控的机制；</p><p>可以对诸如 CPU 使用时间、内存、磁盘 I/O 等进程所需的资源进行限制；</p><p>不同资源的具体管理工作由相应的 Cgroup 子系统（Subsystem）来实现 ；</p><p>针对不同类型的资源限制，只要将限制策略在不同的的子系统上进行关联即可 ；</p><p>Cgroups 在不同的系统资源管理子系统中以层级树（Hierarchy）的方式来组织管理：每个 Cgroup 都可以包含其他的子 Cgroup，因此子 Cgroup 能使用的资源除了受本 Cgroup 配置的资源参数限制，还受到父Cgroup 设置的资源限制。</p><a href=#可配额可度量><h2 id=可配额可度量><span class=hanchor arialabel=Anchor># </span>可配额/可度量</h2></a><p>cgroups 实现了对资源的配额和度量</p><p><strong>blkio</strong>：这个子系统设置限制每个块设备的输入输出控制。例如:磁盘，光盘以及 USB 等等。</p><p><strong>CPU</strong>：这个子系统使用调度程序为 cgroup 任务提供 CPU 的访问。</p><p><strong>cpuacct</strong>： 产生 cgroup 任务的 CPU 资源报告。</p><p><strong>cpuset</strong>： 如果是多核心的 CPU，这个子系统会为 cgroup 任务分配单独的 CPU 和内存。</p><p><strong>devices</strong>： 允许或拒绝 cgroup</p><p><strong>freezer</strong>： 暂停和恢复 cgroup 任务。</p><p><strong>memory</strong>： 设置每个 cgroup 的内存限制以及产生内存资源报告。</p><p><strong>net_cls</strong>： 标记每个网络包以供 cgroup 方便使用。</p><p><strong>ns</strong>：名称空间子系统。</p><p><strong>pid</strong>：进程标识子系统。</p><a href=#cpu子系统><h2 id=cpu子系统><span class=hanchor arialabel=Anchor># </span>CPU子系统</h2></a><p>cpu.shares：可出让的能获得 CPU 使用时间的相对值。</p><p><img src=https://obsidian.codeplayer.org//Assets/image_1665679422886_0.png width=auto alt=image.png>{:height 118, :width 245}</p><p>cpu.cfs_period_us：cfs_period_us 用来配置时间周期长度，单位为 us（微秒）。</p><p>cpu.cfs_quota_us：cfs_quota_us 用来配置当前 Cgroup 在 cfs_period_us 时间内最多能使用的 CPU 时间数，单位为 us（微秒）。</p><p><img src=https://obsidian.codeplayer.org//Assets/image_1665679444552_0.png width=auto alt=image.png>{:height 153, :width 251}</p><p>cpu.stat ：Cgroup 内的进程使用的 CPU 时间统计。</p><p>nr_periods ：经过 cpu.cfs_period_us 的时间周期数量。</p><p>nr_throttled ：在经过的周期内，有多少次因为进程在指定的时间周期内用光了配额时间而受到限制。</p><p>throttled_time ：Cgroup 中的进程被限制使用 CPU 的总用时，单位是 ns（纳秒）。</p><a href=#linux-调度器><h3 id=linux-调度器><span class=hanchor arialabel=Anchor># </span>Linux 调度器</h3></a><p>内核默认提供了5个调度器，Linux 内核使用 struct sched_class 来对调度器进行抽象：</p><p>Stop 调度器，stop_sched_class：优先级最高的调度类，可以抢占其他所有进程，不能被其他进程抢占；</p><p>Deadline 调度器，dl_sched_class：使用红黑树，把进程按照绝对截止期限进行排序，选择最小进程进行调度运行；</p><p>RT 调度器， rt_sched_class：实时调度器，为每个优先级维护一个队列；</p><p><strong>CFS 调度器， cfs_sched_class：完全公平调度器，采用完全公平调度算法，引入虚拟运行时间概念；</strong></p><p>IDLE-Task 调度器， idle_sched_class：空闲调度器，每个 CPU 都会有一个 idle 线程，当没有其他进程可以调度时，调度运行 idle 线程。</p><a href=#cfs-调度器><h3 id=cfs-调度器><span class=hanchor arialabel=Anchor># </span>CFS 调度器</h3></a><p>CFS 是 Completely Fair Scheduler 简称，即完全公平调度器。</p><p>CFS 实现的主要思想是维护为任务提供处理器时间方面的平衡，这意味着应给进程分配相当数量的处理器。</p><p>分给某个任务的时间失去平衡时，应给失去平衡的任务分配时间，让其执行。</p><p>CFS 通过虚拟运行时间（vruntime）来实现平衡，维护提供给某个任务的时间量。</p><p><code>vruntime = 实际运行时间*1024 / 进程权重</code></p><p>进程按照各自不同的速率在物理时钟节拍内前进，优先级高则权重大，其虚拟时钟比真实时钟跑得慢，但获得比较多的运行时间。</p><a href=#vruntime-红黑树><h3 id=vruntime-红黑树><span class=hanchor arialabel=Anchor># </span>vruntime 红黑树</h3></a><p>CFS 调度器没有将进程维护在运行队列中，而是维护了一个以虚拟运行时间为顺序的红黑树。 红黑树的主要特点有：</p><ol><li><p>自平衡，树上没有一条路径会比其他路径长出俩倍。</p></li><li><p>O(log n) 时间复杂度，能够在树上进行快速高效地插入或删除进程。</p></li></ol><p><img src=https://obsidian.codeplayer.org//Assets/image_1665679904583_0.png width=auto alt=image.png></p><a href=#cpuacct-子系统><h2 id=cpuacct-子系统><span class=hanchor arialabel=Anchor># </span>cpuacct 子系统</h2></a><ul><li>用于统计 Cgroup 及其子 Cgroup 下进程的 CPU 的使用情况。<ul><li>cpuacct.usage<ul><li>包含该 Cgroup 及其子 Cgroup 下进程使用 CPU 的时间，单位是 ns（纳秒）。</li></ul></li><li>cpuacct.stat<ul><li>包含该 Cgroup 及其子 Cgroup 下进程使用的 CPU 时间，以及用户态和内核态的时间。</li></ul></li></ul></li></ul><a href=#memory-子系统><h2 id=memory-子系统><span class=hanchor arialabel=Anchor># </span>Memory 子系统</h2></a><ul><li>memory.usage_in_bytes<ul><li>cgroup 下进程使用的内存，包含 cgroup 及其子 cgroup 下的进程使用的内存</li></ul></li><li>memory.max_usage_in_bytes<ul><li>cgroup 下进程使用内存的最大值，包含子 cgroup 的内存使用量。</li></ul></li><li>memory.limit_in_bytes<ul><li>设置 cgroup 下进程最多能使用的内存。如果设置为 -1，表示对该 cgroup 的内存使用不做限制。</li></ul></li><li>memory.soft_limit_in_bytes<ul><li>这个限制并不会阻止进程使用超过限额的内存，只是在系统内存足够时，会优先回收超过限额的内存，使之向限定值靠拢。</li></ul></li><li>memory.oom_control<ul><li><strong>设置是否在 Cgroup 中使用 OOM（Out of Memory）Killer，默认为使用。当属于该 cgroup 的进程使用的内存超过最大的限定值时，会立刻被 OOM Killer 处理。</strong></li></ul></li></ul><a href=#cgroup-driver><h2 id=cgroup-driver><span class=hanchor arialabel=Anchor># </span>Cgroup driver</h2></a><ul><li>systemd:<ul><li>当操作系统使用 systemd 作为 init system 时，初始化进程生成一个根 cgroup 目录结构并作为 cgroup管理器。</li><li>systemd 与 cgroup 紧密结合，并且为每个 systemd unit 分配 cgroup。</li></ul></li><li>cgroupfs:<ul><li>docker 默认用 cgroupfs 作为 cgroup 驱动。</li></ul></li><li>存在问题：<ul><li>在 systemd 作为 init system 的系统中，默认并存着两套 groupdriver。</li><li>这会使得系统中 Docker 和 kubelet 管理的进程被 cgroupfs 驱动管，而 systemd 拉起的服务由systemd 驱动管，让 cgroup 管理混乱且容易在资源紧张时引发问题。</li><li><strong>因此 kubelet 会默认&ndash;cgroup-driver=systemd，若运行时 cgroup 不一致时，kubelet 会报错</strong></li></ul></li></ul><a href=#文件系统><h1 id=文件系统><span class=hanchor arialabel=Anchor># </span>文件系统</h1></a><a href=#union-fs><h2 id=union-fs><span class=hanchor arialabel=Anchor># </span>Union FS</h2></a><p>将不同目录挂载到同一个虚拟文件系统下 （unite several directories into a single virtual filesystem）的文件系统</p><p>支持为每一个成员目录（类似Git Branch）设定 readonly、readwrite 和 whiteout-able 权限</p><p>文件系统分层, 对 readonly 权限的 branch 可以逻辑上进行修改(增量地, 不影响 readonly 部分的)。</p><p>通常 Union FS 有两个用途, 一方面可以将多个 disk 挂到同一个目录下, 另一个更常用的就是将一个readonly 的 branch 和一个 writeable 的 branch 联合在一起。</p><a href=#容器镜像><h2 id=容器镜像><span class=hanchor arialabel=Anchor># </span>容器镜像</h2></a><p><img src=https://obsidian.codeplayer.org//Assets/image_1665732577611_0.png width=auto alt=image.png></p><a href=#overlay-fs><h2 id=overlay-fs><span class=hanchor arialabel=Anchor># </span>Overlay FS</h2></a><p>OverlayFS 也是一种与 AUFS 类似的联合文件系统，同样属于文件级的存储驱动，包含了最初的 Overlay 和更新更稳定的 overlay2。</p><p><strong>Overlay 只有两层：upper 层和 lower 层，Lower 层代表镜像层，upper 层代表容器可写层。</strong></p><p><img src=https://obsidian.codeplayer.org//Assets/image_1665733112134_0.png width=auto alt=image.png></p><a href=#网络><h1 id=网络><span class=hanchor arialabel=Anchor># </span>网络</h1></a><a href=#docker的网络模式><h2 id=docker的网络模式><span class=hanchor arialabel=Anchor># </span>Docker的网络模式</h2></a><ul><li>Null(&ndash;net=None)<ul><li>把容器放入独立的网络空间但不做任何网络配置；</li><li>用户需要通过运行 docker network 命令来完成网络配置。</li></ul></li><li>Host<ul><li>使用主机网络名空间，复用主机网络。</li></ul></li><li>Container<ul><li>重用其他容器的网络。</li></ul></li><li>Bridge(&ndash;net=bridge)<ul><li>使用 Linux 网桥和 iptables 提供容器互联，Docker 在每台主机上创建一个名叫 docker0的网桥，通过 veth p</li></ul></li><li>Overlay(libnetwork, libkv)<ul><li>通过网络封包实现。</li></ul></li><li>Remote(work with remote drivers)<ul><li>Underlay：<ul><li>使用现有底层网络，为每一个容器配置可路由的网络 IP。</li></ul></li><li>Overlay：<ul><li>通过网络封包实现</li></ul></li></ul></li></ul><a href=#默认模式-网桥和-nat><h2 id=默认模式-网桥和-nat><span class=hanchor arialabel=Anchor># </span>默认模式– 网桥和 NAT</h2></a><ul><li>为主机 eth0 分配 IP 192.168.0.101；</li><li>启动 docker daemon，查看主机 iptables；<ul><li>POSTROUTING -A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE</li></ul></li><li>在主机启动容器：<ul><li>docker run -d &ndash;name ssh -p 2333:22 centos-ssh</li><li>Docker 会以标准模式配置网络：<ul><li>创建 veth pair；</li><li>将 veth pair的一端连接到 docker0 网桥；</li><li>veth pair 的另外一端设置为容器名空间的 eth0；</li><li>为容器名空间的 eth0 分配 ip；</li><li>主机上的 Iptables 规则：PREROUTING -A DOCKER ! -i docker0 -p tcp -m tcp &ndash;dport 2333 -j DNAT &ndash;todestination 172.17.0.2:22。</li></ul></li></ul></li></ul><p><img src=https://obsidian.codeplayer.org//Assets/image_1665738983058_0.png width=auto alt=image.png></p><a href=#underlay><h2 id=underlay><span class=hanchor arialabel=Anchor># </span>Underlay</h2></a><p>采用 Linux 网桥设备（sbrctl），通过物理网络连通容器；</p><p>创建新的网桥设备 mydr0；</p><p>将主机网卡加入网桥；</p><p>把主机网卡的地址配置到网桥，并把默认路由规则转移到网桥 mydr0；</p><p>启动容器；</p><p>创建 veth 对，并且把一个 peer 添加到网桥 mydr0；</p><p>配置容器把 veth 的另一个 peer 分配给容器网卡；</p><p><img src=https://obsidian.codeplayer.org//Assets/image_1665739288260_0.png width=auto alt=image.png></p><a href=#docker-libnetwork-overlay><h2 id=docker-libnetwork-overlay><span class=hanchor arialabel=Anchor># </span>Docker Libnetwork Overlay</h2></a><p>Docker overlay 网络驱动原生支持多主机网络；</p><p>Libnetwork 是一个内置的基于 VXLAN 的网络驱动。</p><a href=#vxlan><h2 id=vxlan><span class=hanchor arialabel=Anchor># </span>VXLAN</h2></a><p><img src=https://obsidian.codeplayer.org//Assets/image_1665739423844_0.png width=auto alt=image.png>{:height 580, :width 714}</p><a href=#overlay-network-sample--flannel><h2 id=overlay-network-sample--flannel><span class=hanchor arialabel=Anchor># </span>Overlay network sample – Flannel</h2></a><p>同一主机内的 Pod 可以使用网桥进行通信。</p><p>不同主机上的 Pod 将通过flanneld 将其流量封装在 UDP数据包中 。</p><p><img src=https://obsidian.codeplayer.org//Assets/image_1665739505611_0.png width=auto alt=image.png></p></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li>No backlinks found</li></ul></div><div><script async src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://obsidian.codeplayer.org/js/graph.6579af7b10c818dbd2ca038702db0224.js></script></div></div><div id=contact_buttons><footer><p>Made by Patrick Zhao using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, © 2023</p><ul><li><a href=https://obsidian.codeplayer.org/>Home</a></li><li><a href=https://github.com/PetrusZ>GitHub</a></li><li><a href=https://t.me/Petrus_Z>Telegram</a></li><li><a href=mailto:silencly07@gmail.com>Email</a></li></ul></footer></div><hr><script src=https://giscus.app/client.js data-repo=PetrusZ/ObsidianPublish data-repo-id=R_kgDOJTGL0A data-category=Announcements data-category-id=DIC_kwDOJTGL0M4CVohQ data-mapping=title data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=preferred_color_scheme data-lang=zh-CN crossorigin=anonymous async></script></div></body></html>