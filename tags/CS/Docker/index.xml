<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>CS/Docker on</title><link>https://obsidian.codeplayer.org/tags/CS/Docker/</link><description>Recent content in CS/Docker on</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://obsidian.codeplayer.org/tags/CS/Docker/index.xml" rel="self" type="application/rss+xml"/><item><title>Dockerfile</title><link>https://obsidian.codeplayer.org/CS/Docker/Dockerfile/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://obsidian.codeplayer.org/CS/Docker/Dockerfile/</guid><description>回顾 12 Factor 之进程 [[系统架构#12 factors|12 factors]]
运行环境中，应用程序通常是以一个和多个进程运行的。 12-Factor 应用的进程必须无状态（Stateless）且无共享（Share nothing）。 任何需要持久化的数据都要存储在后端服务内，比如数据库。 应在构建阶段将源代码编译成待执行应用。 Session Sticky 是 12-Factor 极力反对的。 Session 中的数据应该保存在诸如 Memcached 或 Redis 这样的带有过期时间的缓存中 Docker 遵循以上原则管理和构建应用。 理解构建上下文（Build Context） 当运行 docker build 命令时，当前工作目录被称为构建上下文。 docker build 默认查找当前目录的 Dockerfile 作为构建输入，也可以通过 –f 指定 Dockerfile。 docker build –f .</description></item><item><title>常用命令</title><link>https://obsidian.codeplayer.org/CS/Docker/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://obsidian.codeplayer.org/CS/Docker/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid><description>远程构建image 使用build构建 1 2 3 DOCKER_HOST=&amp;#34;ssh://user@docker-build.dev&amp;#34; docker build -t {tag} . docker use context remote-build-host &amp;amp;&amp;amp; docker build -t {tag} .</description></item><item><title>核心技术</title><link>https://obsidian.codeplayer.org/CS/Docker/%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://obsidian.codeplayer.org/CS/Docker/%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/</guid><description>Docker 基于 Linux 内核的 Cgroup，Namespace，以及 Union FS 等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术，由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。
最初实现是基于 LXC，从 0.7 以后开始去除 LXC，转而使用自行开发的 Libcontainer，从 1.11 开始，则进一步演进为使用 runC 和 Containerd。
Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护，使得 Docker 技术比虚拟机技术更为轻便、快捷。</description></item></channel></rss>