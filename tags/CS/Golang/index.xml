<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>CS/Golang on</title><link>https://obsidian.codeplayer.org/tags/CS/Golang/</link><description>Recent content in CS/Golang on</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://obsidian.codeplayer.org/tags/CS/Golang/index.xml" rel="self" type="application/rss+xml"/><item><title>GMP</title><link>https://obsidian.codeplayer.org/Cards/CS/Golang/GMP/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/Cards/CS/Golang/GMP/</guid><description>有关系统的进程和进程的知识，可参考 [[Linux进程]]
协程 进程： 分配系统资源（CPU 时间、内存等）基本单位 有独立的内存空间，切换开销大 线程：进程的一个执行流，是 CPU 调度并能独立运行的的基本单位 同一进程中的多线程共享内存空间，线程切换代价小 多线程通信方便 从内核层面来看线程其实也是一种特殊的进程，它跟父进程共享了打开的文件和文件系统信息，共享了地址空间和信号处理函数 协程 Go 语言中的轻量级线程实现 Golang 在 runtime、系统调用等多方面对 goroutine 调度进行了封装和处理，当遇到长时间执行或者进行系统调用时，会主动把当前 goroutine 的 CPU (P) 转让出去，让其他 goroutine 能被调度并执行，也就是 Golang 从语言层面支持了协程 线程和协程的差异 每个 goroutine (协程) 默认占用内存远比 Java 、C 的线程少 goroutine：2KB 线程：8MB 线程/goroutine 切换开销方面，goroutine 远比线程小 线程：涉及模式切换(从用户态切换到内核态)、16个寄存器、PC、SP&amp;hellip;等寄存器的刷新 goroutine：只有三个寄存器的值修改 - PC / SP / DX.</description></item><item><title>Modules</title><link>https://obsidian.codeplayer.org/Cards/CS/Golang/Modules/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/Cards/CS/Golang/Modules/</guid><description>开启modules
$ go env -w GO111MODULE=on</description></item><item><title>Proxy</title><link>https://obsidian.codeplayer.org/Cards/CS/Golang/Proxy/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/Cards/CS/Golang/Proxy/</guid><description>GOPROXY 和 GOPRIVAT 为拉取 Go 依赖设置代理
export GOPROXY=https://goproxy.cn
在设置 GOPROXY 以后，默认所有依赖拉取都需要经过 proxy 连接 git repo，拉取代码，并做checksum 校验
某些私有代码仓库是 goproxy.cn 无法连接的，因此需要设置 GOPRIVATE 来声明私有代码仓库</description></item><item><title>内存管理</title><link>https://obsidian.codeplayer.org/Cards/CS/Golang/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/Cards/CS/Golang/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid><description>堆内存管理 堆内存管理 初始化连续内存块作为堆
有内存申请的时候，Allocator 从堆内存的未分配区域分割小内存块
用链表将已分配内存连接起来
需要信息描述每个内存块的元数据：大小，是否使用，下一个内存块的地址等
TCMalloc 概览 page:内存页，一块 8K 大小的内存空间。Go 与操作系统之间的内存申请和释放，都是以page 为单位
span: 内存块，一个或多个连续的 page 组成一个 span</description></item><item><title>面向对象</title><link>https://obsidian.codeplayer.org/Cards/CS/Golang/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</link><pubDate>Sun, 09 Apr 2023 14:51:49 +0800</pubDate><guid>https://obsidian.codeplayer.org/Cards/CS/Golang/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</guid><description>常用方法 可见性控制 public - 常量、变量、类型、接口、结构、函数等的名称大写 private - 非大写就只能在包内使用 继承 通过组合实现，内嵌一个或多个 struct 多态 通过接口实现，通过接口定义方法集，编写多套实现</description></item></channel></rss>